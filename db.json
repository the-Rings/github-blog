{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/css/noscript.styl","path":"css/noscript.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/comments.js","path":"js/comments.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/config.js","path":"js/config.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/pjax.js","path":"js/pjax.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/rating.js","path":"js/third-party/rating.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/hexo-build-guide.md","hash":"d833fde76ea7856bb0b213cb906b62fb8c256720","modified":1640833217738},{"_id":"source/_posts/java-arraylist.md","hash":"c0edabe2f0a78d3f04d7e197b48400ffa2cbf2e6","modified":1640832448293},{"_id":"source/_posts/java-chain-of-responsibility.md","hash":"4cdf7f8476ca57b958da0fe317ba23ca4268a37b","modified":1640832468767},{"_id":"source/_posts/hello-world.md","hash":"f145a6fecbbd2421680d07429125d7799eea0f59","modified":1640833220035},{"_id":"source/_posts/java-classloader.md","hash":"09d011e06b3a637f26133085df1526dd4d112eb1","modified":1640833275553},{"_id":"source/_posts/java-annotation.md","hash":"712b8f43893cf4a1c1376e58bed396ff6cf3a199","modified":1640833239701},{"_id":"source/_posts/java-inner-class.md","hash":"ea1c57de65ce9639e73ab1037d052c3c8f77e1fe","modified":1640832621081},{"_id":"source/_posts/build-multi-module-project-best-practice.md","hash":"afe56f79bdc79a65a9fce6ac8ea5b39679383957","modified":1640833187716},{"_id":"source/_posts/java-factory-pattern.md","hash":"18df24dc89ee4cf9450256490578e3ce17a6bc56","modified":1640833288015},{"_id":"source/_posts/java-functional-programming.md","hash":"6b553ebca694c55b60a10ba894f0764896f43d5f","modified":1640833297188},{"_id":"source/_posts/maven-wrapper.md","hash":"6c1630f525365d3d9fb41b9a92e0b6a6f3727a63","modified":1640832696861},{"_id":"source/_posts/java-proxy-and-dynamic-proxy.md","hash":"2dad0cb965f702d18359d634ea66f237d4bcda8d","modified":1640833403209},{"_id":"source/_posts/serialization-deserialization.md","hash":"812ea2d37831fc24ee47d08c93cb9783acfacbbc","modified":1640832858957},{"_id":"source/_posts/professional-dictionary.md","hash":"8440e337384789a1090ebabb28710f98bdb3e395","modified":1640833450420},{"_id":"source/_posts/java-reflection.md","hash":"766bba6e227b1d2ddc01a9dde055ae93df158a1e","modified":1640833412637},{"_id":"source/_posts/java-streams.md","hash":"549218ee853b523eaf4762fc8d4023fec98f2bef","modified":1640833421445},{"_id":"source/_posts/theory-turing-completeness.md","hash":"564dddfa3499e6719fc9eabfb7c18fb6a52e6030","modified":1640833508334},{"_id":"source/about/index.md","hash":"5e3341da64449a4c7cf2ed4d079e60d5189c4c2c","modified":1640832362120},{"_id":"source/categories/index.md","hash":"c5894bd83309dc828ec96f45e8b3c319cfa5c254","modified":1640831234813},{"_id":"source/tags/index.md","hash":"09f5bca4764facf81df1aedfba0d15a74f6c69c7","modified":1640831178244},{"_id":"source/_posts/spring-ioc.md","hash":"cad403c4acefe52d8980e9b4ff23c32948b15771","modified":1640833499355},{"_id":"source/_posts/spring-aop.md","hash":"a57ffb3740aa728dc25c11c6e7a2ffbe30b721f2","modified":1640833475728},{"_id":"source/_posts/spring-autoconfigurations.md","hash":"58068fe1fb8a1554de810ddcc3357dfe1ca657b4","modified":1640833490332},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1635390119513},{"_id":"themes/next/.eslintrc.json","hash":"611e15c3fcb41dc68fa8532ee595a1262a1b5a8a","modified":1635390119513},{"_id":"themes/next/.gitattributes","hash":"aeeca2f1e987d83232d7870d1435a4e3ed66b648","modified":1635390119513},{"_id":"themes/next/.gitignore","hash":"087b7677078303acb2acb47432165950e4d29b43","modified":1635390119519},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1635390119520},{"_id":"themes/next/LICENSE.md","hash":"8cfb03967dd4cbaf3b825271ffce0039aa3fc22a","modified":1635390119520},{"_id":"themes/next/README.md","hash":"43fe29330352545446a532e6630866251129882a","modified":1635390119520},{"_id":"themes/next/_config.yml","hash":"1b0c2cb41687bf002f359e7ee7cceea27374d3a9","modified":1635412984372},{"_id":"themes/next/_vendors.yml","hash":"9875822de1108765fca9f299af68ad460169c1b1","modified":1635390119522},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1635390119522},{"_id":"themes/next/package.json","hash":"6bffbde3c06fe12b2f51d42ea8686a11a7d8150c","modified":1635390119546},{"_id":"themes/next/renovate.json","hash":"767b077c7b615e20af3cf865813cd64674a9bea6","modified":1635390119546},{"_id":"themes/next/.githooks/install.js","hash":"305c2a269818466eed9e381b866c6cd1ad7f8afd","modified":1635390119514},{"_id":"themes/next/.githooks/pre-commit","hash":"b69b9d0b51e27d5d4c87c3242f5067c2cda26e44","modified":1635390119514},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"593ae64e72d43c020a697eac65b1f9c3483ff097","modified":1635390119514},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"2fdca1040427cabfe27cae6754ec5e027ec7092e","modified":1635390119515},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"a103e2d875f7434191859e5b42075cfa9a4cbcb3","modified":1635390119516},{"_id":"themes/next/.github/config.yml","hash":"0956bf71b6f36632b63b14d26580458041a5abd2","modified":1635390119516},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1635390119517},{"_id":"themes/next/.github/label-commenter-config.yml","hash":"a1aa85a2fc66ff0c52c65bd97b0fa282e297a73f","modified":1635390119517},{"_id":"themes/next/.github/labeler.yml","hash":"ff76a903609932a867082b8ccced906e9910533a","modified":1635390119517},{"_id":"themes/next/.github/release-drafter.yml","hash":"de38f816e3023e0a5c1fd1f3c2b626f78bc35246","modified":1635390119517},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1635390119522},{"_id":"themes/next/docs/AUTHORS.md","hash":"579014d47f45b27fd1618b9709f0efe9585c7449","modified":1635390119522},{"_id":"themes/next/docs/LICENSE.txt","hash":"d1cd5a8e83d3bbdb50f902d2b487813da95ddfd3","modified":1635390119523},{"_id":"themes/next/languages/README.md","hash":"b1c96465b3bc139bf5ba6200974b66581d8ff85a","modified":1635390119524},{"_id":"themes/next/languages/ar.yml","hash":"cc7e3e2855348563d746f15c4752b9c63fcdd91a","modified":1635390119524},{"_id":"themes/next/languages/de.yml","hash":"83023c4246b93a2f89f342afe29a7b9e1185f74f","modified":1635390119525},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1635390119525},{"_id":"themes/next/languages/en.yml","hash":"66445143decfbb5eb7031eb370698e31d5222a7a","modified":1635390119525},{"_id":"themes/next/languages/es.yml","hash":"07955d78028cea2a590c63fdc2c01ca3ee05a727","modified":1635390119525},{"_id":"themes/next/languages/fa.yml","hash":"e09fad889ab3ae87874093e1acd51edc9297d869","modified":1635390119526},{"_id":"themes/next/languages/fr.yml","hash":"328c255c82e9b561e20a9f51a4d84abc63d1b90a","modified":1635390119526},{"_id":"themes/next/languages/id.yml","hash":"d7c337ca72efb0bd02ade8b5560c559384ad84dd","modified":1635390119526},{"_id":"themes/next/languages/it.yml","hash":"c038ff0cadbe405750d980bcacfd3900acf96905","modified":1635390119526},{"_id":"themes/next/languages/ja.yml","hash":"57a35b21aca04ce8bca64fb5933f35626c462ea3","modified":1635390119526},{"_id":"themes/next/languages/ko.yml","hash":"d6e2add7488065ec4f7d21cfcf7f0eaa877a84f4","modified":1635390119527},{"_id":"themes/next/languages/nl.yml","hash":"e47858bd1e0d0622c15366ae6c0513d996f589e3","modified":1635390119527},{"_id":"themes/next/languages/pt-BR.yml","hash":"305025e932832328b7e2a8a584638a23c462e68f","modified":1635390119527},{"_id":"themes/next/languages/pt.yml","hash":"ff93459250c33d3c7ba06c30164cc4208edf9b33","modified":1635390119527},{"_id":"themes/next/languages/ru.yml","hash":"7d13108f4a70ff6a162508a49678e4a477fa7b56","modified":1635390119528},{"_id":"themes/next/languages/si.yml","hash":"c15ed758dbad890e856f4fc281208d7b78cc1a59","modified":1635390119528},{"_id":"themes/next/languages/tr.yml","hash":"d3262d2221b0583a52e5d20a3cd1380f5dc49378","modified":1635390119528},{"_id":"themes/next/languages/uk.yml","hash":"f32871f67c63d26bc4e3e15df9b01f5a41236a50","modified":1635390119528},{"_id":"themes/next/languages/vi.yml","hash":"e452ea8c48993262a3e8fce9d92072cafabfc734","modified":1635390119528},{"_id":"themes/next/languages/zh-CN.yml","hash":"f8379d15038e22ef7039d91272cb4f36842dbbe1","modified":1635390119529},{"_id":"themes/next/languages/zh-HK.yml","hash":"c1ee97ceb56da76ecdc7b69fa975f28c8574441b","modified":1635390119529},{"_id":"themes/next/languages/zh-TW.yml","hash":"70c45076ad722b777956048fcc430eac37844c11","modified":1635390119529},{"_id":"themes/next/layout/_layout.njk","hash":"2842f3e9fdde5bbd14cac89629221e68d80c8ea1","modified":1635390119529},{"_id":"themes/next/layout/archive.njk","hash":"aa491dba8f746e626c273a920effedf7d0b32170","modified":1635390119545},{"_id":"themes/next/layout/category.njk","hash":"c243c94abe62ec1e7da73067ac2db147f9a42416","modified":1635390119545},{"_id":"themes/next/layout/index.njk","hash":"92db3756ad46718a0cbb0d2bda02218bd865a63d","modified":1635390119545},{"_id":"themes/next/layout/page.njk","hash":"5fd0c362019eac987e17954dc85287b682195c76","modified":1635390119546},{"_id":"themes/next/layout/post.njk","hash":"707a50e50b90df5fbeaf8407d12895d04163a290","modified":1635390119546},{"_id":"themes/next/layout/tag.njk","hash":"64148c8f6b623391433595ae691ff64d7941d8af","modified":1635390119546},{"_id":"themes/next/test/index.js","hash":"983a505399796b9d9e174ba46d89abbdde38f8ee","modified":1635390119587},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"032194e7975564176f2109aa8b7c020fa6d5e6b1","modified":1635390119515},{"_id":"themes/next/.github/ISSUE_TEMPLATE/config.yml","hash":"daeedc5da2ee74ac31cf71846b766ca6499e9fc6","modified":1635390119515},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"4a7885fe2c8b25be02ab57c345cd862aeeeeacaf","modified":1635390119515},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"618d07b49f4774cd79613d4001984a19d954a6ad","modified":1635390119516},{"_id":"themes/next/.github/workflows/label-commenter.yml","hash":"7dec949b13131783e726facb2f4acde0945db1b8","modified":1635390119518},{"_id":"themes/next/.github/workflows/labeler.yml","hash":"46d0b29dc561fe571d91fd06a7c8ef606b984c72","modified":1635390119518},{"_id":"themes/next/.github/workflows/linter.yml","hash":"b57d876c90d1645a52bbba8a52d47ad0b0c96140","modified":1635390119518},{"_id":"themes/next/.github/workflows/lock.yml","hash":"58eca481fd71088a8ae1dbc04645bcfc03460b87","modified":1635390119518},{"_id":"themes/next/.github/workflows/release-drafter.yml","hash":"359b74890a47d784e35a5cc3c7885d5cdf302e82","modified":1635390119518},{"_id":"themes/next/.github/workflows/stale.yml","hash":"32e7dfb55ecf8af66aebfed471be09ef2eb10e18","modified":1635390119518},{"_id":"themes/next/.github/workflows/tester.yml","hash":"645bb69d0b6cc062c47fabb1ccb2297ccbcfa7f5","modified":1635390119519},{"_id":"themes/next/docs/ru/README.md","hash":"e1d6bf38cf34972ca2ee5331a727787fe14082a3","modified":1635390119523},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7befb4325b107dd668d9eae3d7e86a34910ce3f2","modified":1635390119523},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"a09ceb82b45dd8b7da76c227f3d0bb7eebe7d5d1","modified":1635390119524},{"_id":"themes/next/docs/zh-CN/README.md","hash":"354b0b0a24cbe97cccf2ec8bd97eb7d624fa0dea","modified":1635390119524},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"d9d8e6d7a6a8c80009dd5334cc17fd3e4977a008","modified":1635390119530},{"_id":"themes/next/layout/_macro/post.njk","hash":"e81c2c9f6f7c8c1395b6dd3ff67ed424a1c62394","modified":1635390119530},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"eec74e135d01948361020140c3798769e1e7363b","modified":1635390119530},{"_id":"themes/next/layout/_partials/comments.njk","hash":"d6b7bb7764e3b471ed6b4e5715f6cbe2dd453f59","modified":1635390119530},{"_id":"themes/next/layout/_partials/footer.njk","hash":"65f0d69084e0e26a0153d3b8db610a15c4102691","modified":1635390119531},{"_id":"themes/next/layout/_partials/languages.njk","hash":"537026fc120adeef9148c98ebf074207e3810538","modified":1635390119532},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1635390119534},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"967594ee64805e27b7ff9d957e23ab3f5c948600","modified":1635390119538},{"_id":"themes/next/layout/_scripts/index.njk","hash":"4eb65641b47ea9b23ed2ddfd69b18f21d7d8f214","modified":1635390119538},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"0a1470440f11362df2b1cd6b6228e273d9f999d6","modified":1635390119538},{"_id":"themes/next/layout/_third-party/fancybox.njk","hash":"53ad3c31762b74e5d29787b37d5e494cc4fded9b","modified":1635390119541},{"_id":"themes/next/layout/_third-party/index.njk","hash":"33a4a3275474bd3bb2e8d1b0ea01b42dda9ea608","modified":1635390119542},{"_id":"themes/next/layout/_third-party/pace.njk","hash":"13b2a77b4858a127f458ea092b6f713b052befac","modified":1635390119543},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"73bc15a9c3c5c239ab90efa19a1e721f41f3cb93","modified":1635390119543},{"_id":"themes/next/layout/_third-party/rating.njk","hash":"d0444179fec512760ab1d4f76928d795b971c884","modified":1635390119543},{"_id":"themes/next/scripts/events/index.js","hash":"8bca7ae3cebb3857866d718a562c5d8820fcfbe5","modified":1635390119547},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"0c9a1fe9906672724dbf274154a37bac1915ca2c","modified":1635390119551},{"_id":"themes/next/scripts/filters/locals.js","hash":"8499b9c8c6cdae8aa7e4f5ec5b4b76037969db76","modified":1635390119551},{"_id":"themes/next/scripts/filters/minify.js","hash":"9789307212d729c8cb65e3541348938a1965ff6f","modified":1635390119551},{"_id":"themes/next/scripts/filters/post.js","hash":"5a132b7f9280a40b3d5fb40928c8cbbe071fe6f6","modified":1635390119551},{"_id":"themes/next/scripts/helpers/engine.js","hash":"18cc82558e7a9f3b6086c41ce9de0c46e807a66c","modified":1635390119551},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"e73f43f1bcb46965e317285d6831e129a40ea59b","modified":1635390119552},{"_id":"themes/next/scripts/helpers/font.js","hash":"0a6fa582a0890ecaf5f03f758a730936e48aeca1","modified":1635390119552},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"98fc68cf3fcd6253bbb94068ab1d86578a4ef9ea","modified":1635390119552},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"52acbc74c1ead8a77cd3bbcba4e033053683f7d0","modified":1635390119552},{"_id":"themes/next/scripts/tags/button.js","hash":"86c71c73a63744efbbbb367612871fede0d69529","modified":1635390119553},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"8e912c715702addaf0cefe63e580e45b97ae8c3f","modified":1635390119553},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"b4d12e6fe29089be0f43bafc9eea736602cd16bf","modified":1635390119553},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"4cf2002bcd5a6851aea68e9a1971e6399f5c3ed2","modified":1635390119553},{"_id":"themes/next/scripts/tags/index.js","hash":"255dd1090e8319b557eeca43571f0e4f8aab013b","modified":1635390119553},{"_id":"themes/next/scripts/tags/label.js","hash":"c18b0e619a779ed40be7f014db92af18f45fbd5c","modified":1635390119554},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"3f358bb78c5c6fdf45de287f3ead553e3a6a93c2","modified":1635390119554},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"b3844e168b51a99d495ca05562ffac47677f5728","modified":1635390119554},{"_id":"themes/next/scripts/tags/note.js","hash":"a12fd53e421400836a3722ae69130969558d6ac0","modified":1635390119555},{"_id":"themes/next/scripts/tags/pdf.js","hash":"317ba4611020cc840854386dde098dbbe452777e","modified":1635390119555},{"_id":"themes/next/scripts/tags/tabs.js","hash":"e0ed5fe1bc9d2957952a1aacdf3252d6ef3f9743","modified":1635390119555},{"_id":"themes/next/scripts/tags/video.js","hash":"f6ad3f52779f0636251238d3cbdc5b6f91cc5aba","modified":1635390119555},{"_id":"themes/next/source/css/_colors.styl","hash":"ae65cee0940b73b40f4f335c1d3cbc5ff600ef38","modified":1635390119556},{"_id":"themes/next/source/css/_mixins.styl","hash":"2ca820b221fb7458e6ef4fbcff826e1d1cf4b473","modified":1635390119571},{"_id":"themes/next/source/css/main.styl","hash":"38b8a12681a3a04bed02aa1659054912ed6def11","modified":1635390119575},{"_id":"themes/next/source/css/noscript.styl","hash":"7dc97674c232f6ca71e48b95e3f66472cd8e9c05","modified":1635390119576},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1635390119576},{"_id":"themes/next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1635390119576},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1635390119577},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1635390119577},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1635390119577},{"_id":"themes/next/source/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1635390119577},{"_id":"themes/next/source/js/bookmark.js","hash":"1457291a7244b7786ec35b949d97183e4fbd181d","modified":1635390119578},{"_id":"themes/next/source/js/comments-buttons.js","hash":"81ea6cbcdf0357094753d7523919c1eafa38e79f","modified":1635390119578},{"_id":"themes/next/source/js/comments.js","hash":"0b4daf0ce610760bd52e95d423f61f3e1c72442a","modified":1635390119578},{"_id":"themes/next/source/js/config.js","hash":"211a9ab35205ccfa6b7c74394bade84da0d00af7","modified":1635390119578},{"_id":"themes/next/source/js/motion.js","hash":"20b979ebe3671cb415e6e7171485d65cc347086e","modified":1635390119579},{"_id":"themes/next/source/js/next-boot.js","hash":"b0bdb542a809932182cfbb8772328115142a0b77","modified":1635390119579},{"_id":"themes/next/source/js/pjax.js","hash":"fd954af9b333e26574acafa1642eb7c86b85b7a2","modified":1635390119579},{"_id":"themes/next/source/js/schedule.js","hash":"6dade4388aa6579576a35758075134f573985d57","modified":1635390119579},{"_id":"themes/next/source/js/utils.js","hash":"c13fa66aae52f59f88881738c00ebdcaf0209496","modified":1635390119587},{"_id":"themes/next/test/helpers/font.js","hash":"6f5076bd3f2724e47b46ca69028393a9b6275cd1","modified":1635390119587},{"_id":"themes/next/test/helpers/index.js","hash":"2fb58dca3df2fe53116ee2b1232fa26ebe7b2ce5","modified":1635390119587},{"_id":"themes/next/test/helpers/next-url.js","hash":"08e84781f1cd54e5634b86877ad9cefae4a78e95","modified":1635390119587},{"_id":"themes/next/test/tags/button.js","hash":"a50ca44eaec3d91c2958e3157d624cd3e68828c7","modified":1635390119588},{"_id":"themes/next/test/tags/center-quote.js","hash":"2ac4b5a358681691a17e736de06fce0b640a7023","modified":1635390119588},{"_id":"themes/next/test/tags/caniuse.js","hash":"2852be850d9103c25114253a45e6c62e32517de4","modified":1635390119588},{"_id":"themes/next/test/tags/group-pictures.js","hash":"d7eb1d4402bf96485e69d5944db6aef8f10c8097","modified":1635390119588},{"_id":"themes/next/test/tags/index.js","hash":"5cad001936a694bf32d59751cc2b68a66199f976","modified":1635390119588},{"_id":"themes/next/test/tags/label.js","hash":"6cad7d84c42511459a89cda3971e8ea5cdee0125","modified":1635390119588},{"_id":"themes/next/test/tags/link-grid.js","hash":"41730266306c02362258384cd73659223928361f","modified":1635390119589},{"_id":"themes/next/test/tags/mermaid.js","hash":"f718a3d0e303d842e2ca5a3b162539a49e45a520","modified":1635390119589},{"_id":"themes/next/test/tags/note.js","hash":"161a81ce749e239d2403681372d48ecc1b51d7b9","modified":1635390119589},{"_id":"themes/next/test/tags/pdf.js","hash":"2d114596a8a180b2f3cd2a9c6528a328961f12d4","modified":1635390119589},{"_id":"themes/next/test/tags/tabs.js","hash":"b19d2592347eae5d6a7a97ca7e8cec03e8f25b51","modified":1635390119590},{"_id":"themes/next/test/tags/video.js","hash":"88db9a3a26cd35525c43c0339fcd1c5965ec9518","modified":1635390119590},{"_id":"themes/next/test/validate/index.js","hash":"560862194991c5963da5a411629d8e6c71d20ee2","modified":1635390119590},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"bd87e3a877ebab4508fc2b48b41c96b45c4dd970","modified":1635390119531},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"abcc550cb14374fb7452d6edee63967ad9583d1c","modified":1635390119531},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"5d02ca876f25038c9f9e1d789c6ebae9ef71ae00","modified":1635390119531},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"2f550b53372ec150c2538f216399995b8c003a21","modified":1635390119532},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"f066390762faf6684a523e2eb943420023aac2b1","modified":1635390119532},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"cb841a7a5db322dacd18c23074be300460aa6353","modified":1635390119532},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"940cad08a67e6c361214045096bd3cdffdf44fcf","modified":1635390119532},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"9c136edd2248e2d50c1f6110b75e2b75c299bbd7","modified":1635390119533},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"b352346dd2cb42f7eeaec5e39d9a2a353b029775","modified":1635390119533},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"92553feb26f30f7fc9147bc4ef122908a9da06be","modified":1635390119533},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"130e776575d634201d4f8ef3d78dc12624f19fde","modified":1635390119533},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"752df7d12360a077c51a25609916a3ecc1763bb3","modified":1635390119533},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"0ebc0142abebbeef4278e32abb543c7d7fa75d88","modified":1635390119535},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"ebf83083856f8bd81ad47ffb985d44e338b4e6bb","modified":1635390119535},{"_id":"themes/next/layout/_partials/post/post-footer.njk","hash":"e3502059bcc443ce932946a9891fcbe8b2bb362d","modified":1635390119535},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"2d99d7f355770f16934f5a3836887b118fb4d4bb","modified":1635390119535},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"80d3dac42740d2aef677e25165e31c05eb048887","modified":1635390119536},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"58b3f657a47bae406e5fcf19cd5e42680785ac71","modified":1635390119536},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"93fbb449fbd599cb4315d7eb0daeb239811b233f","modified":1635390119536},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"9766852e72c1809d8c1eea71ac6116b4cc0886d2","modified":1635390119537},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"f73d25a8ccfdd5d4ca2953dc434ff8ce36034c57","modified":1635390119537},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"0b96ee7ccd602e0ee3fc6db47228803771308d4f","modified":1635390119537},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"3e80332f88b101141be69f2a07f54ed8c053eabb","modified":1635390119538},{"_id":"themes/next/layout/_third-party/analytics/cloudflare.njk","hash":"c7cea42f6db2137c11ca1d83e43fcb7ad7ccfb89","modified":1635390119539},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"52ad137450f7b3d6a330e16b3ed1c6174290f0eb","modified":1635390119539},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"9ff9ec05c2037beea229a6bb698f9e3546973220","modified":1635390119539},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"465fcffd4216f8ca0ea2613fe9cf7308f71b9da5","modified":1635390119539},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"09d2c9487d75894d45a823e3237ae9f90fd6ee01","modified":1635390119540},{"_id":"themes/next/layout/_third-party/chat/gitter.njk","hash":"375a86f0b19e130cfa7707007e3a53d9ae7c9b64","modified":1635390119540},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"3fbc72427c1211e5dcfd269af1a74852a7ba5c1a","modified":1635390119540},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"5f7967bd946060f4102263a552ddfbae9975e7ea","modified":1635390119540},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"b0828dd1b1fd66ecd612d9e886a08e7579e9a4f7","modified":1635390119540},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"c5086b4c35f730f82c99c4a8317f2f153ebde869","modified":1635390119540},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"6fd4df5c21cfe530dbb0c012bc0b202f2c362b9c","modified":1635390119540},{"_id":"themes/next/layout/_third-party/comments/isso.njk","hash":"38badcc7624a13961381c2465478056b9602aee5","modified":1635390119541},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"b8e0d5de584cece5e05b03db5b86145aa1e422b4","modified":1635390119541},{"_id":"themes/next/layout/_third-party/comments/utterances.njk","hash":"a7921be7328e1509d33b435175f5333a9aada66f","modified":1635390119541},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"1856c4b035c5b8e64300a11af0461b519dfc4cf4","modified":1635390119542},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"a84db8bc8804335f95609a221ac1746433dcdc89","modified":1635390119542},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"a62aa1ed4e35b8d0451d83f341bf0a97538bc9a4","modified":1635390119542},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"67f67a77f27103177b9940446f43610229536d82","modified":1635390119543},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"210c32b654adae3d8076c4417d370b42af258cea","modified":1635390119543},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"d97790e4b442a1e3ded7d7b4f84b8ee6cdb6e8ea","modified":1635390119544},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"af5336e8bbdc4638435971da115bb7443d374ade","modified":1635390119544},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"866ffa15a3250678eb8a90aa6f609fa965db90fd","modified":1635390119544},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"8703d1855bb8d251c9b7c2940b7e3be525e53000","modified":1635390119544},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"dd8f963acd5a3685be46fd5319c06df0308d99b2","modified":1635390119544},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"0386c708975cc5faea4f782611c5d2c6b8ac2850","modified":1635390119545},{"_id":"themes/next/scripts/events/lib/config.js","hash":"a912944cae0d864458d365867b8a9c89f348e68a","modified":1635390119547},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"00cec6980cafd417def885f496371856cd524a25","modified":1635390119547},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"1f1ea7b579a49f17574c31d78d663c54896133eb","modified":1635390119548},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"8508e96a5f883a5a57d8c1b8b5ea438fa29aafd3","modified":1635390119548},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"2f7057a8d3fce08aa7e2a17d7b7a1f03ac3d8ed6","modified":1635390119548},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"cfff8331fdaa2ede4ab08c58cfc6d98c7d2374d9","modified":1635390119549},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"713056d33dbcd8e9748205c5680b456c21174f4e","modified":1635390119549},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"1cb58aa6b88f7461c3c3f9605273686adcc30979","modified":1635390119549},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"3283bdd6e5ac7d10376df8ddd5faaec5dc1bd667","modified":1635390119549},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"70eb507ef7f1a4fc3ca71a3814cc57afe7f3f60c","modified":1635390119549},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"96e58efba0dc76af409cc7d2db225f0fe4526ea8","modified":1635390119549},{"_id":"themes/next/scripts/filters/comment/isso.js","hash":"c22cbccd7d514947e084eeac6a3af1aa41ec857a","modified":1635390119550},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"bb8ebb541c40362c0cbbd8e83d3b777302bb6c40","modified":1635390119550},{"_id":"themes/next/scripts/filters/comment/utterances.js","hash":"a50718c081685fd35ff8ea9ca13682c284399ed8","modified":1635390119550},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"c4537fa2de33d98baff2c87a73801770414e0b69","modified":1635390119574},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"ee5024be8e39605f0c6d71db038e15e0693d0f41","modified":1635390119574},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"d3a8f6e71c86926d0c2a247a31d7446d829736d5","modified":1635390119575},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"58014a2d087c4126058a99b5b1cb7d8a2eb6224d","modified":1635390119575},{"_id":"themes/next/source/css/_variables/base.styl","hash":"d8882613736f43cab31bd5e1aa4e1265e903d305","modified":1635390119575},{"_id":"themes/next/source/js/schemes/muse.js","hash":"e18fc7074a580509dd5f966eb55428eb86730393","modified":1635390119580},{"_id":"themes/next/source/js/third-party/fancybox.js","hash":"8a847a7bbdbc0086dd1de12b82107a854b43f5e5","modified":1635390119583},{"_id":"themes/next/source/js/third-party/pace.js","hash":"0ebee77b2307bf4b260afb06c060171ef42b7141","modified":1635390119584},{"_id":"themes/next/source/js/third-party/quicklink.js","hash":"539c5bb51244f7f4aa98884f3229d128c1cefc40","modified":1635390119585},{"_id":"themes/next/source/js/third-party/rating.js","hash":"a1f44247c18ac00ee3e0026560398429e4c77dd7","modified":1635390119585},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"2bbf9046ef2a8f99ef3668bbb8be4e52e9d97bb7","modified":1635390119556},{"_id":"themes/next/source/css/_common/components/index.styl","hash":"991c1f80995cec418dc00d3d6b13e2d911ac9894","modified":1635390119556},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"f3defd56be33dba4866a695396d96c767ce63182","modified":1635390119560},{"_id":"themes/next/source/css/_common/outline/index.styl","hash":"7782dfae7a0f8cd61b936fa8ac980440a7bbd3bb","modified":1635390119563},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"2db4462e9cb87b8aef3f50f850fed407de16da3e","modified":1635390119563},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"ca4d03a96ccc606151cf3f6ae8c9cea7fdc86bf7","modified":1635390119566},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"f768ecb2fe3e9384777c1c115cd7409e9155edd7","modified":1635390119566},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"cf8446f4378dcab27b55ede1635c608ae6b8a5c8","modified":1635390119566},{"_id":"themes/next/source/css/_common/scaffolding/index.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1635390119567},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1635390119568},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"34416a5792d0235caa8c0c7e59725f2df0fa614c","modified":1635390119568},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"b9388016f8d9274703e77e306a1feaad1b7b9d6c","modified":1635390119569},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"90f7d3baab061e860172b536c9edc38c7fd2ef5c","modified":1635390119571},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"f51b6a4f06359ed56b2d10caa6f15362d3b3751d","modified":1635390119571},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b1054313ca9419e76fea0451417c881616f50a38","modified":1635390119572},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"00366a6bd1a66f99f845c5ebfc9e8cf56651b815","modified":1635390119572},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f337981f8f20944ed366694aea88146c7b0a13ab","modified":1635390119572},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"c9a9e07b721bb2376e24753ae0a9452431439114","modified":1635390119572},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"89bf3f6b82cb0fafbbd483431df8f450857c5a0b","modified":1635390119572},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"fd89988442f380cba907752fe3f608e3498f8c93","modified":1635390119573},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"018b6a761e197086174c9f06b4d5ea21cc230951","modified":1635390119573},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"28030c61288cc0e1321b18373a5c79029fd76a53","modified":1635390119573},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"134272cb8096156c9e32fbbe085394633c7509cd","modified":1635390119573},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1635390119573},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1635390119573},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"9b2cba0c9aa5a64957294f7548c199db1f63f0f4","modified":1635390119573},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"9f60d501808f67d151af437221d0dfacc27c180c","modified":1635390119573},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"1d29eca70fa686d895f8e98a283e4a159e40905a","modified":1635390119573},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"42bf453def88da82c842dca84e8f47087091f08e","modified":1635390119573},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b5c3dd08c520a16ee49f85fa12b4935e725ef261","modified":1635390119573},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"7905f428b46d100ac5928875cb1e2b99fa86fc0b","modified":1635390119574},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","hash":"f9579a02599de063ccff336177ba964a2931a6e9","modified":1635390119580},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","hash":"d77d4934d959e7125128754b568f1d041c3fbfff","modified":1635390119580},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","hash":"f755e8537ccbbb0bd84c26923f320d4e206e7428","modified":1635390119580},{"_id":"themes/next/source/js/third-party/chat/chatra.js","hash":"72e0766752b78a723fb30e92d533a8b353104e2d","modified":1635390119581},{"_id":"themes/next/source/js/third-party/chat/gitter.js","hash":"14b024c920a8b359777d79dd8e1a849387f8f3ad","modified":1635390119581},{"_id":"themes/next/source/js/third-party/chat/tidio.js","hash":"77c231bcd64f1c09bd9989909e9fee703b65f47f","modified":1635390119581},{"_id":"themes/next/source/js/third-party/comments/changyan.js","hash":"b1dd519dc3b1153c9d2ba2d35f68ca8f73f33bae","modified":1635390119581},{"_id":"themes/next/source/js/third-party/comments/disqus.js","hash":"5460de247c038d6cfbe774d7f8747f0a958d9017","modified":1635390119582},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","hash":"1c282d6c2151346d1f0aa95055d17abe77054ec9","modified":1635390119582},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","hash":"1e8509356fb027d948d118ab220d9631f4d482fa","modified":1635390119582},{"_id":"themes/next/source/js/third-party/comments/isso.js","hash":"b9b9fd2f0e098a123b34a4932da912a9485ffe6c","modified":1635390119582},{"_id":"themes/next/source/js/third-party/comments/livere.js","hash":"68892d74ef5fc308c6e7e6b4f190826d79f3055d","modified":1635390119582},{"_id":"themes/next/source/js/third-party/comments/utterances.js","hash":"ec44d7f1c8b51b0aa3cccba099a78f3575ac828c","modified":1635390119583},{"_id":"themes/next/source/js/third-party/math/katex.js","hash":"5c63ec71458b4fe0cd98fd4a04e11c3746764f11","modified":1635390119583},{"_id":"themes/next/source/js/third-party/math/mathjax.js","hash":"d93556184b2c0aa1dbc4a6fb892d2f77b80d7d9f","modified":1635390119583},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","hash":"ea94731438d8c518d946601f8f46a65b92381fac","modified":1635390119585},{"_id":"themes/next/source/js/third-party/search/local-search.js","hash":"dc2b0e89aa32afc7f7a7e2d7a277dadb7f96e06d","modified":1635390119585},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","hash":"d0829fe41d2fe86b8499e2a896556c1275ea0066","modified":1635390119586},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","hash":"6abdc209f4503d4efd676e18bc30ddea813b6ff9","modified":1635390119586},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","hash":"2618135cbcee6bf228f6734767de1995e5eaaac6","modified":1635390119586},{"_id":"themes/next/source/js/third-party/tags/pdf.js","hash":"e109c2d6828f527f0289d5fa3bb02fce63ee6d93","modified":1635390119586},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fde10ce94e9ae21a03b60d41d532835b54abdcb1","modified":1635390119556},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"80595d274f593b321c0b644a06f3165fe07b16f5","modified":1635390119557},{"_id":"themes/next/source/css/_common/components/pages/index.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1635390119557},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"091b8c763e43447d087c122a86538f290f83136a","modified":1635390119557},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"56d719bcdcba3d725141c55bbd4b168f3942f912","modified":1635390119557},{"_id":"themes/next/source/css/_common/components/post/index.styl","hash":"df2fbd0ada00f37439b0de965c6f1c29d3c97429","modified":1635390119557},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"7a34d020877273dcf11c25fa481409300efb8659","modified":1635390119558},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"e53a5eb1d1771e284044bdb0bc0ed2de27923669","modified":1635390119558},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"c34936a17c3d8af6c0988ac6746d7509dc0b50eb","modified":1635390119559},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"4d29b6ae7ed3dc44b10df851a4128b6441efa8be","modified":1635390119559},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"69dff7cf231d01f85671758455726dd666664a73","modified":1635390119560},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"9043d9bc2db35ca000c79258ef89fdb161dc43fb","modified":1635390119560},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"0a779f955a0e25df0852e0731517dadb234aa181","modified":1635390119560},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"eebe3013a9a976011570dce2d04dfeae4c31d790","modified":1635390119558},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"fb165c1a0d990c5cf98b87773e0dc50410229b96","modified":1635390119560},{"_id":"themes/next/source/css/_common/components/third-party/index.styl","hash":"8df4b0023880ebe10de6b28d951e59286fba97e3","modified":1635390119560},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"1e5776ad4c5c8bcf7596ac74dcabc30704b3f5a0","modified":1635390119561},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"791bc9befb0d4d06e3e517eccfe0bc3551a02a60","modified":1635390119558},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"0527153aa821bdbdb84c7b47f60e3cefd95a742f","modified":1635390119561},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"ab5e2023e863ba6ca6ba4d288fea2877dcd3ad82","modified":1635390119561},{"_id":"themes/next/source/css/_common/components/third-party/utterances.styl","hash":"d28856f365a9373c4ae6fe1e5673d63df2dfd65f","modified":1635390119561},{"_id":"themes/next/source/css/_common/outline/footer/index.styl","hash":"02b6d1a53f7a02c6b0929b11f3ab904b5b873a0e","modified":1635390119562},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"c8648c8ea3105556be0068d9fb2735261d0d94bc","modified":1635390119562},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"05af22f3edc2383a3d97ec4c05e9ac43b014bead","modified":1635390119562},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"2db695204d39e4c7daa7b91585a0ea4b06b49f11","modified":1635390119563},{"_id":"themes/next/source/css/_common/outline/header/index.styl","hash":"67fc7a1eb59c8451eec34e572cbb2fd1424757bc","modified":1635390119562},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"aa1de16f693dd6aa66adc5728cce112f0b6fbe38","modified":1635390119563},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"d9bc2b520636b9df7f946295cd430593df4118ff","modified":1635390119563},{"_id":"themes/next/source/css/_common/outline/sidebar/index.styl","hash":"9964a96f9a647cfb16b97679eced79d07e084e6d","modified":1635390119564},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2c2bfbc34b6f19d262ae7c041474985e12f4f4ad","modified":1635390119564},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"d8a028f532d562e6a86bb3b9c7b992e4b6dbbb51","modified":1635390119564},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"1c324d56ae83e96db2c4c6d63edd7ee51c936fc1","modified":1635390119564},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"63d8f5f169c2b1c969928fc79244c5fe89ee484e","modified":1635390119564},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"57ed6770535ecb2e6485a0c87d4de6d6476368b9","modified":1635390119565},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"db4f3263b2b6551dd56bfdf33cceaf81661a3611","modified":1635390119565},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"081345490271840855d1238b969dbf2e0a2bba8f","modified":1635390119566},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"6681ffe283f8a7e3c86310ef4f6ca1e499c1a19f","modified":1635390119566},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2de038def2cb91da143b14696366c14a66e0e569","modified":1635390119566},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"a4003e1408844568cb5102a5a111046cb19b2d31","modified":1635390119567},{"_id":"themes/next/source/css/_common/scaffolding/highlight/index.styl","hash":"5f706f3382652835379cf9b9fec24ccd4513ab65","modified":1635390119567},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"6b3680e0dbea8e14c1cec24ef63b7fae5e37f7ef","modified":1635390119569},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"8d9218980e185210ce034e9769ab639b9630fd88","modified":1635390119569},{"_id":"themes/next/source/css/_common/scaffolding/tags/index.styl","hash":"e22fde6f1657d311d46f64d868c4491d535c8caa","modified":1635390119569},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"531daf2612c6217950677a2d03924459ce57c291","modified":1635390119569},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7075dd32dd70da1e161e4bd14b46f1e8be62fa3c","modified":1635390119570},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"c7754dc6c866928b538f0863a05b96ec44b5e986","modified":1635390119570},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"2e9dc3b3546e19e9de18050ad04b1741841116bc","modified":1635390119570},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"77122986509a6b4968bae2729417b7016137534c","modified":1635390119570},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"40a38f2129617ffd4e8d5cd78e982fdfc9941acf","modified":1635390119571},{"_id":"public/search.xml","hash":"341e7e75be26277488e74249351c7f765beddcce","modified":1640833652847},{"_id":"public/about/index.html","hash":"e83748bf7666e6a8419fb25ae343ae41bef750d3","modified":1640833652847},{"_id":"public/categories/index.html","hash":"a7667e4e635ac4b40fa8a054a23ae59cc70a11eb","modified":1640833652847},{"_id":"public/tags/index.html","hash":"c73309ac35b50d2647676868db58c8744d6849ef","modified":1640833652847},{"_id":"public/2021/11/22/serialization-deserialization/index.html","hash":"e210ae4d1fb71a450276aaae313ceb5548d5e9cf","modified":1640833652847},{"_id":"public/2021/11/04/java-inner-class/index.html","hash":"45d182f0c475eaaa0e20741eb4f56e19e5f4f79e","modified":1640833652847},{"_id":"public/2021/05/27/hello-world/index.html","hash":"cfc137857412e7e53861dbe822269c8cf659b906","modified":1640833652847},{"_id":"public/archives/index.html","hash":"c59d4772fcc784c84da48090869cd3817173a628","modified":1640833652847},{"_id":"public/archives/page/2/index.html","hash":"b5264a0ee5a96a693b8077c44ca47361bb012a35","modified":1640833652847},{"_id":"public/archives/2021/index.html","hash":"0232e162817cf48ec27eba40ba33662d0d40f1fd","modified":1640833652847},{"_id":"public/archives/2021/page/2/index.html","hash":"75a0c74528ed70535c2082795a793eb25672dea5","modified":1640833652847},{"_id":"public/archives/2021/05/index.html","hash":"df9f41c535cf41efd62e50bdfa5cbea4aafc0a2f","modified":1640833652847},{"_id":"public/archives/2021/06/index.html","hash":"3740a740d18aefaf8edd44c2349af624f6aae1a0","modified":1640833652847},{"_id":"public/archives/2021/07/index.html","hash":"578427c500a75b0478054bcf5efd8af018b19101","modified":1640833652847},{"_id":"public/archives/2021/08/index.html","hash":"bb6f1412c58bea93fe2ce8f4b8522d554bb746c0","modified":1640833652847},{"_id":"public/archives/2021/09/index.html","hash":"0a65a74fc06e3d9e497c2a2f62951f0b518be6bc","modified":1640833652847},{"_id":"public/archives/2021/10/index.html","hash":"758152f45da3c09a4c441ebaa59f1af752a0002d","modified":1640833652847},{"_id":"public/archives/2021/11/index.html","hash":"23f583ea5ffc7eb4ea79f42f925036975a4f88a7","modified":1640833652847},{"_id":"public/categories/Package-Manager/index.html","hash":"b229ae46ca579fd8b1b3e72445b2f12a34ce572b","modified":1640833652847},{"_id":"public/categories/Hexo/index.html","hash":"90e38ae21036274bcf9ebfe0f48fdea99c81962b","modified":1640833652847},{"_id":"public/categories/Java/index.html","hash":"44ec780f7195561f9274c77b7f6dc6640ac4317c","modified":1640833652847},{"_id":"public/categories/Pattern/index.html","hash":"a88f228d3a555adedcaf64c9f8bbda35453e00de","modified":1640833652847},{"_id":"public/categories/Java/Pattern/index.html","hash":"4ea4eaf4fb018880b4385de8bf675175ab0a9716","modified":1640833652847},{"_id":"public/categories/专业词汇/index.html","hash":"9faebbcf461ade7495f0c9b4940ceb6df2a71bc8","modified":1640833652847},{"_id":"public/categories/Spring/index.html","hash":"b51d9c5ac41a57dca9621da64825d38fdeacd8d4","modified":1640833652847},{"_id":"public/categories/计算机理论/index.html","hash":"3d820fda149f37b1b446898c45aad5d3ab364c08","modified":1640833652847},{"_id":"public/tags/ClassLoader/index.html","hash":"81c74e9b811d5724a43d976689b2e05287c63f18","modified":1640833652847},{"_id":"public/tags/factory-pattern/index.html","hash":"101feb9bcc69531d5c63ab6f2ebd4a805c729498","modified":1640833652847},{"_id":"public/tags/Proxy/index.html","hash":"556ab3605d2f9901e89663e96045f8912156aa46","modified":1640833652847},{"_id":"public/tags/Reflection/index.html","hash":"ac5783d178fc740372327cdc67bbe572c5d2a7cc","modified":1640833652847},{"_id":"public/tags/Stream/index.html","hash":"5a699c93445eea3b4dd90438734472a8b72c41bc","modified":1640833652847},{"_id":"public/tags/maven/index.html","hash":"b149e683a5f101c6c766c4f17555505bb4b6326f","modified":1640833652847},{"_id":"public/tags/Serialization/index.html","hash":"adc2ed1bd78da7b66e88d82a86393b109705f0d1","modified":1640833652847},{"_id":"public/tags/AOP/index.html","hash":"f9a4794fb744d588d128656c1054b3db3c6bcca8","modified":1640833652847},{"_id":"public/tags/Spring/index.html","hash":"ebabc387783cd3d89d0943102fd409ef411c7049","modified":1640833652847},{"_id":"public/tags/Turing/index.html","hash":"19131d9577ff00f5def217f65a980575b9589287","modified":1640833652847},{"_id":"public/2021/11/15/java-arraylist/index.html","hash":"8ada10876f95b98ee9c3bfbcb37daaad8954bf85","modified":1640833652847},{"_id":"public/2021/11/12/theory-turing-completeness/index.html","hash":"c8ef3727b4fddc7d205c40d9231ec8b4728f7d06","modified":1640833652847},{"_id":"public/2021/11/07/maven-wrapper/index.html","hash":"3c34bff746b0b47958596a1cc45fb285f878948f","modified":1640833652847},{"_id":"public/2021/11/02/java-chain-of-responsibility/index.html","hash":"78391c92bddd7326c44ca949057784c1e0bd387d","modified":1640833652847},{"_id":"public/2021/11/01/spring-autoconfigurations/index.html","hash":"b0f961273465e60c928691abfb9dfd65d1ab9f5a","modified":1640833652847},{"_id":"public/2021/10/05/professional-dictionary/index.html","hash":"96678e6a031b922f70a058d2a89adff1a4b09f7e","modified":1640833652847},{"_id":"public/2021/10/01/spring-aop/index.html","hash":"09d3df42fcb2b3d9c6fc048990fe922c3eefe9e9","modified":1640833652847},{"_id":"public/2021/09/28/spring-ioc/index.html","hash":"e4cf3003bd5306baac39eeb3601ebeeac340f14a","modified":1640833652847},{"_id":"public/2021/08/12/java-reflection/index.html","hash":"23d1989b0a5a9c00d62b707f464994f1d0f7a0a0","modified":1640833652847},{"_id":"public/2021/08/04/java-functional-programming/index.html","hash":"c7c17c6e7c4948a1a892062c1d01bdf6cf1c6a8d","modified":1640833652847},{"_id":"public/2021/08/01/java-proxy-and-dynamic-proxy/index.html","hash":"1f30406b80fc918dd4f15567dd147c8b5b179be0","modified":1640833652847},{"_id":"public/2021/07/24/java-annotation/index.html","hash":"bb481f846380e22a7c7c341c12d23b6be63cc9c4","modified":1640833652847},{"_id":"public/2021/07/03/java-factory-pattern/index.html","hash":"12ef67630b4e0334dab543192c46346bbc28e56f","modified":1640833652847},{"_id":"public/2021/06/19/build-multi-module-project-best-practice/index.html","hash":"3163f0d032f0173e6fe18f493c2a0eebe1ca0685","modified":1640833652847},{"_id":"public/2021/06/15/java-classloader/index.html","hash":"eba20476b5099e5a100c5015c0c171543ead88c6","modified":1640833652847},{"_id":"public/2021/06/07/java-streams/index.html","hash":"f621bf95974772a487d971bf214e87bc17c95ca1","modified":1640833652847},{"_id":"public/2021/05/28/hexo-build-guide/index.html","hash":"667c88a9aba566df38e9e381e21f57c011609f13","modified":1640833652847},{"_id":"public/index.html","hash":"a0365044b0540f7fe5c6fdb8e380e1f9300ecbd9","modified":1640833652847},{"_id":"public/page/2/index.html","hash":"3f2e648245480e44e71987638bcb60eb9bbea3ac","modified":1640833652847},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1640833652847},{"_id":"public/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1640833652847},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1640833652847},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1640833652847},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1640833652847},{"_id":"public/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1640833652847},{"_id":"public/css/noscript.css","hash":"54d14cd43dc297950a4a8d39ec9644dd5fc3499f","modified":1640833652847},{"_id":"public/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1640833652847},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1640833652847},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1640833652847},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1640833652847},{"_id":"public/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1640833652847},{"_id":"public/js/next-boot.js","hash":"48497e2156a10155dc42311633a110c9685692c9","modified":1640833652847},{"_id":"public/js/pjax.js","hash":"0523cb1946907687c53999e2ce7cfe1831da6476","modified":1640833652847},{"_id":"public/js/schedule.js","hash":"2b43e2d576a308289880befc27580dbb2aa34439","modified":1640833652847},{"_id":"public/js/utils.js","hash":"e447160d342b1f93df5214b6a733441039ced439","modified":1640833652847},{"_id":"public/js/schemes/muse.js","hash":"62f4638674c92dfb72454fee38751d0227d3d225","modified":1640833652847},{"_id":"public/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1640833652847},{"_id":"public/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1640833652847},{"_id":"public/js/third-party/quicklink.js","hash":"6f58cd7aa8f6f1ab92d5a96551add293f4e55312","modified":1640833652847},{"_id":"public/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1640833652847},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1640833652847},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1640833652847},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1640833652847},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1640833652847},{"_id":"public/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1640833652847},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1640833652847},{"_id":"public/js/third-party/comments/changyan.js","hash":"8c8ebec444c727b704ea41ad88b0b96ed2e4b8d4","modified":1640833652847},{"_id":"public/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1640833652847},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1640833652847},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1640833652847},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1640833652847},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1640833652847},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1640833652847},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1640833652847},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1640833652847},{"_id":"public/js/third-party/search/algolia-search.js","hash":"ac401e3736d56a3c9cb85ab885744cce0b813c55","modified":1640833652847},{"_id":"public/js/third-party/search/local-search.js","hash":"45c485f82258d246f37deb66884bd2643323ef3a","modified":1640833652847},{"_id":"public/js/third-party/statistics/firestore.js","hash":"0960f16107ed61452fb0dffc6ed22dc143de34ef","modified":1640833652847},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1640833652847},{"_id":"public/js/third-party/tags/mermaid.js","hash":"3dc4628efa6debd6490fc0ebddff2424a7b319d8","modified":1640833652847},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1640833652847},{"_id":"public/css/main.css","hash":"55a3a484a1fe5a96b589b73f0ee0550092ca909a","modified":1640833652847}],"Category":[{"name":"Package Manager","_id":"ckxsdzpy50004xotg087w2j5w"},{"name":"Hexo","_id":"ckxsdzpyd0009xotg7114am3u"},{"name":"Java","_id":"ckxsdzpyg000dxotgbnsjarwf"},{"name":"Pattern","_id":"ckxsdzpyr000mxotge5xqgrtr"},{"name":"Pattern","parent":"ckxsdzpyg000dxotgbnsjarwf","_id":"ckxsdzpyz0011xotgeu895910"},{"name":"专业词汇","_id":"ckxsdzpz6001gxotg7vrz8bz1"},{"name":"Spring","_id":"ckxsdzpz8001lxotg3mw83p5p"},{"name":"计算机理论","_id":"ckxsdzpzc001wxotgff1x5cxf"}],"Data":[],"Page":[{"title":"关于","date":"2017-10-28T03:27:47.000Z","_content":"\n知其表而不知起里, 充其量你只能算一个画匠, 而不是画师; 只懂得如何使用API, 而不知道这些API是如何设计的, 使你迈不出从\"画匠\"到\"画师\"的那一步.\n\n好的博客地址收集: \nhttps://draveness.me/\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2017-10-28 11:27:47\n---\n\n知其表而不知起里, 充其量你只能算一个画匠, 而不是画师; 只懂得如何使用API, 而不知道这些API是如何设计的, 使你迈不出从\"画匠\"到\"画师\"的那一步.\n\n好的博客地址收集: \nhttps://draveness.me/\n","updated":"2021-12-30T02:46:02.120Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckxsdzpxs0000xotg7ltq11rh","content":"<p>知其表而不知起里, 充其量你只能算一个画匠, 而不是画师; 只懂得如何使用API, 而不知道这些API是如何设计的, 使你迈不出从”画匠”到”画师”的那一步.</p>\n<p>好的博客地址收集:<br><a href=\"https://draveness.me/\">https://draveness.me/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>知其表而不知起里, 充其量你只能算一个画匠, 而不是画师; 只懂得如何使用API, 而不知道这些API是如何设计的, 使你迈不出从”画匠”到”画师”的那一步.</p>\n<p>好的博客地址收集:<br><a href=\"https://draveness.me/\">https://draveness.me/</a></p>\n"},{"title":"分类","date":"2021-10-28T03:25:27.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2021-10-28 11:25:27\ntype: \"categories\"\n---\n","updated":"2021-12-30T02:27:14.813Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckxsdzpy20002xotge4gfgokf","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2021-05-28T03:25:33.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2021-05-28 11:25:33\ntype: \"tags\"\n---\n","updated":"2021-12-30T02:26:18.244Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckxsdzpy80005xotg3cdb011g","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"构建多模块项目的最佳实践","date":"2021-06-19T02:19:26.000Z","_content":"\n从创建一个最简单的gradle项目开始, 然后介绍multi module项目\n\n# Creating simplest Gradle project for Java\n以创建一个Redis Client为例, 引入一个第三方库Jedis依赖.\n\n1. 首先创建Root Project, 即创建一个文件夹, 添加`settings.gradle`文件并编辑\n```gradle\nrootProject.name = 'simplest-gradle-project'\n\n```\n2. 在root目录下, 创建gradle wrapper的必要文件, `gradlew`, `gradlew.bat`, `gradle`(文件夹), 这些文件可以通过 Spring Initializr 新建一个项目得到.\n3. 在每个subproject下创建`build.gradle`文件, 如下内容(示例)\n```gradle\nplugins {\n\tid 'java'\n}\n\ngroup = 'org.demo'\nversion = '0.0.1-SNAPSHOT'\n\nrepositories {\n    maven {\n      url 'https://maven.aliyun.com/repository/public/'\n    }\n    maven {\n      url 'https://maven.aliyun.com/repository/spring/'\n    }\n    mavenLocal()\n    mavenCentral()\n}\n\ndependencies {\n\timplementation 'redis.clients:jedis:jedis-3.6.2'\n}\n```\n4. 通过gradle task创建src文件目录(在build.gradle文件中添加下述代码), 然后运行 `./gradlew :createDirs`, 或者直接通过IDEA的gradle插件, 双击`simplest-gradle-project > Tasks > other > createDirs`\n```gradle\n// 创建缺失的src目录\ntask createDirs {\n    sourceSets*.java.srcDirs*.each{\n        it.mkdirs()\n    }\n    sourceSets*.resources.srcDirs*.each{\n        it.mkdirs()\n    }\n}\n```\n\n参考官方文档整理而来,\nhttps://spring.io/guides/gs/multi-module/\n\n# Creating a Multi Module Project\n1. 首先创建Root Project, 即创建一个文件夹, 添加`settings.gradle`文件并编辑(首先确定自己有多少子项目)\n```gradle\nrootProject.name = 'gradle-multi-module'\n\ninclude 'subproject1'\ninclude 'subproject2'\n```\n2. 在root目录下, 创建gradle wrapper的必要文件, `gradlew`, `gradlew.bat`, `gradle`(文件夹), 这些文件可以通过 Spring Initializr 新建一个项目得到.\n3. 在root目录下, 创建subprojects文件夹, `mkdir -p src/main/java/com/example/multimodule/service`\n4. 在每个subproject下创建`build.gradle`文件, 如下内容(示例):\n```gradle\nplugins {\n\tid 'org.springframework.boot' version '2.5.2'\n\tid 'io.spring.dependency-management' version '1.0.11.RELEASE'\n\tid 'java'\n}\n\ngroup = 'com.example'\nversion = '0.0.1-SNAPSHOT'\nsourceCompatibility = '1.8'\n\nrepositories {\n    maven {\n      url 'https://maven.aliyun.com/repository/public/'\n    }\n    maven {\n      url 'https://maven.aliyun.com/repository/spring/'\n    }\n    mavenLocal()\n    mavenCentral()\n}\n\ndependencies {\n\timplementation 'org.springframework.boot:spring-boot-starter'\n\ttestImplementation 'org.springframework.boot:spring-boot-starter-test'\n}\n```\n\n### Gradle\n对Gradle做出一些总结.\n\ngradle是一个扩展性很强的build tool, 比Maven更加灵活. \n1. Gradle makes it easy to build common types of project — say Java libraries — by adding a layer of conventions and prebuilt functionality through plugins.\n2. Gradle models its builds as Directed Acyclic Graphs (DAGs) of tasks (units of work). What this means is that a build essentially configures a set of tasks and wires them together — based on their dependencies — to create that DAG. Once the task graph has been created, Gradle determines which tasks need to be run in which order and then proceeds to execute them. Gradle构建项目的过程是执行一系列的task, 这些task构成了一个有向无环图DAG. 对于Java项目这些task就是: check, assemble, jar等等, 这些任务是内置的不需要用户定义.\n这里还经常提到一个概念: DSL . DSL 其实是 Domain Specific Language 的缩写，中文翻译为领域特定语言; 而与 DSL 相对的就是 GPL, 这里的 GPL 并不是我们知道的开源许可证, 而是 General Purpose Language 的简称，即通用编程语言，也就是我们非常熟悉的 Objective-C、Java、Python 以及 C 语言等等。比如Regex, HTML等, Gradle中支持Grovvy. 与 GPL 相对，DSL 与传统意义上的通用编程语言 C、Python 以及 Haskell 完全不同。通用的计算机编程语言是可以用来编写任意计算机程序的，并且能表达任何的可被计算的逻辑，同时也是 {% post_link theory-turing-completeness '图灵完备' %} 的。\n\n","source":"_posts/build-multi-module-project-best-practice.md","raw":"---\ntitle: 构建多模块项目的最佳实践\ndate: 2021-06-19 10:19:26\ncategories:\n- Package Manager\n---\n\n从创建一个最简单的gradle项目开始, 然后介绍multi module项目\n\n# Creating simplest Gradle project for Java\n以创建一个Redis Client为例, 引入一个第三方库Jedis依赖.\n\n1. 首先创建Root Project, 即创建一个文件夹, 添加`settings.gradle`文件并编辑\n```gradle\nrootProject.name = 'simplest-gradle-project'\n\n```\n2. 在root目录下, 创建gradle wrapper的必要文件, `gradlew`, `gradlew.bat`, `gradle`(文件夹), 这些文件可以通过 Spring Initializr 新建一个项目得到.\n3. 在每个subproject下创建`build.gradle`文件, 如下内容(示例)\n```gradle\nplugins {\n\tid 'java'\n}\n\ngroup = 'org.demo'\nversion = '0.0.1-SNAPSHOT'\n\nrepositories {\n    maven {\n      url 'https://maven.aliyun.com/repository/public/'\n    }\n    maven {\n      url 'https://maven.aliyun.com/repository/spring/'\n    }\n    mavenLocal()\n    mavenCentral()\n}\n\ndependencies {\n\timplementation 'redis.clients:jedis:jedis-3.6.2'\n}\n```\n4. 通过gradle task创建src文件目录(在build.gradle文件中添加下述代码), 然后运行 `./gradlew :createDirs`, 或者直接通过IDEA的gradle插件, 双击`simplest-gradle-project > Tasks > other > createDirs`\n```gradle\n// 创建缺失的src目录\ntask createDirs {\n    sourceSets*.java.srcDirs*.each{\n        it.mkdirs()\n    }\n    sourceSets*.resources.srcDirs*.each{\n        it.mkdirs()\n    }\n}\n```\n\n参考官方文档整理而来,\nhttps://spring.io/guides/gs/multi-module/\n\n# Creating a Multi Module Project\n1. 首先创建Root Project, 即创建一个文件夹, 添加`settings.gradle`文件并编辑(首先确定自己有多少子项目)\n```gradle\nrootProject.name = 'gradle-multi-module'\n\ninclude 'subproject1'\ninclude 'subproject2'\n```\n2. 在root目录下, 创建gradle wrapper的必要文件, `gradlew`, `gradlew.bat`, `gradle`(文件夹), 这些文件可以通过 Spring Initializr 新建一个项目得到.\n3. 在root目录下, 创建subprojects文件夹, `mkdir -p src/main/java/com/example/multimodule/service`\n4. 在每个subproject下创建`build.gradle`文件, 如下内容(示例):\n```gradle\nplugins {\n\tid 'org.springframework.boot' version '2.5.2'\n\tid 'io.spring.dependency-management' version '1.0.11.RELEASE'\n\tid 'java'\n}\n\ngroup = 'com.example'\nversion = '0.0.1-SNAPSHOT'\nsourceCompatibility = '1.8'\n\nrepositories {\n    maven {\n      url 'https://maven.aliyun.com/repository/public/'\n    }\n    maven {\n      url 'https://maven.aliyun.com/repository/spring/'\n    }\n    mavenLocal()\n    mavenCentral()\n}\n\ndependencies {\n\timplementation 'org.springframework.boot:spring-boot-starter'\n\ttestImplementation 'org.springframework.boot:spring-boot-starter-test'\n}\n```\n\n### Gradle\n对Gradle做出一些总结.\n\ngradle是一个扩展性很强的build tool, 比Maven更加灵活. \n1. Gradle makes it easy to build common types of project — say Java libraries — by adding a layer of conventions and prebuilt functionality through plugins.\n2. Gradle models its builds as Directed Acyclic Graphs (DAGs) of tasks (units of work). What this means is that a build essentially configures a set of tasks and wires them together — based on their dependencies — to create that DAG. Once the task graph has been created, Gradle determines which tasks need to be run in which order and then proceeds to execute them. Gradle构建项目的过程是执行一系列的task, 这些task构成了一个有向无环图DAG. 对于Java项目这些task就是: check, assemble, jar等等, 这些任务是内置的不需要用户定义.\n这里还经常提到一个概念: DSL . DSL 其实是 Domain Specific Language 的缩写，中文翻译为领域特定语言; 而与 DSL 相对的就是 GPL, 这里的 GPL 并不是我们知道的开源许可证, 而是 General Purpose Language 的简称，即通用编程语言，也就是我们非常熟悉的 Objective-C、Java、Python 以及 C 语言等等。比如Regex, HTML等, Gradle中支持Grovvy. 与 GPL 相对，DSL 与传统意义上的通用编程语言 C、Python 以及 Haskell 完全不同。通用的计算机编程语言是可以用来编写任意计算机程序的，并且能表达任何的可被计算的逻辑，同时也是 {% post_link theory-turing-completeness '图灵完备' %} 的。\n\n","slug":"build-multi-module-project-best-practice","published":1,"updated":"2021-12-30T02:59:47.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxsdzpxx0001xotg65yafs9i","content":"<p>从创建一个最简单的gradle项目开始, 然后介绍multi module项目</p>\n<h1 id=\"Creating-simplest-Gradle-project-for-Java\"><a href=\"#Creating-simplest-Gradle-project-for-Java\" class=\"headerlink\" title=\"Creating simplest Gradle project for Java\"></a>Creating simplest Gradle project for Java</h1><p>以创建一个Redis Client为例, 引入一个第三方库Jedis依赖.</p>\n<ol>\n<li>首先创建Root Project, 即创建一个文件夹, 添加<code>settings.gradle</code>文件并编辑<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rootProject.name = <span class=\"string\">&#x27;simplest-gradle-project&#x27;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li>在root目录下, 创建gradle wrapper的必要文件, <code>gradlew</code>, <code>gradlew.bat</code>, <code>gradle</code>(文件夹), 这些文件可以通过 Spring Initializr 新建一个项目得到.</li>\n<li>在每个subproject下创建<code>build.gradle</code>文件, 如下内容(示例)<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">\tid <span class=\"string\">&#x27;java&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">group</span> = <span class=\"string\">&#x27;org.demo&#x27;</span></span><br><span class=\"line\">version = <span class=\"string\">&#x27;0.0.1-SNAPSHOT&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">repositories</span> &#123;</span><br><span class=\"line\">    maven &#123;</span><br><span class=\"line\">      url <span class=\"string\">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    maven &#123;</span><br><span class=\"line\">      url <span class=\"string\">&#x27;https://maven.aliyun.com/repository/spring/&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mavenLocal()</span><br><span class=\"line\">    mavenCentral()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">\timplementation <span class=\"string\">&#x27;redis.clients:jedis:jedis-3.6.2&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>通过gradle task创建src文件目录(在build.gradle文件中添加下述代码), 然后运行 <code>./gradlew :createDirs</code>, 或者直接通过IDEA的gradle插件, 双击<code>simplest-gradle-project &gt; Tasks &gt; other &gt; createDirs</code><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建缺失的src目录</span></span><br><span class=\"line\"><span class=\"keyword\">task</span> createDirs &#123;</span><br><span class=\"line\">    <span class=\"keyword\">sourceSets</span>*.java.srcDirs*.<span class=\"keyword\">each</span>&#123;</span><br><span class=\"line\">        it.mkdirs()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">sourceSets</span>*.resources.srcDirs*.<span class=\"keyword\">each</span>&#123;</span><br><span class=\"line\">        it.mkdirs()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>参考官方文档整理而来,<br><a href=\"https://spring.io/guides/gs/multi-module/\">https://spring.io/guides/gs/multi-module/</a></p>\n<h1 id=\"Creating-a-Multi-Module-Project\"><a href=\"#Creating-a-Multi-Module-Project\" class=\"headerlink\" title=\"Creating a Multi Module Project\"></a>Creating a Multi Module Project</h1><ol>\n<li>首先创建Root Project, 即创建一个文件夹, 添加<code>settings.gradle</code>文件并编辑(首先确定自己有多少子项目)<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rootProject.name = <span class=\"string\">&#x27;gradle-multi-module&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">include</span> <span class=\"string\">&#x27;subproject1&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">include</span> <span class=\"string\">&#x27;subproject2&#x27;</span></span><br></pre></td></tr></table></figure></li>\n<li>在root目录下, 创建gradle wrapper的必要文件, <code>gradlew</code>, <code>gradlew.bat</code>, <code>gradle</code>(文件夹), 这些文件可以通过 Spring Initializr 新建一个项目得到.</li>\n<li>在root目录下, 创建subprojects文件夹, <code>mkdir -p src/main/java/com/example/multimodule/service</code></li>\n<li>在每个subproject下创建<code>build.gradle</code>文件, 如下内容(示例):<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">\tid <span class=\"string\">&#x27;org.springframework.boot&#x27;</span> version <span class=\"string\">&#x27;2.5.2&#x27;</span></span><br><span class=\"line\">\tid <span class=\"string\">&#x27;io.spring.dependency-management&#x27;</span> version <span class=\"string\">&#x27;1.0.11.RELEASE&#x27;</span></span><br><span class=\"line\">\tid <span class=\"string\">&#x27;java&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">group</span> = <span class=\"string\">&#x27;com.example&#x27;</span></span><br><span class=\"line\">version = <span class=\"string\">&#x27;0.0.1-SNAPSHOT&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">sourceCompatibility</span> = <span class=\"string\">&#x27;1.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">repositories</span> &#123;</span><br><span class=\"line\">    maven &#123;</span><br><span class=\"line\">      url <span class=\"string\">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    maven &#123;</span><br><span class=\"line\">      url <span class=\"string\">&#x27;https://maven.aliyun.com/repository/spring/&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mavenLocal()</span><br><span class=\"line\">    mavenCentral()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">\timplementation <span class=\"string\">&#x27;org.springframework.boot:spring-boot-starter&#x27;</span></span><br><span class=\"line\">\ttestImplementation <span class=\"string\">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Gradle\"><a href=\"#Gradle\" class=\"headerlink\" title=\"Gradle\"></a>Gradle</h3><p>对Gradle做出一些总结.</p>\n<p>gradle是一个扩展性很强的build tool, 比Maven更加灵活. </p>\n<ol>\n<li>Gradle makes it easy to build common types of project — say Java libraries — by adding a layer of conventions and prebuilt functionality through plugins.</li>\n<li>Gradle models its builds as Directed Acyclic Graphs (DAGs) of tasks (units of work). What this means is that a build essentially configures a set of tasks and wires them together — based on their dependencies — to create that DAG. Once the task graph has been created, Gradle determines which tasks need to be run in which order and then proceeds to execute them. Gradle构建项目的过程是执行一系列的task, 这些task构成了一个有向无环图DAG. 对于Java项目这些task就是: check, assemble, jar等等, 这些任务是内置的不需要用户定义.<br>这里还经常提到一个概念: DSL . DSL 其实是 Domain Specific Language 的缩写，中文翻译为领域特定语言; 而与 DSL 相对的就是 GPL, 这里的 GPL 并不是我们知道的开源许可证, 而是 General Purpose Language 的简称，即通用编程语言，也就是我们非常熟悉的 Objective-C、Java、Python 以及 C 语言等等。比如Regex, HTML等, Gradle中支持Grovvy. 与 GPL 相对，DSL 与传统意义上的通用编程语言 C、Python 以及 Haskell 完全不同。通用的计算机编程语言是可以用来编写任意计算机程序的，并且能表达任何的可被计算的逻辑，同时也是 <a href=\"/2021/11/12/theory-turing-completeness/\" title=\"图灵完备\">图灵完备</a> 的。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>从创建一个最简单的gradle项目开始, 然后介绍multi module项目</p>\n<h1 id=\"Creating-simplest-Gradle-project-for-Java\"><a href=\"#Creating-simplest-Gradle-project-for-Java\" class=\"headerlink\" title=\"Creating simplest Gradle project for Java\"></a>Creating simplest Gradle project for Java</h1><p>以创建一个Redis Client为例, 引入一个第三方库Jedis依赖.</p>\n<ol>\n<li>首先创建Root Project, 即创建一个文件夹, 添加<code>settings.gradle</code>文件并编辑<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rootProject.name = <span class=\"string\">&#x27;simplest-gradle-project&#x27;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li>在root目录下, 创建gradle wrapper的必要文件, <code>gradlew</code>, <code>gradlew.bat</code>, <code>gradle</code>(文件夹), 这些文件可以通过 Spring Initializr 新建一个项目得到.</li>\n<li>在每个subproject下创建<code>build.gradle</code>文件, 如下内容(示例)<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">\tid <span class=\"string\">&#x27;java&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">group</span> = <span class=\"string\">&#x27;org.demo&#x27;</span></span><br><span class=\"line\">version = <span class=\"string\">&#x27;0.0.1-SNAPSHOT&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">repositories</span> &#123;</span><br><span class=\"line\">    maven &#123;</span><br><span class=\"line\">      url <span class=\"string\">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    maven &#123;</span><br><span class=\"line\">      url <span class=\"string\">&#x27;https://maven.aliyun.com/repository/spring/&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mavenLocal()</span><br><span class=\"line\">    mavenCentral()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">\timplementation <span class=\"string\">&#x27;redis.clients:jedis:jedis-3.6.2&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>通过gradle task创建src文件目录(在build.gradle文件中添加下述代码), 然后运行 <code>./gradlew :createDirs</code>, 或者直接通过IDEA的gradle插件, 双击<code>simplest-gradle-project &gt; Tasks &gt; other &gt; createDirs</code><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建缺失的src目录</span></span><br><span class=\"line\"><span class=\"keyword\">task</span> createDirs &#123;</span><br><span class=\"line\">    <span class=\"keyword\">sourceSets</span>*.java.srcDirs*.<span class=\"keyword\">each</span>&#123;</span><br><span class=\"line\">        it.mkdirs()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">sourceSets</span>*.resources.srcDirs*.<span class=\"keyword\">each</span>&#123;</span><br><span class=\"line\">        it.mkdirs()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>参考官方文档整理而来,<br><a href=\"https://spring.io/guides/gs/multi-module/\">https://spring.io/guides/gs/multi-module/</a></p>\n<h1 id=\"Creating-a-Multi-Module-Project\"><a href=\"#Creating-a-Multi-Module-Project\" class=\"headerlink\" title=\"Creating a Multi Module Project\"></a>Creating a Multi Module Project</h1><ol>\n<li>首先创建Root Project, 即创建一个文件夹, 添加<code>settings.gradle</code>文件并编辑(首先确定自己有多少子项目)<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rootProject.name = <span class=\"string\">&#x27;gradle-multi-module&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">include</span> <span class=\"string\">&#x27;subproject1&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">include</span> <span class=\"string\">&#x27;subproject2&#x27;</span></span><br></pre></td></tr></table></figure></li>\n<li>在root目录下, 创建gradle wrapper的必要文件, <code>gradlew</code>, <code>gradlew.bat</code>, <code>gradle</code>(文件夹), 这些文件可以通过 Spring Initializr 新建一个项目得到.</li>\n<li>在root目录下, 创建subprojects文件夹, <code>mkdir -p src/main/java/com/example/multimodule/service</code></li>\n<li>在每个subproject下创建<code>build.gradle</code>文件, 如下内容(示例):<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">\tid <span class=\"string\">&#x27;org.springframework.boot&#x27;</span> version <span class=\"string\">&#x27;2.5.2&#x27;</span></span><br><span class=\"line\">\tid <span class=\"string\">&#x27;io.spring.dependency-management&#x27;</span> version <span class=\"string\">&#x27;1.0.11.RELEASE&#x27;</span></span><br><span class=\"line\">\tid <span class=\"string\">&#x27;java&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">group</span> = <span class=\"string\">&#x27;com.example&#x27;</span></span><br><span class=\"line\">version = <span class=\"string\">&#x27;0.0.1-SNAPSHOT&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">sourceCompatibility</span> = <span class=\"string\">&#x27;1.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">repositories</span> &#123;</span><br><span class=\"line\">    maven &#123;</span><br><span class=\"line\">      url <span class=\"string\">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    maven &#123;</span><br><span class=\"line\">      url <span class=\"string\">&#x27;https://maven.aliyun.com/repository/spring/&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mavenLocal()</span><br><span class=\"line\">    mavenCentral()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">\timplementation <span class=\"string\">&#x27;org.springframework.boot:spring-boot-starter&#x27;</span></span><br><span class=\"line\">\ttestImplementation <span class=\"string\">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Gradle\"><a href=\"#Gradle\" class=\"headerlink\" title=\"Gradle\"></a>Gradle</h3><p>对Gradle做出一些总结.</p>\n<p>gradle是一个扩展性很强的build tool, 比Maven更加灵活. </p>\n<ol>\n<li>Gradle makes it easy to build common types of project — say Java libraries — by adding a layer of conventions and prebuilt functionality through plugins.</li>\n<li>Gradle models its builds as Directed Acyclic Graphs (DAGs) of tasks (units of work). What this means is that a build essentially configures a set of tasks and wires them together — based on their dependencies — to create that DAG. Once the task graph has been created, Gradle determines which tasks need to be run in which order and then proceeds to execute them. Gradle构建项目的过程是执行一系列的task, 这些task构成了一个有向无环图DAG. 对于Java项目这些task就是: check, assemble, jar等等, 这些任务是内置的不需要用户定义.<br>这里还经常提到一个概念: DSL . DSL 其实是 Domain Specific Language 的缩写，中文翻译为领域特定语言; 而与 DSL 相对的就是 GPL, 这里的 GPL 并不是我们知道的开源许可证, 而是 General Purpose Language 的简称，即通用编程语言，也就是我们非常熟悉的 Objective-C、Java、Python 以及 C 语言等等。比如Regex, HTML等, Gradle中支持Grovvy. 与 GPL 相对，DSL 与传统意义上的通用编程语言 C、Python 以及 Haskell 完全不同。通用的计算机编程语言是可以用来编写任意计算机程序的，并且能表达任何的可被计算的逻辑，同时也是 <a href=\"/2021/11/12/theory-turing-completeness/\" title=\"图灵完备\">图灵完备</a> 的。</li>\n</ol>\n"},{"title":"Hello World","date":"2021-05-27T02:03:18.000Z","_content":"Welcome to [the-Rings](https://the-rings.github.io/)! This is your very first post.\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2021-05-27 10:03:18\n---\nWelcome to [the-Rings](https://the-rings.github.io/)! This is your very first post.\n","slug":"hello-world","published":1,"updated":"2021-12-30T03:00:20.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxsdzpy30003xotgea04atzf","content":"<p>Welcome to <a href=\"https://the-rings.github.io/\">the-Rings</a>! This is your very first post.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://the-rings.github.io/\">the-Rings</a>! This is your very first post.</p>\n"},{"title":"使用Hexo构建博客","date":"2021-05-28T06:53:12.000Z","_content":"\n一直以来，使用其他工具来记录技术知识的积累，以后陆续将其转到github上。使用Hexo搭建项目可以自动将文档生成静态HTML等文件，上传到github上，随时通过your-github-name.github.io查看自己的公开静态信息库。\n\n## Github准备操作\n\n1. 首先在github上创建一个新的repository，其中`Repository name`为`[your-github-name].github.io`，设为开源, 用来存放生成的静态文件, 先不创建任何文件和分支.\n2. 在创建一个repository, `Repository name`最好设为`github-bolg`(根据个人喜好), 这个项目存放文档以及源码\n3. 将ssh公钥`id_ras.pub`内容添加到个人信息 > settings > SSH keys\n\n## 本地准备操作\n\n1. 安装Node.js (默认安装了npm)\n\n2. npm的配置, 对前端不是很熟, 这里需要记录一下\n\n   - 在Windows默认的用户目录下, 新建`C:\\Users\\your-user-name\\.npmrc`文件\n\n     ```\n       registry=https://registry.npm.taobao.org\n       prefix=D:\\apps\\nodejs\\node_global\n       cache=D:\\apps\\nodejs\\node_cache\n    ```\n\n3. 安装`npm install -g hexo`\n\n4. 初始化`hexo init [your-project-name]`\n\n5. 此时可以进行一步本地启动尝试. 执行三个命令: `hexo clean`&`hexo generate`&`hexo server`, 如果成功访问`localhost:4000`说明初始化成功\n\n6. 进入项目根目录查看\n\n   - `.deploy_git`&`.github`不明其意, 勿动\n   - `source/_posts`存放源文档, 未来soure中还会加入`about`, `categoryies`, `tags`文件夹, 分别对应了`关于` , `分类`, `标签`页面的源文档. \n   - `themes`对应主题, 每个主题都会是一个文件夹\n   - `_config.yml`记录了整个项目的配置, 包括显示的语言, 时区等\n   - `package.json`&`package-lock.json`为项目依赖包的记录\n   - `public`文件夹是生成的静态文件保存的位置, 对应`[your-github-name].github.io`仓库\n   - `node_modules`对应依赖包信息\n\n7. 整个项目初始化为git项目, 并添加`.gitignore`文件\n\n    ```\n     .DS_Store\n     Thumbs.db\n     db.json\n     *.log\n     node_modules/\n     public/\n     .deploy*/\n    ```\n\n   - > 通过此gitignore文件可以看出向`[github-blog]`repository推送的包括源文档, 主题文件和配置文件\n\n     ```shell\n     git init\n     git remote add origin [github-bolg repository ssh address]\n     # for example: $ git remote add origin git@github.com:the-Rings/github-blog.git\n     # github从2020年12月份之后, 不再支持用户名&密码方式推送项目, 所以这里是ssh address, 配合我们之前加入的SSH keys使用\n     git add .\n     git commit -m \"something\"\n     git push --set-upstream main\n     # 推送完成\n     ```\n\n8. 配置`_config.yml`向`[your-github-name].github.io`仓库推送public下的文件, 这是不需要初始化git仓库, 使用hexo相关工具完成\n\n    ```yaml\n    # 编辑_config.yml中的deploy选项\n    deploy:\n      type: git\n      repo: git@github.com:[your-github-name]/[your-github-name].github.io.git # 复制仓库的SSH地址\n      branch: main # 分支默认为main即可\n    ```\n\n9. 安装`npm install hexo-deployer-git --save`, 这个工具来向github推送静态文件\n\n10. 通过`hexo clean`&`hexo generate`&`hexo deploy`三个命令组合完成, 实际上每次修改之后都是这一顿操作.\n\n## 主题等相关配置操作\n\n1. 选用`Next`主题, 然后对`theme/next`中的配置文件进行相关设置, 这里参考网友们的答案即可, 主要是对首页、归档、分类、标签、关于进行相关设置和注释放开, 并通过命令增加对应的模块\n\n   ```shell\n     hexo new page categories\n     hexo new page tags\n     hexo new page about\n   ```\n\n2. 启用搜索功能, 在项目的根目录下`_config.yml`找到`Extensions`, 增加配置, 并执行`$ npm install hexo-generator-searchdb --save`\n\n    ```yaml\n     search:\n       path: search.xml\n       field: post\n       format: html\n       limit: 10000\n    ```\n\n   - 然后, 在主题配置文件`theme/next/.config.yml`中设置`local_search: enable: true`\n\n3. UML图插件\n    ```shell\n    npm install --save hexo-tag-plantuml\n    ```\n    语法参考: https://plantuml.com/zh/class-diagram\n    预览效果: https://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000\n    {% plantuml %}\n    Joinpoint <|-- Invocation\n    interface Joinpoint {}\n    interface Invocation {}\n    \n    Invocation <|-- MethodInvocation\n    interface MethodInvocation {}\n    \n    MethodInvocation <|-- ProxyMethodInvocation\n    interface ProxyMethodInvocation {}\n    \n    ProxyMethodInvocation <|.. ReflectiveMethodInvocation\n    {% endplantuml %}\n\n## 特殊语法\n1. 站内文章链接{% post_link file_name \"display name\" %}\n\n## 日常操作流程\n\n1. 写博客`hexo new post [new-blog-name]`, 在`source/_post/`下就生成了一个新的博客文件, 可以用其他markdown编辑工具来编写, 比如Typora\n2. 在博客文档的开头可以设置标签和分类\n3. 写完之后, 提交源码`git add `&`git commit`&`git push`\n4. 部署发布`hexo clean`&`hexo generate`&`hexo deploy`\n\n\n# Troubleshooting\n总结一些在部署中的错误解决\n1. 在执行`hexo generate`中出现错误: `Template render error: (unknown path)`, 多半是语法错误, 比如, 在使用`{% xxx %}`时写成了`{ % xxx %}`, 前方多了一个空格.","source":"_posts/hexo-build-guide.md","raw":"---\ntitle: 使用Hexo构建博客\ndate: 2021-05-28 14:53:12\ncategories:\n- Hexo\n---\n\n一直以来，使用其他工具来记录技术知识的积累，以后陆续将其转到github上。使用Hexo搭建项目可以自动将文档生成静态HTML等文件，上传到github上，随时通过your-github-name.github.io查看自己的公开静态信息库。\n\n## Github准备操作\n\n1. 首先在github上创建一个新的repository，其中`Repository name`为`[your-github-name].github.io`，设为开源, 用来存放生成的静态文件, 先不创建任何文件和分支.\n2. 在创建一个repository, `Repository name`最好设为`github-bolg`(根据个人喜好), 这个项目存放文档以及源码\n3. 将ssh公钥`id_ras.pub`内容添加到个人信息 > settings > SSH keys\n\n## 本地准备操作\n\n1. 安装Node.js (默认安装了npm)\n\n2. npm的配置, 对前端不是很熟, 这里需要记录一下\n\n   - 在Windows默认的用户目录下, 新建`C:\\Users\\your-user-name\\.npmrc`文件\n\n     ```\n       registry=https://registry.npm.taobao.org\n       prefix=D:\\apps\\nodejs\\node_global\n       cache=D:\\apps\\nodejs\\node_cache\n    ```\n\n3. 安装`npm install -g hexo`\n\n4. 初始化`hexo init [your-project-name]`\n\n5. 此时可以进行一步本地启动尝试. 执行三个命令: `hexo clean`&`hexo generate`&`hexo server`, 如果成功访问`localhost:4000`说明初始化成功\n\n6. 进入项目根目录查看\n\n   - `.deploy_git`&`.github`不明其意, 勿动\n   - `source/_posts`存放源文档, 未来soure中还会加入`about`, `categoryies`, `tags`文件夹, 分别对应了`关于` , `分类`, `标签`页面的源文档. \n   - `themes`对应主题, 每个主题都会是一个文件夹\n   - `_config.yml`记录了整个项目的配置, 包括显示的语言, 时区等\n   - `package.json`&`package-lock.json`为项目依赖包的记录\n   - `public`文件夹是生成的静态文件保存的位置, 对应`[your-github-name].github.io`仓库\n   - `node_modules`对应依赖包信息\n\n7. 整个项目初始化为git项目, 并添加`.gitignore`文件\n\n    ```\n     .DS_Store\n     Thumbs.db\n     db.json\n     *.log\n     node_modules/\n     public/\n     .deploy*/\n    ```\n\n   - > 通过此gitignore文件可以看出向`[github-blog]`repository推送的包括源文档, 主题文件和配置文件\n\n     ```shell\n     git init\n     git remote add origin [github-bolg repository ssh address]\n     # for example: $ git remote add origin git@github.com:the-Rings/github-blog.git\n     # github从2020年12月份之后, 不再支持用户名&密码方式推送项目, 所以这里是ssh address, 配合我们之前加入的SSH keys使用\n     git add .\n     git commit -m \"something\"\n     git push --set-upstream main\n     # 推送完成\n     ```\n\n8. 配置`_config.yml`向`[your-github-name].github.io`仓库推送public下的文件, 这是不需要初始化git仓库, 使用hexo相关工具完成\n\n    ```yaml\n    # 编辑_config.yml中的deploy选项\n    deploy:\n      type: git\n      repo: git@github.com:[your-github-name]/[your-github-name].github.io.git # 复制仓库的SSH地址\n      branch: main # 分支默认为main即可\n    ```\n\n9. 安装`npm install hexo-deployer-git --save`, 这个工具来向github推送静态文件\n\n10. 通过`hexo clean`&`hexo generate`&`hexo deploy`三个命令组合完成, 实际上每次修改之后都是这一顿操作.\n\n## 主题等相关配置操作\n\n1. 选用`Next`主题, 然后对`theme/next`中的配置文件进行相关设置, 这里参考网友们的答案即可, 主要是对首页、归档、分类、标签、关于进行相关设置和注释放开, 并通过命令增加对应的模块\n\n   ```shell\n     hexo new page categories\n     hexo new page tags\n     hexo new page about\n   ```\n\n2. 启用搜索功能, 在项目的根目录下`_config.yml`找到`Extensions`, 增加配置, 并执行`$ npm install hexo-generator-searchdb --save`\n\n    ```yaml\n     search:\n       path: search.xml\n       field: post\n       format: html\n       limit: 10000\n    ```\n\n   - 然后, 在主题配置文件`theme/next/.config.yml`中设置`local_search: enable: true`\n\n3. UML图插件\n    ```shell\n    npm install --save hexo-tag-plantuml\n    ```\n    语法参考: https://plantuml.com/zh/class-diagram\n    预览效果: https://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000\n    {% plantuml %}\n    Joinpoint <|-- Invocation\n    interface Joinpoint {}\n    interface Invocation {}\n    \n    Invocation <|-- MethodInvocation\n    interface MethodInvocation {}\n    \n    MethodInvocation <|-- ProxyMethodInvocation\n    interface ProxyMethodInvocation {}\n    \n    ProxyMethodInvocation <|.. ReflectiveMethodInvocation\n    {% endplantuml %}\n\n## 特殊语法\n1. 站内文章链接{% post_link file_name \"display name\" %}\n\n## 日常操作流程\n\n1. 写博客`hexo new post [new-blog-name]`, 在`source/_post/`下就生成了一个新的博客文件, 可以用其他markdown编辑工具来编写, 比如Typora\n2. 在博客文档的开头可以设置标签和分类\n3. 写完之后, 提交源码`git add `&`git commit`&`git push`\n4. 部署发布`hexo clean`&`hexo generate`&`hexo deploy`\n\n\n# Troubleshooting\n总结一些在部署中的错误解决\n1. 在执行`hexo generate`中出现错误: `Template render error: (unknown path)`, 多半是语法错误, 比如, 在使用`{% xxx %}`时写成了`{ % xxx %}`, 前方多了一个空格.","slug":"hexo-build-guide","published":1,"updated":"2021-12-30T03:00:17.738Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxsdzpy80006xotgf8gsfdnb","content":"<p>一直以来，使用其他工具来记录技术知识的积累，以后陆续将其转到github上。使用Hexo搭建项目可以自动将文档生成静态HTML等文件，上传到github上，随时通过your-github-name.github.io查看自己的公开静态信息库。</p>\n<h2 id=\"Github准备操作\"><a href=\"#Github准备操作\" class=\"headerlink\" title=\"Github准备操作\"></a>Github准备操作</h2><ol>\n<li>首先在github上创建一个新的repository，其中<code>Repository name</code>为<code>[your-github-name].github.io</code>，设为开源, 用来存放生成的静态文件, 先不创建任何文件和分支.</li>\n<li>在创建一个repository, <code>Repository name</code>最好设为<code>github-bolg</code>(根据个人喜好), 这个项目存放文档以及源码</li>\n<li>将ssh公钥<code>id_ras.pub</code>内容添加到个人信息 &gt; settings &gt; SSH keys</li>\n</ol>\n<h2 id=\"本地准备操作\"><a href=\"#本地准备操作\" class=\"headerlink\" title=\"本地准备操作\"></a>本地准备操作</h2><ol>\n<li><p>安装Node.js (默认安装了npm)</p>\n</li>\n<li><p>npm的配置, 对前端不是很熟, 这里需要记录一下</p>\n<ul>\n<li><p>在Windows默认的用户目录下, 新建<code>C:\\Users\\your-user-name\\.npmrc</code>文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">registry=https://registry.npm.taobao.org</span><br><span class=\"line\">prefix=D:\\apps\\nodejs\\node_global</span><br><span class=\"line\">cache=D:\\apps\\nodejs\\node_cache</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>安装<code>npm install -g hexo</code></p>\n</li>\n<li><p>初始化<code>hexo init [your-project-name]</code></p>\n</li>\n<li><p>此时可以进行一步本地启动尝试. 执行三个命令: <code>hexo clean</code>&amp;<code>hexo generate</code>&amp;<code>hexo server</code>, 如果成功访问<code>localhost:4000</code>说明初始化成功</p>\n</li>\n<li><p>进入项目根目录查看</p>\n<ul>\n<li><code>.deploy_git</code>&amp;<code>.github</code>不明其意, 勿动</li>\n<li><code>source/_posts</code>存放源文档, 未来soure中还会加入<code>about</code>, <code>categoryies</code>, <code>tags</code>文件夹, 分别对应了<code>关于</code> , <code>分类</code>, <code>标签</code>页面的源文档. </li>\n<li><code>themes</code>对应主题, 每个主题都会是一个文件夹</li>\n<li><code>_config.yml</code>记录了整个项目的配置, 包括显示的语言, 时区等</li>\n<li><code>package.json</code>&amp;<code>package-lock.json</code>为项目依赖包的记录</li>\n<li><code>public</code>文件夹是生成的静态文件保存的位置, 对应<code>[your-github-name].github.io</code>仓库</li>\n<li><code>node_modules</code>对应依赖包信息</li>\n</ul>\n</li>\n<li><p>整个项目初始化为git项目, 并添加<code>.gitignore</code>文件</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.DS_Store</span><br><span class=\"line\">Thumbs.db</span><br><span class=\"line\">db.json</span><br><span class=\"line\">*.log</span><br><span class=\"line\">node_modules/</span><br><span class=\"line\">public/</span><br><span class=\"line\">.deploy*/</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><blockquote>\n<p>通过此gitignore文件可以看出向<code>[github-blog]</code>repository推送的包括源文档, 主题文件和配置文件</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">git remote add origin [github-bolg repository ssh address]</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"keyword\">for</span> example: $ git remote add origin git@github.com:the-Rings/github-blog.git</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> github从2020年12月份之后, 不再支持用户名&amp;密码方式推送项目, 所以这里是ssh address, 配合我们之前加入的SSH keys使用</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;something&quot;</span><br><span class=\"line\">git push --set-upstream main</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 推送完成</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>配置<code>_config.yml</code>向<code>[your-github-name].github.io</code>仓库推送public下的文件, 这是不需要初始化git仓库, 使用hexo相关工具完成</p>\n <figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 编辑_config.yml中的deploy选项</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">git@github.com:[your-github-name]/[your-github-name].github.io.git</span> <span class=\"comment\"># 复制仓库的SSH地址</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">main</span> <span class=\"comment\"># 分支默认为main即可</span></span><br></pre></td></tr></table></figure></li>\n<li><p>安装<code>npm install hexo-deployer-git --save</code>, 这个工具来向github推送静态文件</p>\n</li>\n<li><p>通过<code>hexo clean</code>&amp;<code>hexo generate</code>&amp;<code>hexo deploy</code>三个命令组合完成, 实际上每次修改之后都是这一顿操作.</p>\n</li>\n</ol>\n<h2 id=\"主题等相关配置操作\"><a href=\"#主题等相关配置操作\" class=\"headerlink\" title=\"主题等相关配置操作\"></a>主题等相关配置操作</h2><ol>\n<li><p>选用<code>Next</code>主题, 然后对<code>theme/next</code>中的配置文件进行相关设置, 这里参考网友们的答案即可, 主要是对首页、归档、分类、标签、关于进行相关设置和注释放开, 并通过命令增加对应的模块</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page categories</span><br><span class=\"line\">hexo new page tags</span><br><span class=\"line\">hexo new page about</span><br></pre></td></tr></table></figure></li>\n<li><p>启用搜索功能, 在项目的根目录下<code>_config.yml</code>找到<code>Extensions</code>, 增加配置, 并执行<code>$ npm install hexo-generator-searchdb --save</code></p>\n <figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">search:</span></span><br><span class=\"line\">  <span class=\"attr\">path:</span> <span class=\"string\">search.xml</span></span><br><span class=\"line\">  <span class=\"attr\">field:</span> <span class=\"string\">post</span></span><br><span class=\"line\">  <span class=\"attr\">format:</span> <span class=\"string\">html</span></span><br><span class=\"line\">  <span class=\"attr\">limit:</span> <span class=\"number\">10000</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>然后, 在主题配置文件<code>theme/next/.config.yml</code>中设置<code>local_search: enable: true</code></li>\n</ul>\n</li>\n<li><p>UML图插件</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save hexo-tag-plantuml</span><br></pre></td></tr></table></figure>\n<p> 语法参考: <a href=\"https://plantuml.com/zh/class-diagram\">https://plantuml.com/zh/class-diagram</a><br> 预览效果: <a href=\"https://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000\">https://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000</a></p>\n <img  src=http://www.plantuml.com/plantuml/svg/yyhFp2i0uX85cnfTNGNFlBByvCIIpFmyBg1OQb5QOdAgWXTSJNKjaZ12BKYS2uaBDietjIGZFmMhWUXIOFqOWc1J0ehoAohn68LL7cmUTXcR6ZqzXQ3Kj9pKv9BCibHqUG00></li>\n</ol>\n<h2 id=\"特殊语法\"><a href=\"#特殊语法\" class=\"headerlink\" title=\"特殊语法\"></a>特殊语法</h2><ol>\n<li>站内文章链接<a href=\"#\">Post not found: file_name display name</a></li>\n</ol>\n<h2 id=\"日常操作流程\"><a href=\"#日常操作流程\" class=\"headerlink\" title=\"日常操作流程\"></a>日常操作流程</h2><ol>\n<li>写博客<code>hexo new post [new-blog-name]</code>, 在<code>source/_post/</code>下就生成了一个新的博客文件, 可以用其他markdown编辑工具来编写, 比如Typora</li>\n<li>在博客文档的开头可以设置标签和分类</li>\n<li>写完之后, 提交源码<code>git add </code>&amp;<code>git commit</code>&amp;<code>git push</code></li>\n<li>部署发布<code>hexo clean</code>&amp;<code>hexo generate</code>&amp;<code>hexo deploy</code></li>\n</ol>\n<h1 id=\"Troubleshooting\"><a href=\"#Troubleshooting\" class=\"headerlink\" title=\"Troubleshooting\"></a>Troubleshooting</h1><p>总结一些在部署中的错误解决</p>\n<ol>\n<li>在执行<code>hexo generate</code>中出现错误: <code>Template render error: (unknown path)</code>, 多半是语法错误, 比如, 在使用<code>&#123;% xxx %&#125;</code>时写成了<code>&#123; % xxx %&#125;</code>, 前方多了一个空格.</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>一直以来，使用其他工具来记录技术知识的积累，以后陆续将其转到github上。使用Hexo搭建项目可以自动将文档生成静态HTML等文件，上传到github上，随时通过your-github-name.github.io查看自己的公开静态信息库。</p>\n<h2 id=\"Github准备操作\"><a href=\"#Github准备操作\" class=\"headerlink\" title=\"Github准备操作\"></a>Github准备操作</h2><ol>\n<li>首先在github上创建一个新的repository，其中<code>Repository name</code>为<code>[your-github-name].github.io</code>，设为开源, 用来存放生成的静态文件, 先不创建任何文件和分支.</li>\n<li>在创建一个repository, <code>Repository name</code>最好设为<code>github-bolg</code>(根据个人喜好), 这个项目存放文档以及源码</li>\n<li>将ssh公钥<code>id_ras.pub</code>内容添加到个人信息 &gt; settings &gt; SSH keys</li>\n</ol>\n<h2 id=\"本地准备操作\"><a href=\"#本地准备操作\" class=\"headerlink\" title=\"本地准备操作\"></a>本地准备操作</h2><ol>\n<li><p>安装Node.js (默认安装了npm)</p>\n</li>\n<li><p>npm的配置, 对前端不是很熟, 这里需要记录一下</p>\n<ul>\n<li><p>在Windows默认的用户目录下, 新建<code>C:\\Users\\your-user-name\\.npmrc</code>文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">registry=https://registry.npm.taobao.org</span><br><span class=\"line\">prefix=D:\\apps\\nodejs\\node_global</span><br><span class=\"line\">cache=D:\\apps\\nodejs\\node_cache</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>安装<code>npm install -g hexo</code></p>\n</li>\n<li><p>初始化<code>hexo init [your-project-name]</code></p>\n</li>\n<li><p>此时可以进行一步本地启动尝试. 执行三个命令: <code>hexo clean</code>&amp;<code>hexo generate</code>&amp;<code>hexo server</code>, 如果成功访问<code>localhost:4000</code>说明初始化成功</p>\n</li>\n<li><p>进入项目根目录查看</p>\n<ul>\n<li><code>.deploy_git</code>&amp;<code>.github</code>不明其意, 勿动</li>\n<li><code>source/_posts</code>存放源文档, 未来soure中还会加入<code>about</code>, <code>categoryies</code>, <code>tags</code>文件夹, 分别对应了<code>关于</code> , <code>分类</code>, <code>标签</code>页面的源文档. </li>\n<li><code>themes</code>对应主题, 每个主题都会是一个文件夹</li>\n<li><code>_config.yml</code>记录了整个项目的配置, 包括显示的语言, 时区等</li>\n<li><code>package.json</code>&amp;<code>package-lock.json</code>为项目依赖包的记录</li>\n<li><code>public</code>文件夹是生成的静态文件保存的位置, 对应<code>[your-github-name].github.io</code>仓库</li>\n<li><code>node_modules</code>对应依赖包信息</li>\n</ul>\n</li>\n<li><p>整个项目初始化为git项目, 并添加<code>.gitignore</code>文件</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.DS_Store</span><br><span class=\"line\">Thumbs.db</span><br><span class=\"line\">db.json</span><br><span class=\"line\">*.log</span><br><span class=\"line\">node_modules/</span><br><span class=\"line\">public/</span><br><span class=\"line\">.deploy*/</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><blockquote>\n<p>通过此gitignore文件可以看出向<code>[github-blog]</code>repository推送的包括源文档, 主题文件和配置文件</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">git remote add origin [github-bolg repository ssh address]</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"keyword\">for</span> example: $ git remote add origin git@github.com:the-Rings/github-blog.git</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> github从2020年12月份之后, 不再支持用户名&amp;密码方式推送项目, 所以这里是ssh address, 配合我们之前加入的SSH keys使用</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;something&quot;</span><br><span class=\"line\">git push --set-upstream main</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 推送完成</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>配置<code>_config.yml</code>向<code>[your-github-name].github.io</code>仓库推送public下的文件, 这是不需要初始化git仓库, 使用hexo相关工具完成</p>\n <figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 编辑_config.yml中的deploy选项</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">git@github.com:[your-github-name]/[your-github-name].github.io.git</span> <span class=\"comment\"># 复制仓库的SSH地址</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">main</span> <span class=\"comment\"># 分支默认为main即可</span></span><br></pre></td></tr></table></figure></li>\n<li><p>安装<code>npm install hexo-deployer-git --save</code>, 这个工具来向github推送静态文件</p>\n</li>\n<li><p>通过<code>hexo clean</code>&amp;<code>hexo generate</code>&amp;<code>hexo deploy</code>三个命令组合完成, 实际上每次修改之后都是这一顿操作.</p>\n</li>\n</ol>\n<h2 id=\"主题等相关配置操作\"><a href=\"#主题等相关配置操作\" class=\"headerlink\" title=\"主题等相关配置操作\"></a>主题等相关配置操作</h2><ol>\n<li><p>选用<code>Next</code>主题, 然后对<code>theme/next</code>中的配置文件进行相关设置, 这里参考网友们的答案即可, 主要是对首页、归档、分类、标签、关于进行相关设置和注释放开, 并通过命令增加对应的模块</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page categories</span><br><span class=\"line\">hexo new page tags</span><br><span class=\"line\">hexo new page about</span><br></pre></td></tr></table></figure></li>\n<li><p>启用搜索功能, 在项目的根目录下<code>_config.yml</code>找到<code>Extensions</code>, 增加配置, 并执行<code>$ npm install hexo-generator-searchdb --save</code></p>\n <figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">search:</span></span><br><span class=\"line\">  <span class=\"attr\">path:</span> <span class=\"string\">search.xml</span></span><br><span class=\"line\">  <span class=\"attr\">field:</span> <span class=\"string\">post</span></span><br><span class=\"line\">  <span class=\"attr\">format:</span> <span class=\"string\">html</span></span><br><span class=\"line\">  <span class=\"attr\">limit:</span> <span class=\"number\">10000</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>然后, 在主题配置文件<code>theme/next/.config.yml</code>中设置<code>local_search: enable: true</code></li>\n</ul>\n</li>\n<li><p>UML图插件</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save hexo-tag-plantuml</span><br></pre></td></tr></table></figure>\n<p> 语法参考: <a href=\"https://plantuml.com/zh/class-diagram\">https://plantuml.com/zh/class-diagram</a><br> 预览效果: <a href=\"https://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000\">https://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000</a></p>\n <img  src=http://www.plantuml.com/plantuml/svg/yyhFp2i0uX85cnfTNGNFlBByvCIIpFmyBg1OQb5QOdAgWXTSJNKjaZ12BKYS2uaBDietjIGZFmMhWUXIOFqOWc1J0ehoAohn68LL7cmUTXcR6ZqzXQ3Kj9pKv9BCibHqUG00></li>\n</ol>\n<h2 id=\"特殊语法\"><a href=\"#特殊语法\" class=\"headerlink\" title=\"特殊语法\"></a>特殊语法</h2><ol>\n<li>站内文章链接<a href=\"#\">Post not found: file_name display name</a></li>\n</ol>\n<h2 id=\"日常操作流程\"><a href=\"#日常操作流程\" class=\"headerlink\" title=\"日常操作流程\"></a>日常操作流程</h2><ol>\n<li>写博客<code>hexo new post [new-blog-name]</code>, 在<code>source/_post/</code>下就生成了一个新的博客文件, 可以用其他markdown编辑工具来编写, 比如Typora</li>\n<li>在博客文档的开头可以设置标签和分类</li>\n<li>写完之后, 提交源码<code>git add </code>&amp;<code>git commit</code>&amp;<code>git push</code></li>\n<li>部署发布<code>hexo clean</code>&amp;<code>hexo generate</code>&amp;<code>hexo deploy</code></li>\n</ol>\n<h1 id=\"Troubleshooting\"><a href=\"#Troubleshooting\" class=\"headerlink\" title=\"Troubleshooting\"></a>Troubleshooting</h1><p>总结一些在部署中的错误解决</p>\n<ol>\n<li>在执行<code>hexo generate</code>中出现错误: <code>Template render error: (unknown path)</code>, 多半是语法错误, 比如, 在使用<code>&#123;% xxx %&#125;</code>时写成了<code>&#123; % xxx %&#125;</code>, 前方多了一个空格.</li>\n</ol>\n"},{"title":"Java注解","date":"2021-07-24T02:31:14.000Z","_content":"\n通过格式化的方式让代码附带信息, 之后根据这些约定好的格式, 在源代码时期, 编译时期和运行时期, 通过Annotation Processor做一些操作. 注解可以理解为一种特殊的注释, 只不过是给机器看的.\n定义注解的语法看起来就像在定义一个接口.\n\n# Annotation\n定义在注解中的类型包括: 基本类型(All primitives)、String、Class、enum、Annotation以及以上这些类型组成的数组。\n\n注解不支持继承.\n\n有五种元注解, 元注解用于注解其他注解. 其中@Target和@Retention是必须的. @Retention标识了注解在那个阶段起作用，参数SOURCE，CLASS，RUNTIME中的一个，其中SOURCE表示注解将会被编译器丢弃（忽略），CLASS表示注解将会被JVM丢弃（忽略），RUNTIME表示注解可以再运行时起作用，并一直保留，所以可以通过反射读取注解信息。也就是说，SOURCE在complie time起作用，javac编译完就丢弃，比如@SuppressWarnings @Override就用在启动编译的时候。比如:\n有一个类库叫mapstruct，其中@Mapper注解用在接口上对应@Retentation(RetentationPolicy.CLASS)。在它编译打包后，会在target/generated-sources/annotations/下生成对应的实现类的java文件，然后生成实现类的class文件。\n\n那么问题来了，SOURCE也是在编译时起作用，究竟在那个阶段呢？以下这张图展示了Java的编译过程：\n{% plantuml %}\nstart\n\n: your source code;\n\nrepeat: Parse and Enter;\n    : ...;\nrepeat while (Annotation Processing)\n\n: Analyse and Generate;\n: 100100010;\n\nend\n{% endplantuml %}\n\n在Annotation Processing的过程之后，RetentationPolicy.SOURCE就被丢弃了，同时RetentationPolicy.CLASS的注解要还保留在class文件中。\n\n\n## Useing javac to Process Annotations\n自定义注解之后，如果不对其进行处理，那么注解不会比注释更有用。\n\n如果要在编译时期做一些事情(利用注解生成代码), 这时就需要用到`Annotation Processor`, 具体的做法是继承AbstractProcessor, 然后实现其process方法.\n\nAnnotation Processor机制是什么？.\n如果在上一轮的processing中生成一个新的source code文件，那么这个文件将被再次检查annotation，直到没有新的source file产生。最后所有的源文件都被编译完成。这就是为什么mapstruct先生成java文件，然后生成class文件。\n\n## Runtime Annotations Processing\n在运行时通过反射完成一些操作的话，不是继承AbstractProcessor，只需要通过Java反射API中扩展的getAnnotation(xxx.class)方法即可。\n\n比如，通过自定义注解@Query(...)来实现动态查询，事先在一个类Criteria，其中声明好查询条件的字段Fields，都用@Query装饰。然后写这样一个方法，接收Criteria对象criteria，criterai.getClass().getDeclaredFields()，遍历这个数组，然后对数组中的每个Field，field.setAccessible(true)，保证对private的访问。然后field.getAnnotation(Query.class)获得当前这个@Query传入的参数，确定查询条件是等于，like等等。根据filed.getName()获得字段名称，filed.get(criteria)获得对象中此属性的值。\n```java\nimport cn.hutool.core.util.ObjectUtil;\nimport com.lee.annotation.Query;\nimport com.lee.config.mybatis.SimpleQueryWrapper;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport lombok.extern.slf4j.Slf4j;\n\n/**\n * @author guomaoqing907\n */\n@Slf4j\n@SuppressWarnings({\"unchecked\", \"all\"})\npublic class QueryHelpForMybatis<T> {\n  public static <T, Q> SimpleQueryWrapper<T> getQueryCondition(Q query) {\n    List<SimpleQueryWrapper<T>> list = new ArrayList<SimpleQueryWrapper<T>>();\n    SimpleQueryWrapper<T> qw = new SimpleQueryWrapper<>();\n    if (query == null) {\n      return qw;\n    }\n    try {\n      List<Field> fields = getAllFields(query.getClass(), new ArrayList<>());\n      for (Field field : fields) {\n        boolean accessible = field.isAccessible();\n        // 设置对象的访问权限，保证对private的属性的访\n        field.setAccessible(true);\n        Query q = field.getAnnotation(Query.class);\n        if (q != null) {\n          String propName = q.propName();\n          String joinName = q.joinName();\n          // 不支持join表的条件，需要在具体查询接口处另作处理\n          if (!isBlank(joinName)) {\n            continue;\n          }\n          String blurry = q.blurry();\n          String attributeName = isBlank(propName) ? field.getName() : propName;\n          boolean sortType = q.sortType();\n          Class<?> fieldType = field.getType();\n          Object val = field.get(query);\n          if (ObjectUtil.isNull(val) || \"\".equals(val) || ObjectUtil.isEmpty(val)) {\n            continue;\n          }\n          // 模糊多字段\n          if (ObjectUtil.isNotEmpty(blurry)) {\n            String[] blurrys = blurry.split(\",\");\n            List<SimpleQueryWrapper<T>> conditionChain = new ArrayList<>();\n            // NOTE: 如何实现 (a like '..' or b like '..' or c like '..') and d = '..'\n            for (String s : blurrys) {\n              qw.or().like(s, val.toString());\n            }\n            continue;\n          }\n          switch (q.type()) {\n            case EQUAL:\n              qw.eq(attributeName, val);\n              break;\n            case GREATER_THAN:\n              qw.and(obj -> obj.ge(attributeName, val));\n              break;\n            case LESS_THAN:\n              qw.and(obj -> obj.le(attributeName, val));\n              break;\n            case LESS_THAN_NQ:\n              qw.and(obj -> obj.lt(attributeName, val));\n              break;\n            case INNER_LIKE:\n              qw.and(obj -> obj.like(attributeName, val));\n              break;\n            case LEFT_LIKE:\n              qw.and(obj -> obj.likeLeft(attributeName, val));\n              break;\n            case RIGHT_LIKE:\n              qw.and(obj -> obj.likeRight(attributeName, val));\n              break;\n            case IN:\n              List valList = (ArrayList) val;\n              Object[] objArray = valList.toArray();\n              qw.and(obj -> obj.in(attributeName, objArray));\n              break;\n            case NOT_EQUAL:\n              qw.and(obj -> obj.ne(attributeName, val));\n              break;\n            case NOT_NULL:\n              qw.and(obj -> obj.isNotNull(attributeName));\n              break;\n            case IS_NULL:\n              qw.and(obj -> obj.isNull(attributeName));\n              break;\n            case BETWEEN:\n              List<Object> between = new ArrayList<>((List<Object>) val);\n              qw.and(obj -> obj.between(attributeName, between.get(0), between.get(1)));\n              break;\n            case SORT:\n              List valListSort = (ArrayList) val ;\n              Object[] objArraySort = valListSort.toArray();\n              if(valListSort.toString().split(\",\").length<=2){\n                Object object = \"asc\";\n                if (objArraySort[1].equals(object)){\n                   qw.orderBy(true, true, objArraySort[0].toString());\n                }else {\n                  qw.orderBy(true, false, objArraySort[0].toString());\n                }\n              }\n              else {\n                String[] stringsSort;\n                for (Object objectSort : objArraySort){\n                  stringsSort=objectSort.toString().split(\",\");\n                  if (stringsSort[1].equals(\"asc\")){\n                    qw.orderBy(true, true, stringsSort[0]);\n                  }else {\n                    qw.orderBy(true, false, stringsSort[0]);\n                  }\n                }\n              }\n              break;\n            default:\n          }\n        }\n        field.setAccessible(accessible);\n      }\n    } catch (Exception e) {\n      log.error(e.getMessage(), e);\n    }\n    return qw;\n  }\n\n  private static boolean isBlank(final CharSequence cs) {\n    int strLen;\n    if (cs == null || (strLen = cs.length()) == 0) {\n      return true;\n    }\n    for (int i = 0; i < strLen; i++) {\n      if (!Character.isWhitespace(cs.charAt(i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public static List<Field> getAllFields(Class clazz, List<Field> fields) {\n    if (clazz != null) {\n      fields.addAll(Arrays.asList(clazz.getDeclaredFields()));\n      getAllFields(clazz.getSuperclass(), fields);\n    }\n    return fields;\n  }\n}\n```\n\n\n","source":"_posts/java-annotation.md","raw":"---\ntitle: Java注解\ndate: 2021-07-24 10:31:14\ncategories:\n- Java\n---\n\n通过格式化的方式让代码附带信息, 之后根据这些约定好的格式, 在源代码时期, 编译时期和运行时期, 通过Annotation Processor做一些操作. 注解可以理解为一种特殊的注释, 只不过是给机器看的.\n定义注解的语法看起来就像在定义一个接口.\n\n# Annotation\n定义在注解中的类型包括: 基本类型(All primitives)、String、Class、enum、Annotation以及以上这些类型组成的数组。\n\n注解不支持继承.\n\n有五种元注解, 元注解用于注解其他注解. 其中@Target和@Retention是必须的. @Retention标识了注解在那个阶段起作用，参数SOURCE，CLASS，RUNTIME中的一个，其中SOURCE表示注解将会被编译器丢弃（忽略），CLASS表示注解将会被JVM丢弃（忽略），RUNTIME表示注解可以再运行时起作用，并一直保留，所以可以通过反射读取注解信息。也就是说，SOURCE在complie time起作用，javac编译完就丢弃，比如@SuppressWarnings @Override就用在启动编译的时候。比如:\n有一个类库叫mapstruct，其中@Mapper注解用在接口上对应@Retentation(RetentationPolicy.CLASS)。在它编译打包后，会在target/generated-sources/annotations/下生成对应的实现类的java文件，然后生成实现类的class文件。\n\n那么问题来了，SOURCE也是在编译时起作用，究竟在那个阶段呢？以下这张图展示了Java的编译过程：\n{% plantuml %}\nstart\n\n: your source code;\n\nrepeat: Parse and Enter;\n    : ...;\nrepeat while (Annotation Processing)\n\n: Analyse and Generate;\n: 100100010;\n\nend\n{% endplantuml %}\n\n在Annotation Processing的过程之后，RetentationPolicy.SOURCE就被丢弃了，同时RetentationPolicy.CLASS的注解要还保留在class文件中。\n\n\n## Useing javac to Process Annotations\n自定义注解之后，如果不对其进行处理，那么注解不会比注释更有用。\n\n如果要在编译时期做一些事情(利用注解生成代码), 这时就需要用到`Annotation Processor`, 具体的做法是继承AbstractProcessor, 然后实现其process方法.\n\nAnnotation Processor机制是什么？.\n如果在上一轮的processing中生成一个新的source code文件，那么这个文件将被再次检查annotation，直到没有新的source file产生。最后所有的源文件都被编译完成。这就是为什么mapstruct先生成java文件，然后生成class文件。\n\n## Runtime Annotations Processing\n在运行时通过反射完成一些操作的话，不是继承AbstractProcessor，只需要通过Java反射API中扩展的getAnnotation(xxx.class)方法即可。\n\n比如，通过自定义注解@Query(...)来实现动态查询，事先在一个类Criteria，其中声明好查询条件的字段Fields，都用@Query装饰。然后写这样一个方法，接收Criteria对象criteria，criterai.getClass().getDeclaredFields()，遍历这个数组，然后对数组中的每个Field，field.setAccessible(true)，保证对private的访问。然后field.getAnnotation(Query.class)获得当前这个@Query传入的参数，确定查询条件是等于，like等等。根据filed.getName()获得字段名称，filed.get(criteria)获得对象中此属性的值。\n```java\nimport cn.hutool.core.util.ObjectUtil;\nimport com.lee.annotation.Query;\nimport com.lee.config.mybatis.SimpleQueryWrapper;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport lombok.extern.slf4j.Slf4j;\n\n/**\n * @author guomaoqing907\n */\n@Slf4j\n@SuppressWarnings({\"unchecked\", \"all\"})\npublic class QueryHelpForMybatis<T> {\n  public static <T, Q> SimpleQueryWrapper<T> getQueryCondition(Q query) {\n    List<SimpleQueryWrapper<T>> list = new ArrayList<SimpleQueryWrapper<T>>();\n    SimpleQueryWrapper<T> qw = new SimpleQueryWrapper<>();\n    if (query == null) {\n      return qw;\n    }\n    try {\n      List<Field> fields = getAllFields(query.getClass(), new ArrayList<>());\n      for (Field field : fields) {\n        boolean accessible = field.isAccessible();\n        // 设置对象的访问权限，保证对private的属性的访\n        field.setAccessible(true);\n        Query q = field.getAnnotation(Query.class);\n        if (q != null) {\n          String propName = q.propName();\n          String joinName = q.joinName();\n          // 不支持join表的条件，需要在具体查询接口处另作处理\n          if (!isBlank(joinName)) {\n            continue;\n          }\n          String blurry = q.blurry();\n          String attributeName = isBlank(propName) ? field.getName() : propName;\n          boolean sortType = q.sortType();\n          Class<?> fieldType = field.getType();\n          Object val = field.get(query);\n          if (ObjectUtil.isNull(val) || \"\".equals(val) || ObjectUtil.isEmpty(val)) {\n            continue;\n          }\n          // 模糊多字段\n          if (ObjectUtil.isNotEmpty(blurry)) {\n            String[] blurrys = blurry.split(\",\");\n            List<SimpleQueryWrapper<T>> conditionChain = new ArrayList<>();\n            // NOTE: 如何实现 (a like '..' or b like '..' or c like '..') and d = '..'\n            for (String s : blurrys) {\n              qw.or().like(s, val.toString());\n            }\n            continue;\n          }\n          switch (q.type()) {\n            case EQUAL:\n              qw.eq(attributeName, val);\n              break;\n            case GREATER_THAN:\n              qw.and(obj -> obj.ge(attributeName, val));\n              break;\n            case LESS_THAN:\n              qw.and(obj -> obj.le(attributeName, val));\n              break;\n            case LESS_THAN_NQ:\n              qw.and(obj -> obj.lt(attributeName, val));\n              break;\n            case INNER_LIKE:\n              qw.and(obj -> obj.like(attributeName, val));\n              break;\n            case LEFT_LIKE:\n              qw.and(obj -> obj.likeLeft(attributeName, val));\n              break;\n            case RIGHT_LIKE:\n              qw.and(obj -> obj.likeRight(attributeName, val));\n              break;\n            case IN:\n              List valList = (ArrayList) val;\n              Object[] objArray = valList.toArray();\n              qw.and(obj -> obj.in(attributeName, objArray));\n              break;\n            case NOT_EQUAL:\n              qw.and(obj -> obj.ne(attributeName, val));\n              break;\n            case NOT_NULL:\n              qw.and(obj -> obj.isNotNull(attributeName));\n              break;\n            case IS_NULL:\n              qw.and(obj -> obj.isNull(attributeName));\n              break;\n            case BETWEEN:\n              List<Object> between = new ArrayList<>((List<Object>) val);\n              qw.and(obj -> obj.between(attributeName, between.get(0), between.get(1)));\n              break;\n            case SORT:\n              List valListSort = (ArrayList) val ;\n              Object[] objArraySort = valListSort.toArray();\n              if(valListSort.toString().split(\",\").length<=2){\n                Object object = \"asc\";\n                if (objArraySort[1].equals(object)){\n                   qw.orderBy(true, true, objArraySort[0].toString());\n                }else {\n                  qw.orderBy(true, false, objArraySort[0].toString());\n                }\n              }\n              else {\n                String[] stringsSort;\n                for (Object objectSort : objArraySort){\n                  stringsSort=objectSort.toString().split(\",\");\n                  if (stringsSort[1].equals(\"asc\")){\n                    qw.orderBy(true, true, stringsSort[0]);\n                  }else {\n                    qw.orderBy(true, false, stringsSort[0]);\n                  }\n                }\n              }\n              break;\n            default:\n          }\n        }\n        field.setAccessible(accessible);\n      }\n    } catch (Exception e) {\n      log.error(e.getMessage(), e);\n    }\n    return qw;\n  }\n\n  private static boolean isBlank(final CharSequence cs) {\n    int strLen;\n    if (cs == null || (strLen = cs.length()) == 0) {\n      return true;\n    }\n    for (int i = 0; i < strLen; i++) {\n      if (!Character.isWhitespace(cs.charAt(i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public static List<Field> getAllFields(Class clazz, List<Field> fields) {\n    if (clazz != null) {\n      fields.addAll(Arrays.asList(clazz.getDeclaredFields()));\n      getAllFields(clazz.getSuperclass(), fields);\n    }\n    return fields;\n  }\n}\n```\n\n\n","slug":"java-annotation","published":1,"updated":"2021-12-30T03:00:39.701Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxsdzpya0007xotg13uchtu0","content":"<p>通过格式化的方式让代码附带信息, 之后根据这些约定好的格式, 在源代码时期, 编译时期和运行时期, 通过Annotation Processor做一些操作. 注解可以理解为一种特殊的注释, 只不过是给机器看的.<br>定义注解的语法看起来就像在定义一个接口.</p>\n<h1 id=\"Annotation\"><a href=\"#Annotation\" class=\"headerlink\" title=\"Annotation\"></a>Annotation</h1><p>定义在注解中的类型包括: 基本类型(All primitives)、String、Class、enum、Annotation以及以上这些类型组成的数组。</p>\n<p>注解不支持继承.</p>\n<p>有五种元注解, 元注解用于注解其他注解. 其中@Target和@Retention是必须的. @Retention标识了注解在那个阶段起作用，参数SOURCE，CLASS，RUNTIME中的一个，其中SOURCE表示注解将会被编译器丢弃（忽略），CLASS表示注解将会被JVM丢弃（忽略），RUNTIME表示注解可以再运行时起作用，并一直保留，所以可以通过反射读取注解信息。也就是说，SOURCE在complie time起作用，javac编译完就丢弃，比如@SuppressWarnings @Override就用在启动编译的时候。比如:<br>有一个类库叫mapstruct，其中@Mapper注解用在接口上对应@Retentation(RetentationPolicy.CLASS)。在它编译打包后，会在target/generated-sources/annotations/下生成对应的实现类的java文件，然后生成实现类的class文件。</p>\n<p>那么问题来了，SOURCE也是在编译时起作用，究竟在那个阶段呢？以下这张图展示了Java的编译过程：</p>\n<img  src=http://www.plantuml.com/plantuml/svg/BOsn2WCn34DtVuN6TWdNDPbkA5tl5qnYsi3X5CUbtD_NXHEI9l4qdSs9CexnCSoeAgYZII4oUGjxniOs1QmDTtMnGWXbf9JAkS7trNV1PLKTpjw7OhDHPSwkp-iVlohlnqbvY8gnnqN6RLd2aVWJRJy0>\n\n<p>在Annotation Processing的过程之后，RetentationPolicy.SOURCE就被丢弃了，同时RetentationPolicy.CLASS的注解要还保留在class文件中。</p>\n<h2 id=\"Useing-javac-to-Process-Annotations\"><a href=\"#Useing-javac-to-Process-Annotations\" class=\"headerlink\" title=\"Useing javac to Process Annotations\"></a>Useing javac to Process Annotations</h2><p>自定义注解之后，如果不对其进行处理，那么注解不会比注释更有用。</p>\n<p>如果要在编译时期做一些事情(利用注解生成代码), 这时就需要用到<code>Annotation Processor</code>, 具体的做法是继承AbstractProcessor, 然后实现其process方法.</p>\n<p>Annotation Processor机制是什么？.<br>如果在上一轮的processing中生成一个新的source code文件，那么这个文件将被再次检查annotation，直到没有新的source file产生。最后所有的源文件都被编译完成。这就是为什么mapstruct先生成java文件，然后生成class文件。</p>\n<h2 id=\"Runtime-Annotations-Processing\"><a href=\"#Runtime-Annotations-Processing\" class=\"headerlink\" title=\"Runtime Annotations Processing\"></a>Runtime Annotations Processing</h2><p>在运行时通过反射完成一些操作的话，不是继承AbstractProcessor，只需要通过Java反射API中扩展的getAnnotation(xxx.class)方法即可。</p>\n<p>比如，通过自定义注解@Query(…)来实现动态查询，事先在一个类Criteria，其中声明好查询条件的字段Fields，都用@Query装饰。然后写这样一个方法，接收Criteria对象criteria，criterai.getClass().getDeclaredFields()，遍历这个数组，然后对数组中的每个Field，field.setAccessible(true)，保证对private的访问。然后field.getAnnotation(Query.class)获得当前这个@Query传入的参数，确定查询条件是等于，like等等。根据filed.getName()获得字段名称，filed.get(criteria)获得对象中此属性的值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cn.hutool.core.util.ObjectUtil;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.lee.annotation.Query;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.lee.config.mybatis.SimpleQueryWrapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Field;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> guomaoqing907</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;all&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueryHelpForMybatis</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T, Q&gt; <span class=\"function\">SimpleQueryWrapper&lt;T&gt; <span class=\"title\">getQueryCondition</span><span class=\"params\">(Q query)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;SimpleQueryWrapper&lt;T&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;SimpleQueryWrapper&lt;T&gt;&gt;();</span><br><span class=\"line\">    SimpleQueryWrapper&lt;T&gt; qw = <span class=\"keyword\">new</span> SimpleQueryWrapper&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (query == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> qw;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      List&lt;Field&gt; fields = getAllFields(query.getClass(), <span class=\"keyword\">new</span> ArrayList&lt;&gt;());</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (Field field : fields) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> accessible = field.isAccessible();</span><br><span class=\"line\">        <span class=\"comment\">// 设置对象的访问权限，保证对private的属性的访</span></span><br><span class=\"line\">        field.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        Query q = field.getAnnotation(Query.class);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (q != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          String propName = q.propName();</span><br><span class=\"line\">          String joinName = q.joinName();</span><br><span class=\"line\">          <span class=\"comment\">// 不支持join表的条件，需要在具体查询接口处另作处理</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!isBlank(joinName)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          String blurry = q.blurry();</span><br><span class=\"line\">          String attributeName = isBlank(propName) ? field.getName() : propName;</span><br><span class=\"line\">          <span class=\"keyword\">boolean</span> sortType = q.sortType();</span><br><span class=\"line\">          Class&lt;?&gt; fieldType = field.getType();</span><br><span class=\"line\">          Object val = field.get(query);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (ObjectUtil.isNull(val) || <span class=\"string\">&quot;&quot;</span>.equals(val) || ObjectUtil.isEmpty(val)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">// 模糊多字段</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (ObjectUtil.isNotEmpty(blurry)) &#123;</span><br><span class=\"line\">            String[] blurrys = blurry.split(<span class=\"string\">&quot;,&quot;</span>);</span><br><span class=\"line\">            List&lt;SimpleQueryWrapper&lt;T&gt;&gt; conditionChain = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> 如何实现 (a like &#x27;..&#x27; or b like &#x27;..&#x27; or c like &#x27;..&#x27;) and d = &#x27;..&#x27;</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String s : blurrys) &#123;</span><br><span class=\"line\">              qw.or().like(s, val.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">switch</span> (q.type()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> EQUAL:</span><br><span class=\"line\">              qw.eq(attributeName, val);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> GREATER_THAN:</span><br><span class=\"line\">              qw.and(obj -&gt; obj.ge(attributeName, val));</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LESS_THAN:</span><br><span class=\"line\">              qw.and(obj -&gt; obj.le(attributeName, val));</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LESS_THAN_NQ:</span><br><span class=\"line\">              qw.and(obj -&gt; obj.lt(attributeName, val));</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> INNER_LIKE:</span><br><span class=\"line\">              qw.and(obj -&gt; obj.like(attributeName, val));</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LEFT_LIKE:</span><br><span class=\"line\">              qw.and(obj -&gt; obj.likeLeft(attributeName, val));</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> RIGHT_LIKE:</span><br><span class=\"line\">              qw.and(obj -&gt; obj.likeRight(attributeName, val));</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> IN:</span><br><span class=\"line\">              List valList = (ArrayList) val;</span><br><span class=\"line\">              Object[] objArray = valList.toArray();</span><br><span class=\"line\">              qw.and(obj -&gt; obj.in(attributeName, objArray));</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> NOT_EQUAL:</span><br><span class=\"line\">              qw.and(obj -&gt; obj.ne(attributeName, val));</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> NOT_NULL:</span><br><span class=\"line\">              qw.and(obj -&gt; obj.isNotNull(attributeName));</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> IS_NULL:</span><br><span class=\"line\">              qw.and(obj -&gt; obj.isNull(attributeName));</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> BETWEEN:</span><br><span class=\"line\">              List&lt;Object&gt; between = <span class=\"keyword\">new</span> ArrayList&lt;&gt;((List&lt;Object&gt;) val);</span><br><span class=\"line\">              qw.and(obj -&gt; obj.between(attributeName, between.get(<span class=\"number\">0</span>), between.get(<span class=\"number\">1</span>)));</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> SORT:</span><br><span class=\"line\">              List valListSort = (ArrayList) val ;</span><br><span class=\"line\">              Object[] objArraySort = valListSort.toArray();</span><br><span class=\"line\">              <span class=\"keyword\">if</span>(valListSort.toString().split(<span class=\"string\">&quot;,&quot;</span>).length&lt;=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">                Object object = <span class=\"string\">&quot;asc&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (objArraySort[<span class=\"number\">1</span>].equals(object))&#123;</span><br><span class=\"line\">                   qw.orderBy(<span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>, objArraySort[<span class=\"number\">0</span>].toString());</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                  qw.orderBy(<span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, objArraySort[<span class=\"number\">0</span>].toString());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                String[] stringsSort;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Object objectSort : objArraySort)&#123;</span><br><span class=\"line\">                  stringsSort=objectSort.toString().split(<span class=\"string\">&quot;,&quot;</span>);</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (stringsSort[<span class=\"number\">1</span>].equals(<span class=\"string\">&quot;asc&quot;</span>))&#123;</span><br><span class=\"line\">                    qw.orderBy(<span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>, stringsSort[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                  &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    qw.orderBy(<span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, stringsSort[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        field.setAccessible(accessible);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      log.error(e.getMessage(), e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> qw;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isBlank</span><span class=\"params\">(<span class=\"keyword\">final</span> CharSequence cs)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> strLen;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cs == <span class=\"keyword\">null</span> || (strLen = cs.length()) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strLen; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!Character.isWhitespace(cs.charAt(i))) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Field&gt; <span class=\"title\">getAllFields</span><span class=\"params\">(Class clazz, List&lt;Field&gt; fields)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clazz != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      fields.addAll(Arrays.asList(clazz.getDeclaredFields()));</span><br><span class=\"line\">      getAllFields(clazz.getSuperclass(), fields);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fields;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p>通过格式化的方式让代码附带信息, 之后根据这些约定好的格式, 在源代码时期, 编译时期和运行时期, 通过Annotation Processor做一些操作. 注解可以理解为一种特殊的注释, 只不过是给机器看的.<br>定义注解的语法看起来就像在定义一个接口.</p>\n<h1 id=\"Annotation\"><a href=\"#Annotation\" class=\"headerlink\" title=\"Annotation\"></a>Annotation</h1><p>定义在注解中的类型包括: 基本类型(All primitives)、String、Class、enum、Annotation以及以上这些类型组成的数组。</p>\n<p>注解不支持继承.</p>\n<p>有五种元注解, 元注解用于注解其他注解. 其中@Target和@Retention是必须的. @Retention标识了注解在那个阶段起作用，参数SOURCE，CLASS，RUNTIME中的一个，其中SOURCE表示注解将会被编译器丢弃（忽略），CLASS表示注解将会被JVM丢弃（忽略），RUNTIME表示注解可以再运行时起作用，并一直保留，所以可以通过反射读取注解信息。也就是说，SOURCE在complie time起作用，javac编译完就丢弃，比如@SuppressWarnings @Override就用在启动编译的时候。比如:<br>有一个类库叫mapstruct，其中@Mapper注解用在接口上对应@Retentation(RetentationPolicy.CLASS)。在它编译打包后，会在target/generated-sources/annotations/下生成对应的实现类的java文件，然后生成实现类的class文件。</p>\n<p>那么问题来了，SOURCE也是在编译时起作用，究竟在那个阶段呢？以下这张图展示了Java的编译过程：</p>\n<img  src=http://www.plantuml.com/plantuml/svg/BOsn2WCn34DtVuN6TWdNDPbkA5tl5qnYsi3X5CUbtD_NXHEI9l4qdSs9CexnCSoeAgYZII4oUGjxniOs1QmDTtMnGWXbf9JAkS7trNV1PLKTpjw7OhDHPSwkp-iVlohlnqbvY8gnnqN6RLd2aVWJRJy0>\n\n<p>在Annotation Processing的过程之后，RetentationPolicy.SOURCE就被丢弃了，同时RetentationPolicy.CLASS的注解要还保留在class文件中。</p>\n<h2 id=\"Useing-javac-to-Process-Annotations\"><a href=\"#Useing-javac-to-Process-Annotations\" class=\"headerlink\" title=\"Useing javac to Process Annotations\"></a>Useing javac to Process Annotations</h2><p>自定义注解之后，如果不对其进行处理，那么注解不会比注释更有用。</p>\n<p>如果要在编译时期做一些事情(利用注解生成代码), 这时就需要用到<code>Annotation Processor</code>, 具体的做法是继承AbstractProcessor, 然后实现其process方法.</p>\n<p>Annotation Processor机制是什么？.<br>如果在上一轮的processing中生成一个新的source code文件，那么这个文件将被再次检查annotation，直到没有新的source file产生。最后所有的源文件都被编译完成。这就是为什么mapstruct先生成java文件，然后生成class文件。</p>\n<h2 id=\"Runtime-Annotations-Processing\"><a href=\"#Runtime-Annotations-Processing\" class=\"headerlink\" title=\"Runtime Annotations Processing\"></a>Runtime Annotations Processing</h2><p>在运行时通过反射完成一些操作的话，不是继承AbstractProcessor，只需要通过Java反射API中扩展的getAnnotation(xxx.class)方法即可。</p>\n<p>比如，通过自定义注解@Query(…)来实现动态查询，事先在一个类Criteria，其中声明好查询条件的字段Fields，都用@Query装饰。然后写这样一个方法，接收Criteria对象criteria，criterai.getClass().getDeclaredFields()，遍历这个数组，然后对数组中的每个Field，field.setAccessible(true)，保证对private的访问。然后field.getAnnotation(Query.class)获得当前这个@Query传入的参数，确定查询条件是等于，like等等。根据filed.getName()获得字段名称，filed.get(criteria)获得对象中此属性的值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cn.hutool.core.util.ObjectUtil;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.lee.annotation.Query;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.lee.config.mybatis.SimpleQueryWrapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Field;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> guomaoqing907</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;all&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueryHelpForMybatis</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T, Q&gt; <span class=\"function\">SimpleQueryWrapper&lt;T&gt; <span class=\"title\">getQueryCondition</span><span class=\"params\">(Q query)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;SimpleQueryWrapper&lt;T&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;SimpleQueryWrapper&lt;T&gt;&gt;();</span><br><span class=\"line\">    SimpleQueryWrapper&lt;T&gt; qw = <span class=\"keyword\">new</span> SimpleQueryWrapper&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (query == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> qw;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      List&lt;Field&gt; fields = getAllFields(query.getClass(), <span class=\"keyword\">new</span> ArrayList&lt;&gt;());</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (Field field : fields) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> accessible = field.isAccessible();</span><br><span class=\"line\">        <span class=\"comment\">// 设置对象的访问权限，保证对private的属性的访</span></span><br><span class=\"line\">        field.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        Query q = field.getAnnotation(Query.class);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (q != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          String propName = q.propName();</span><br><span class=\"line\">          String joinName = q.joinName();</span><br><span class=\"line\">          <span class=\"comment\">// 不支持join表的条件，需要在具体查询接口处另作处理</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!isBlank(joinName)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          String blurry = q.blurry();</span><br><span class=\"line\">          String attributeName = isBlank(propName) ? field.getName() : propName;</span><br><span class=\"line\">          <span class=\"keyword\">boolean</span> sortType = q.sortType();</span><br><span class=\"line\">          Class&lt;?&gt; fieldType = field.getType();</span><br><span class=\"line\">          Object val = field.get(query);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (ObjectUtil.isNull(val) || <span class=\"string\">&quot;&quot;</span>.equals(val) || ObjectUtil.isEmpty(val)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">// 模糊多字段</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (ObjectUtil.isNotEmpty(blurry)) &#123;</span><br><span class=\"line\">            String[] blurrys = blurry.split(<span class=\"string\">&quot;,&quot;</span>);</span><br><span class=\"line\">            List&lt;SimpleQueryWrapper&lt;T&gt;&gt; conditionChain = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> 如何实现 (a like &#x27;..&#x27; or b like &#x27;..&#x27; or c like &#x27;..&#x27;) and d = &#x27;..&#x27;</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String s : blurrys) &#123;</span><br><span class=\"line\">              qw.or().like(s, val.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">switch</span> (q.type()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> EQUAL:</span><br><span class=\"line\">              qw.eq(attributeName, val);</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> GREATER_THAN:</span><br><span class=\"line\">              qw.and(obj -&gt; obj.ge(attributeName, val));</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LESS_THAN:</span><br><span class=\"line\">              qw.and(obj -&gt; obj.le(attributeName, val));</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LESS_THAN_NQ:</span><br><span class=\"line\">              qw.and(obj -&gt; obj.lt(attributeName, val));</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> INNER_LIKE:</span><br><span class=\"line\">              qw.and(obj -&gt; obj.like(attributeName, val));</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> LEFT_LIKE:</span><br><span class=\"line\">              qw.and(obj -&gt; obj.likeLeft(attributeName, val));</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> RIGHT_LIKE:</span><br><span class=\"line\">              qw.and(obj -&gt; obj.likeRight(attributeName, val));</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> IN:</span><br><span class=\"line\">              List valList = (ArrayList) val;</span><br><span class=\"line\">              Object[] objArray = valList.toArray();</span><br><span class=\"line\">              qw.and(obj -&gt; obj.in(attributeName, objArray));</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> NOT_EQUAL:</span><br><span class=\"line\">              qw.and(obj -&gt; obj.ne(attributeName, val));</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> NOT_NULL:</span><br><span class=\"line\">              qw.and(obj -&gt; obj.isNotNull(attributeName));</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> IS_NULL:</span><br><span class=\"line\">              qw.and(obj -&gt; obj.isNull(attributeName));</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> BETWEEN:</span><br><span class=\"line\">              List&lt;Object&gt; between = <span class=\"keyword\">new</span> ArrayList&lt;&gt;((List&lt;Object&gt;) val);</span><br><span class=\"line\">              qw.and(obj -&gt; obj.between(attributeName, between.get(<span class=\"number\">0</span>), between.get(<span class=\"number\">1</span>)));</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> SORT:</span><br><span class=\"line\">              List valListSort = (ArrayList) val ;</span><br><span class=\"line\">              Object[] objArraySort = valListSort.toArray();</span><br><span class=\"line\">              <span class=\"keyword\">if</span>(valListSort.toString().split(<span class=\"string\">&quot;,&quot;</span>).length&lt;=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">                Object object = <span class=\"string\">&quot;asc&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (objArraySort[<span class=\"number\">1</span>].equals(object))&#123;</span><br><span class=\"line\">                   qw.orderBy(<span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>, objArraySort[<span class=\"number\">0</span>].toString());</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                  qw.orderBy(<span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, objArraySort[<span class=\"number\">0</span>].toString());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                String[] stringsSort;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Object objectSort : objArraySort)&#123;</span><br><span class=\"line\">                  stringsSort=objectSort.toString().split(<span class=\"string\">&quot;,&quot;</span>);</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (stringsSort[<span class=\"number\">1</span>].equals(<span class=\"string\">&quot;asc&quot;</span>))&#123;</span><br><span class=\"line\">                    qw.orderBy(<span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>, stringsSort[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                  &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    qw.orderBy(<span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, stringsSort[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        field.setAccessible(accessible);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      log.error(e.getMessage(), e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> qw;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isBlank</span><span class=\"params\">(<span class=\"keyword\">final</span> CharSequence cs)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> strLen;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cs == <span class=\"keyword\">null</span> || (strLen = cs.length()) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strLen; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!Character.isWhitespace(cs.charAt(i))) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Field&gt; <span class=\"title\">getAllFields</span><span class=\"params\">(Class clazz, List&lt;Field&gt; fields)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clazz != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      fields.addAll(Arrays.asList(clazz.getDeclaredFields()));</span><br><span class=\"line\">      getAllFields(clazz.getSuperclass(), fields);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fields;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"ArrayList","date":"2021-11-15T08:32:10.000Z","_content":"\nArrayList基于数组的List集合, 那么从数组中删除一个元素的底层逻辑是什么样?\n\n### ArrayList.remove(index)\n```java\nList<String> al = new ArrayList<>(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"));\nString old = al.remove(0);\nSystem.out.println(old);\n\n// output:\n// a\n```\n> 注意: `Arrays.asList(...).remove(index)`会抛出`UnsupportedOperationException`.\n> Arrays.asList方法返回一个ArrayList(内部类), 是`java.util.Arrays`下的一个内部类, 对remove并没有实现逻辑\n> 通过`Arrays.asList(...)`得到的List是一个只读的集合, 也没有实现add方法. 所以这里可以通过ArrayList的构造方法新建可以增删改查的集合\n\nArrayList源码(部分):\n```java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n{\n    // ...\n    \n    /**\n     * The array buffer into which the elements of the ArrayList are stored.\n     * The capacity of the ArrayList is the length of this array buffer. Any\n     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n     * will be expanded to DEFAULT_CAPACITY when the first element is added.\n     */\n    transient Object[] elementData; // non-private to simplify nested class access\n\n    E elementData(int index) {\n        // elementData\n        return (E) elementData[index];\n    }\n\n    /**\n     * Removes the element at the specified position in this list.\n     * Shifts any subsequent elements to the left (subtracts one from their\n     * indices).\n     *\n     * @param index the index of the element to be removed\n     * @return the element that was removed from the list\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public E remove(int index) {\n        rangeCheck(index);\n\n        modCount++;\n        E oldValue = elementData(index);\n\n        // numMoved表示要移动的元素数量\n        // 如果等于0说明, 要删除的是最后一位, 不需要移动, 直接将最后一位设为null即可\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n\n        return oldValue;\n    }\n\n    // ...\n}\n```\n\nArrayList内部维护了一个数组`elementData`. remove并没有删除数组中的元素, 而是通过`System.arraycopy`方法将index后的元素向前移动一位, 把最后一位的的值设为null.\nSystem.arraycopy是一个native方法\n```java\n/**\n * 将从src数组的指定位置srcPos开始复制length长度的元素, 对应到dest数组的descPos位置依次往后替换\n * 比如, 当length为2的两个数组, srcPos=3, destPos=0\n * src: [a, b, c, d, e]\n *                ↓  ↓\n * dest:         [1, 2, 3, 4, 5]\n * output: [a, b, 3, 4, 5](dest)\n * \n * @param src     the source array.\n * @param srcPos  starting position in the source array.\n * @param dest    the destination array.\n * @param destPos starting position in the destination data.\n * @param length  the number of array elements to be copied.\n */\npublic static native void arraycopy(Object src,  int  srcPos, Object dest, int destPos, int length);\n```\n寻找native方法的实现C++源码, 下载[OpenJDK](https://github.com/openjdk/jdk/tags?after=jdk8-b114)源码, 在`jdk\\src\\share\\native`你可以找到C/C++源码\n - jdk\\src\\linux source for linux.\n - jdk\\src\\windows source for windows.\n - jdk\\src\\solaris souce for solaris.\n - jd\\src\\share common source.\n\n最后在`hotspot\\src\\share\\vm\\oops\\objArrayKlass.cpp`168行, 其中有copy_array方法, 大概思路是这样的:\n```java\nwhile(length > 0){\n    dest[destPos] = src[srcPos]\n    destPos++;\n    srcPos++;\n    length--;\n}\n```\n如果List集合对应的数组是`[a, b, c, d, e]`, 现在执行`.remove(0)`, 调用`System.arraycopy(elementData, 1, elementData, 0, 4)`后得到的`elementData`是`[b, c, d, e, e]`, 数组的长度不会发生变化. 紧接着执行`elementData[--size] = null`, `[b, c, d, e, null]`, 完成操作. 源码注释中解释到: **clear to let GC do its work**, 让GC完成接下来的工作, 此时ArrayList.size已经减1, 但是由于数组在被创建出来以后长度无法更改, 所以其对应的数组`elementData`的长度依然不变.\n\n```java\nelementData[--size] = null; // clear to let GC do its work\n```\n这样一行代码让人感觉很奇怪. 首先, 数组中的最后一个元素是由于所有位置的元素向前移动而多出来的, 这个元素的值不应该能被外界访问到; 再者, 这个元素可能会在程序中保持很长时间(因为List容器还在使用暂时无法回收), 也不应该再被使用, 设为null, 做为一个垃圾回收的标志.\n\n\n","source":"_posts/java-arraylist.md","raw":"---\ntitle: ArrayList\ndate: 2021-11-15 16:32:10\ncategories:\n- Java\n---\n\nArrayList基于数组的List集合, 那么从数组中删除一个元素的底层逻辑是什么样?\n\n### ArrayList.remove(index)\n```java\nList<String> al = new ArrayList<>(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"));\nString old = al.remove(0);\nSystem.out.println(old);\n\n// output:\n// a\n```\n> 注意: `Arrays.asList(...).remove(index)`会抛出`UnsupportedOperationException`.\n> Arrays.asList方法返回一个ArrayList(内部类), 是`java.util.Arrays`下的一个内部类, 对remove并没有实现逻辑\n> 通过`Arrays.asList(...)`得到的List是一个只读的集合, 也没有实现add方法. 所以这里可以通过ArrayList的构造方法新建可以增删改查的集合\n\nArrayList源码(部分):\n```java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n{\n    // ...\n    \n    /**\n     * The array buffer into which the elements of the ArrayList are stored.\n     * The capacity of the ArrayList is the length of this array buffer. Any\n     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n     * will be expanded to DEFAULT_CAPACITY when the first element is added.\n     */\n    transient Object[] elementData; // non-private to simplify nested class access\n\n    E elementData(int index) {\n        // elementData\n        return (E) elementData[index];\n    }\n\n    /**\n     * Removes the element at the specified position in this list.\n     * Shifts any subsequent elements to the left (subtracts one from their\n     * indices).\n     *\n     * @param index the index of the element to be removed\n     * @return the element that was removed from the list\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public E remove(int index) {\n        rangeCheck(index);\n\n        modCount++;\n        E oldValue = elementData(index);\n\n        // numMoved表示要移动的元素数量\n        // 如果等于0说明, 要删除的是最后一位, 不需要移动, 直接将最后一位设为null即可\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n\n        return oldValue;\n    }\n\n    // ...\n}\n```\n\nArrayList内部维护了一个数组`elementData`. remove并没有删除数组中的元素, 而是通过`System.arraycopy`方法将index后的元素向前移动一位, 把最后一位的的值设为null.\nSystem.arraycopy是一个native方法\n```java\n/**\n * 将从src数组的指定位置srcPos开始复制length长度的元素, 对应到dest数组的descPos位置依次往后替换\n * 比如, 当length为2的两个数组, srcPos=3, destPos=0\n * src: [a, b, c, d, e]\n *                ↓  ↓\n * dest:         [1, 2, 3, 4, 5]\n * output: [a, b, 3, 4, 5](dest)\n * \n * @param src     the source array.\n * @param srcPos  starting position in the source array.\n * @param dest    the destination array.\n * @param destPos starting position in the destination data.\n * @param length  the number of array elements to be copied.\n */\npublic static native void arraycopy(Object src,  int  srcPos, Object dest, int destPos, int length);\n```\n寻找native方法的实现C++源码, 下载[OpenJDK](https://github.com/openjdk/jdk/tags?after=jdk8-b114)源码, 在`jdk\\src\\share\\native`你可以找到C/C++源码\n - jdk\\src\\linux source for linux.\n - jdk\\src\\windows source for windows.\n - jdk\\src\\solaris souce for solaris.\n - jd\\src\\share common source.\n\n最后在`hotspot\\src\\share\\vm\\oops\\objArrayKlass.cpp`168行, 其中有copy_array方法, 大概思路是这样的:\n```java\nwhile(length > 0){\n    dest[destPos] = src[srcPos]\n    destPos++;\n    srcPos++;\n    length--;\n}\n```\n如果List集合对应的数组是`[a, b, c, d, e]`, 现在执行`.remove(0)`, 调用`System.arraycopy(elementData, 1, elementData, 0, 4)`后得到的`elementData`是`[b, c, d, e, e]`, 数组的长度不会发生变化. 紧接着执行`elementData[--size] = null`, `[b, c, d, e, null]`, 完成操作. 源码注释中解释到: **clear to let GC do its work**, 让GC完成接下来的工作, 此时ArrayList.size已经减1, 但是由于数组在被创建出来以后长度无法更改, 所以其对应的数组`elementData`的长度依然不变.\n\n```java\nelementData[--size] = null; // clear to let GC do its work\n```\n这样一行代码让人感觉很奇怪. 首先, 数组中的最后一个元素是由于所有位置的元素向前移动而多出来的, 这个元素的值不应该能被外界访问到; 再者, 这个元素可能会在程序中保持很长时间(因为List容器还在使用暂时无法回收), 也不应该再被使用, 设为null, 做为一个垃圾回收的标志.\n\n\n","slug":"java-arraylist","published":1,"updated":"2021-12-30T02:47:28.293Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxsdzpyb0008xotgekce7p56","content":"<p>ArrayList基于数组的List集合, 那么从数组中删除一个元素的底层逻辑是什么样?</p>\n<h3 id=\"ArrayList-remove-index\"><a href=\"#ArrayList-remove-index\" class=\"headerlink\" title=\"ArrayList.remove(index)\"></a>ArrayList.remove(index)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; al = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;d&quot;</span>, <span class=\"string\">&quot;e&quot;</span>));</span><br><span class=\"line\">String old = al.remove(<span class=\"number\">0</span>);</span><br><span class=\"line\">System.out.println(old);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// a</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意: <code>Arrays.asList(...).remove(index)</code>会抛出<code>UnsupportedOperationException</code>.<br>Arrays.asList方法返回一个ArrayList(内部类), 是<code>java.util.Arrays</code>下的一个内部类, 对remove并没有实现逻辑<br>通过<code>Arrays.asList(...)</code>得到的List是一个只读的集合, 也没有实现add方法. 所以这里可以通过ArrayList的构造方法新建可以增删改查的集合</p>\n</blockquote>\n<p>ArrayList源码(部分):</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">RandomAccess</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class=\"line\"><span class=\"comment\">     * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class=\"line\"><span class=\"comment\">     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class=\"line\"><span class=\"comment\">     * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Object[] elementData; <span class=\"comment\">// non-private to simplify nested class access</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">E <span class=\"title\">elementData</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// elementData</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (E) elementData[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Removes the element at the specified position in this list.</span></span><br><span class=\"line\"><span class=\"comment\">     * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class=\"line\"><span class=\"comment\">     * indices).</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> index the index of the element to be removed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> the element that was removed from the list</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> IndexOutOfBoundsException &#123;<span class=\"doctag\">@inheritDoc</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        E oldValue = elementData(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// numMoved表示要移动的元素数量</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果等于0说明, 要删除的是最后一位, 不需要移动, 直接将最后一位设为null即可</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                             numMoved);</span><br><span class=\"line\">        elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ArrayList内部维护了一个数组<code>elementData</code>. remove并没有删除数组中的元素, 而是通过<code>System.arraycopy</code>方法将index后的元素向前移动一位, 把最后一位的的值设为null.<br>System.arraycopy是一个native方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将从src数组的指定位置srcPos开始复制length长度的元素, 对应到dest数组的descPos位置依次往后替换</span></span><br><span class=\"line\"><span class=\"comment\"> * 比如, 当length为2的两个数组, srcPos=3, destPos=0</span></span><br><span class=\"line\"><span class=\"comment\"> * src: [a, b, c, d, e]</span></span><br><span class=\"line\"><span class=\"comment\"> *                ↓  ↓</span></span><br><span class=\"line\"><span class=\"comment\"> * dest:         [1, 2, 3, 4, 5]</span></span><br><span class=\"line\"><span class=\"comment\"> * output: [a, b, 3, 4, 5](dest)</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> src     the source array.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> srcPos  starting position in the source array.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> dest    the destination array.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> destPos starting position in the destination data.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> length  the number of array elements to be copied.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">arraycopy</span><span class=\"params\">(Object src,  <span class=\"keyword\">int</span>  srcPos, Object dest, <span class=\"keyword\">int</span> destPos, <span class=\"keyword\">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>寻找native方法的实现C++源码, 下载<a href=\"https://github.com/openjdk/jdk/tags?after=jdk8-b114\">OpenJDK</a>源码, 在<code>jdk\\src\\share\\native</code>你可以找到C/C++源码</p>\n<ul>\n<li>jdk\\src\\linux source for linux.</li>\n<li>jdk\\src\\windows source for windows.</li>\n<li>jdk\\src\\solaris souce for solaris.</li>\n<li>jd\\src\\share common source.</li>\n</ul>\n<p>最后在<code>hotspot\\src\\share\\vm\\oops\\objArrayKlass.cpp</code>168行, 其中有copy_array方法, 大概思路是这样的:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(length &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    dest[destPos] = src[srcPos]</span><br><span class=\"line\">    destPos++;</span><br><span class=\"line\">    srcPos++;</span><br><span class=\"line\">    length--;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果List集合对应的数组是<code>[a, b, c, d, e]</code>, 现在执行<code>.remove(0)</code>, 调用<code>System.arraycopy(elementData, 1, elementData, 0, 4)</code>后得到的<code>elementData</code>是<code>[b, c, d, e, e]</code>, 数组的长度不会发生变化. 紧接着执行<code>elementData[--size] = null</code>, <code>[b, c, d, e, null]</code>, 完成操作. 源码注释中解释到: <strong>clear to let GC do its work</strong>, 让GC完成接下来的工作, 此时ArrayList.size已经减1, 但是由于数组在被创建出来以后长度无法更改, 所以其对应的数组<code>elementData</code>的长度依然不变.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br></pre></td></tr></table></figure>\n<p>这样一行代码让人感觉很奇怪. 首先, 数组中的最后一个元素是由于所有位置的元素向前移动而多出来的, 这个元素的值不应该能被外界访问到; 再者, 这个元素可能会在程序中保持很长时间(因为List容器还在使用暂时无法回收), 也不应该再被使用, 设为null, 做为一个垃圾回收的标志.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>ArrayList基于数组的List集合, 那么从数组中删除一个元素的底层逻辑是什么样?</p>\n<h3 id=\"ArrayList-remove-index\"><a href=\"#ArrayList-remove-index\" class=\"headerlink\" title=\"ArrayList.remove(index)\"></a>ArrayList.remove(index)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; al = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;d&quot;</span>, <span class=\"string\">&quot;e&quot;</span>));</span><br><span class=\"line\">String old = al.remove(<span class=\"number\">0</span>);</span><br><span class=\"line\">System.out.println(old);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// a</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意: <code>Arrays.asList(...).remove(index)</code>会抛出<code>UnsupportedOperationException</code>.<br>Arrays.asList方法返回一个ArrayList(内部类), 是<code>java.util.Arrays</code>下的一个内部类, 对remove并没有实现逻辑<br>通过<code>Arrays.asList(...)</code>得到的List是一个只读的集合, 也没有实现add方法. 所以这里可以通过ArrayList的构造方法新建可以增删改查的集合</p>\n</blockquote>\n<p>ArrayList源码(部分):</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">RandomAccess</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class=\"line\"><span class=\"comment\">     * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class=\"line\"><span class=\"comment\">     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class=\"line\"><span class=\"comment\">     * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Object[] elementData; <span class=\"comment\">// non-private to simplify nested class access</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">E <span class=\"title\">elementData</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// elementData</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (E) elementData[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Removes the element at the specified position in this list.</span></span><br><span class=\"line\"><span class=\"comment\">     * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class=\"line\"><span class=\"comment\">     * indices).</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> index the index of the element to be removed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> the element that was removed from the list</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> IndexOutOfBoundsException &#123;<span class=\"doctag\">@inheritDoc</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        E oldValue = elementData(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// numMoved表示要移动的元素数量</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果等于0说明, 要删除的是最后一位, 不需要移动, 直接将最后一位设为null即可</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                             numMoved);</span><br><span class=\"line\">        elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ArrayList内部维护了一个数组<code>elementData</code>. remove并没有删除数组中的元素, 而是通过<code>System.arraycopy</code>方法将index后的元素向前移动一位, 把最后一位的的值设为null.<br>System.arraycopy是一个native方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将从src数组的指定位置srcPos开始复制length长度的元素, 对应到dest数组的descPos位置依次往后替换</span></span><br><span class=\"line\"><span class=\"comment\"> * 比如, 当length为2的两个数组, srcPos=3, destPos=0</span></span><br><span class=\"line\"><span class=\"comment\"> * src: [a, b, c, d, e]</span></span><br><span class=\"line\"><span class=\"comment\"> *                ↓  ↓</span></span><br><span class=\"line\"><span class=\"comment\"> * dest:         [1, 2, 3, 4, 5]</span></span><br><span class=\"line\"><span class=\"comment\"> * output: [a, b, 3, 4, 5](dest)</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> src     the source array.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> srcPos  starting position in the source array.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> dest    the destination array.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> destPos starting position in the destination data.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> length  the number of array elements to be copied.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">arraycopy</span><span class=\"params\">(Object src,  <span class=\"keyword\">int</span>  srcPos, Object dest, <span class=\"keyword\">int</span> destPos, <span class=\"keyword\">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>寻找native方法的实现C++源码, 下载<a href=\"https://github.com/openjdk/jdk/tags?after=jdk8-b114\">OpenJDK</a>源码, 在<code>jdk\\src\\share\\native</code>你可以找到C/C++源码</p>\n<ul>\n<li>jdk\\src\\linux source for linux.</li>\n<li>jdk\\src\\windows source for windows.</li>\n<li>jdk\\src\\solaris souce for solaris.</li>\n<li>jd\\src\\share common source.</li>\n</ul>\n<p>最后在<code>hotspot\\src\\share\\vm\\oops\\objArrayKlass.cpp</code>168行, 其中有copy_array方法, 大概思路是这样的:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(length &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    dest[destPos] = src[srcPos]</span><br><span class=\"line\">    destPos++;</span><br><span class=\"line\">    srcPos++;</span><br><span class=\"line\">    length--;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果List集合对应的数组是<code>[a, b, c, d, e]</code>, 现在执行<code>.remove(0)</code>, 调用<code>System.arraycopy(elementData, 1, elementData, 0, 4)</code>后得到的<code>elementData</code>是<code>[b, c, d, e, e]</code>, 数组的长度不会发生变化. 紧接着执行<code>elementData[--size] = null</code>, <code>[b, c, d, e, null]</code>, 完成操作. 源码注释中解释到: <strong>clear to let GC do its work</strong>, 让GC完成接下来的工作, 此时ArrayList.size已经减1, 但是由于数组在被创建出来以后长度无法更改, 所以其对应的数组<code>elementData</code>的长度依然不变.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br></pre></td></tr></table></figure>\n<p>这样一行代码让人感觉很奇怪. 首先, 数组中的最后一个元素是由于所有位置的元素向前移动而多出来的, 这个元素的值不应该能被外界访问到; 再者, 这个元素可能会在程序中保持很长时间(因为List容器还在使用暂时无法回收), 也不应该再被使用, 设为null, 做为一个垃圾回收的标志.</p>\n"},{"title":"责任链模式","date":"2021-11-02T12:31:25.000Z","_content":"\n这篇博客需和另一篇将Spring AOP的相结合.\n\n# 责任链模式\n用这样一段OnJava8的原文来描述责任链模式\n\n{% blockquote Bruce Eckel, OnJava8 %}\nIn recursion, one method calls itself over and over until it reaches a termination condition; with **Chain of Responsibility**, a method calls the same base-class method (with a different implementation) which calls another implementation of the base-class method, etc., until it reaches a termination condition.\n{% endblockquote %}\n\n从中体会到几点: Java中使用递归调用来执行整个链条, 链条是一个List, 这个List中保存着每个子类重写父类的同一个方法, 但是它们实现逻辑不同. \n\n\n在Spring AOP中, 对于某个Joinpoint. 要加入一个横切逻辑, 需要定义一个类实现MethodInterceptor, 重写其invoke方法, 在invoke方法体中添加横切逻辑. 其方法体中必须调用`invocation.proceed()`方法, 不然会造成\"短路\". \n\n有多个MethodInterceptor实现的时候, 要按照逐个执行它们的invoke方法(横切逻辑), 这些匹配到的interceptor, 最终集中到了`ReflectiveMethodInvocation.interceptorsAndDynamicMethodMatchers`这个List中, 将在`proceed()`方法中执行. 这里用到了递归, 整体是\"责任链模式\"\n\n附上ReflectiveMethodInvocation源码来解释\n\n```java\n\n/**\n * Spring's implementation of the AOP Alliance\n * {@link org.aopalliance.intercept.MethodInvocation} interface,\n * implementing the extended\n * {@link org.springframework.aop.ProxyMethodInvocation} interface.\n *\n * <p>Invokes the target object using reflection. Subclasses can override the\n * {@link #invokeJoinpoint()} method to change this behavior, so this is also\n * a useful base class for more specialized MethodInvocation implementations.\n *\n * <p>It is possible to clone an invocation, to invoke {@link #proceed()}\n * repeatedly (once per clone), using the {@link #invocableClone()} method.\n * It is also possible to attach custom attributes to the invocation,\n * using the {@link #setUserAttribute} / {@link #getUserAttribute} methods.\n *\n * <p><b>NOTE:</b> This class is considered internal and should not be\n * directly accessed. The sole reason for it being public is compatibility\n * with existing framework integrations (e.g. Pitchfork). For any other\n * purposes, use the {@link ProxyMethodInvocation} interface instead.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Adrian Colyer\n * @see #invokeJoinpoint\n * @see #proceed\n * @see #invocableClone\n * @see #setUserAttribute\n * @see #getUserAttribute\n */\npublic class ReflectiveMethodInvocation implements ProxyMethodInvocation, Cloneable {\n\n\tprotected final Object proxy;\n\n\t@Nullable\n\tprotected final Object target;\n\n\tprotected final Method method;\n\n\tprotected Object[] arguments = new Object[0];\n\n\t@Nullable\n\tprivate final Class<?> targetClass;\n\n\t/**\n\t * Lazily initialized map of user-specific attributes for this invocation.\n\t */\n\t@Nullable\n\tprivate Map<String, Object> userAttributes;\n\n\t/**\n\t * List of MethodInterceptor and InterceptorAndDynamicMethodMatcher\n\t * that need dynamic checks.\n\t */\n\tprotected final List<?> interceptorsAndDynamicMethodMatchers;\n\n\t/**\n\t * Index from 0 of the current interceptor we're invoking.\n\t * -1 until we invoke: then the current interceptor.\n\t */\n\tprivate int currentInterceptorIndex = -1;\n\n\n\t/**\n\t * Construct a new ReflectiveMethodInvocation with the given arguments.\n\t * @param proxy the proxy object that the invocation was made on\n\t * @param target the target object to invoke\n\t * @param method the method to invoke\n\t * @param arguments the arguments to invoke the method with\n\t * @param targetClass the target class, for MethodMatcher invocations\n\t * @param interceptorsAndDynamicMethodMatchers interceptors that should be applied,\n\t * along with any InterceptorAndDynamicMethodMatchers that need evaluation at runtime.\n\t * MethodMatchers included in this struct must already have been found to have matched\n\t * as far as was possibly statically. Passing an array might be about 10% faster,\n\t * but would complicate the code. And it would work only for static pointcuts.\n\t */\n\tprotected ReflectiveMethodInvocation(\n\tprotected ReflectiveMethodInvocation(\n\t\t\tObject proxy, @Nullable Object target, Method method, @Nullable Object[] arguments,\n\t\t\t@Nullable Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers) {\n\n\t\tthis.proxy = proxy;\n\t\tthis.target = target;\n\t\tthis.targetClass = targetClass;\n\t\t// 找到桥接方法，作为最后执行的方法。至于什么是桥接方法，自行百度关键字：bridge method\n\t\t// 桥接方法是 JDK 1.5 引入泛型后，为了使Java的泛型方法生成的字节码和 1.5 版本前的字节码相兼容，由编译器自动生成的方法（子类实现父类的泛型方法时会生成桥接方法）\n\t\tthis.method = BridgeMethodResolver.findBridgedMethod(method);\n\t\t// 对参数进行适配\n\t\tthis.arguments = AopProxyUtils.adaptArgumentsIfNecessary(method, arguments);\n\t\tthis.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers;\n\t}\n\n\t@Override\n\tpublic final Object getProxy() {\n\t\treturn this.proxy;\n\t}\n\t@Override\n\t@Nullable\n\tpublic final Object getThis() {\n\t\treturn this.target;\n\t}\n\t// 此处：getStaticPart返回的就是当前得method\n\t@Override\n\tpublic final AccessibleObject getStaticPart() {\n\t\treturn this.method;\n\t}\n\t// 注意：这里返回的可能是桥接方法哦\n\t@Override\n\tpublic final Method getMethod() {\n\t\treturn this.method;\n\t}\n\t@Override\n\tpublic final Object[] getArguments() {\n\t\treturn this.arguments;\n\t}\n\t@Override\n\tpublic void setArguments(Object... arguments) {\n\t\tthis.arguments = arguments;\n\t}\n\n    // 核心在这里\n    @Override\n\t@Nullable\n\tpublic Object proceed() throws Throwable {\n\t\t//\tWe start with an index of -1 and increment early.\n\t\tif (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {\n            // 这个方法相当于调用了目标方法\n\t\t\treturn invokeJoinpoint();\n\t\t}\n\n        // 获取集合中的 MethodInterceptor（并且currentInterceptorIndex + 1）\n\t\tObject interceptorOrInterceptionAdvice =\n\t\t\t\tthis.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);\n\t\tif (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {\n\t\t\t// Evaluate dynamic method matcher here: static part will already have\n\t\t\t// been evaluated and found to match.\n\t\t\tInterceptorAndDynamicMethodMatcher dm =\n\t\t\t\t\t(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;\n\t\t\tClass<?> targetClass = (this.targetClass != null ? this.targetClass : this.method.getDeclaringClass());\n\n\t\t\tif (dm.methodMatcher.matches(this.method, targetClass, this.arguments)) {\n                // 执行封装了横切逻辑的invoke方法\n                // 所以在interceptor.invoke方法内部, 必须调用invocation.proceed(), 才能再次恢复递归; 否则, 会发生\"短路\". 就无法执行上面的invokeJoinpoint();\n\t\t\t\treturn dm.interceptor.invoke(this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Dynamic matching failed.\n\t\t\t\t// Skip this interceptor and invoke the next in the chain.\n\t\t\t\treturn proceed();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// It's an interceptor, so we just invoke it: The pointcut will have\n\t\t\t// been evaluated statically before this object was constructed.\n\t\t\treturn ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);\n\t\t}\n\t}\n\n    \n\t/**\n\t * Invoke the joinpoint using reflection.\n\t * Subclasses can override this to use custom invocation.\n\t * @return the return value of the joinpoint\n\t * @throws Throwable if invoking the joinpoint resulted in an exception\n\t */\n\t@Nullable\n\tprotected Object invokeJoinpoint() throws Throwable {\n        // this.target指的就是被代理的目标对象\n        // 最终invokeJoinpointUsingReflection内部执行的就是method.invoke(arguments);也就是说执行了目标对象的Joinpoint\n\t\treturn AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments);\n\t}\n\n    // ...    \n\n}\n```\n\n重要的解释信息都在代码的注释中, 这里理清楚它们继承的关系, 可以看出它们是AOP Joinpoint概念实现\n{% plantuml %}\nJoinpoint <|-- Invocation\ninterface Joinpoint {}\ninterface Invocation {}\n\nInvocation <|-- MethodInvocation\ninterface MethodInvocation {}\n\nMethodInvocation <|-- ProxyMethodInvocation\ninterface ProxyMethodInvocation {}\n\nProxyMethodInvocation <|.. ReflectiveMethodInvocation\n{% endplantuml %}\n\n```java\npackage org.aopalliance.intercept;\n\nimport java.lang.reflect.AccessibleObject;\n\n/**\n * This interface represents a generic runtime joinpoint (in the AOP\n * terminology).\n *\n * <p>A runtime joinpoint is an <i>event</i> that occurs on a static\n * joinpoint (i.e. a location in a the program). For instance, an\n * invocation is the runtime joinpoint on a method (static joinpoint).\n * The static part of a given joinpoint can be generically retrieved\n * using the {@link #getStaticPart()} method.\n *\n * <p>In the context of an interception framework, a runtime joinpoint\n * is then the reification of an access to an accessible object (a\n * method, a constructor, a field), i.e. the static part of the\n * joinpoint. It is passed to the interceptors that are installed on\n * the static joinpoint.\n *\n * @author Rod Johnson\n * @see Interceptor\n */\npublic interface Joinpoint {\n\n\t/**\n\t * Proceed to the next interceptor in the chain.\n\t * <p>The implementation and the semantics of this method depends\n\t * on the actual joinpoint type (see the children interfaces).\n\t * @return see the children interfaces' proceed definition\n\t * @throws Throwable if the joinpoint throws an exception\n\t */\n\tObject proceed() throws Throwable;\n\n\t/**\n\t * Return the object that holds the current joinpoint's static part.\n\t * <p>For instance, the target object for an invocation.\n\t * @return the object (can be null if the accessible object is static)\n\t */\n\tObject getThis();\n\n\t/**\n\t * Return the static part of this joinpoint.\n\t * <p>The static part is an accessible object on which a chain of\n\t * interceptors are installed.\n\t */\n\tAccessibleObject getStaticPart();\n\n}\n```\n\n","source":"_posts/java-chain-of-responsibility.md","raw":"---\ntitle: 责任链模式\ndate: 2021-11-02 20:31:25\ncategories:\n- Pattern\n---\n\n这篇博客需和另一篇将Spring AOP的相结合.\n\n# 责任链模式\n用这样一段OnJava8的原文来描述责任链模式\n\n{% blockquote Bruce Eckel, OnJava8 %}\nIn recursion, one method calls itself over and over until it reaches a termination condition; with **Chain of Responsibility**, a method calls the same base-class method (with a different implementation) which calls another implementation of the base-class method, etc., until it reaches a termination condition.\n{% endblockquote %}\n\n从中体会到几点: Java中使用递归调用来执行整个链条, 链条是一个List, 这个List中保存着每个子类重写父类的同一个方法, 但是它们实现逻辑不同. \n\n\n在Spring AOP中, 对于某个Joinpoint. 要加入一个横切逻辑, 需要定义一个类实现MethodInterceptor, 重写其invoke方法, 在invoke方法体中添加横切逻辑. 其方法体中必须调用`invocation.proceed()`方法, 不然会造成\"短路\". \n\n有多个MethodInterceptor实现的时候, 要按照逐个执行它们的invoke方法(横切逻辑), 这些匹配到的interceptor, 最终集中到了`ReflectiveMethodInvocation.interceptorsAndDynamicMethodMatchers`这个List中, 将在`proceed()`方法中执行. 这里用到了递归, 整体是\"责任链模式\"\n\n附上ReflectiveMethodInvocation源码来解释\n\n```java\n\n/**\n * Spring's implementation of the AOP Alliance\n * {@link org.aopalliance.intercept.MethodInvocation} interface,\n * implementing the extended\n * {@link org.springframework.aop.ProxyMethodInvocation} interface.\n *\n * <p>Invokes the target object using reflection. Subclasses can override the\n * {@link #invokeJoinpoint()} method to change this behavior, so this is also\n * a useful base class for more specialized MethodInvocation implementations.\n *\n * <p>It is possible to clone an invocation, to invoke {@link #proceed()}\n * repeatedly (once per clone), using the {@link #invocableClone()} method.\n * It is also possible to attach custom attributes to the invocation,\n * using the {@link #setUserAttribute} / {@link #getUserAttribute} methods.\n *\n * <p><b>NOTE:</b> This class is considered internal and should not be\n * directly accessed. The sole reason for it being public is compatibility\n * with existing framework integrations (e.g. Pitchfork). For any other\n * purposes, use the {@link ProxyMethodInvocation} interface instead.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Adrian Colyer\n * @see #invokeJoinpoint\n * @see #proceed\n * @see #invocableClone\n * @see #setUserAttribute\n * @see #getUserAttribute\n */\npublic class ReflectiveMethodInvocation implements ProxyMethodInvocation, Cloneable {\n\n\tprotected final Object proxy;\n\n\t@Nullable\n\tprotected final Object target;\n\n\tprotected final Method method;\n\n\tprotected Object[] arguments = new Object[0];\n\n\t@Nullable\n\tprivate final Class<?> targetClass;\n\n\t/**\n\t * Lazily initialized map of user-specific attributes for this invocation.\n\t */\n\t@Nullable\n\tprivate Map<String, Object> userAttributes;\n\n\t/**\n\t * List of MethodInterceptor and InterceptorAndDynamicMethodMatcher\n\t * that need dynamic checks.\n\t */\n\tprotected final List<?> interceptorsAndDynamicMethodMatchers;\n\n\t/**\n\t * Index from 0 of the current interceptor we're invoking.\n\t * -1 until we invoke: then the current interceptor.\n\t */\n\tprivate int currentInterceptorIndex = -1;\n\n\n\t/**\n\t * Construct a new ReflectiveMethodInvocation with the given arguments.\n\t * @param proxy the proxy object that the invocation was made on\n\t * @param target the target object to invoke\n\t * @param method the method to invoke\n\t * @param arguments the arguments to invoke the method with\n\t * @param targetClass the target class, for MethodMatcher invocations\n\t * @param interceptorsAndDynamicMethodMatchers interceptors that should be applied,\n\t * along with any InterceptorAndDynamicMethodMatchers that need evaluation at runtime.\n\t * MethodMatchers included in this struct must already have been found to have matched\n\t * as far as was possibly statically. Passing an array might be about 10% faster,\n\t * but would complicate the code. And it would work only for static pointcuts.\n\t */\n\tprotected ReflectiveMethodInvocation(\n\tprotected ReflectiveMethodInvocation(\n\t\t\tObject proxy, @Nullable Object target, Method method, @Nullable Object[] arguments,\n\t\t\t@Nullable Class<?> targetClass, List<Object> interceptorsAndDynamicMethodMatchers) {\n\n\t\tthis.proxy = proxy;\n\t\tthis.target = target;\n\t\tthis.targetClass = targetClass;\n\t\t// 找到桥接方法，作为最后执行的方法。至于什么是桥接方法，自行百度关键字：bridge method\n\t\t// 桥接方法是 JDK 1.5 引入泛型后，为了使Java的泛型方法生成的字节码和 1.5 版本前的字节码相兼容，由编译器自动生成的方法（子类实现父类的泛型方法时会生成桥接方法）\n\t\tthis.method = BridgeMethodResolver.findBridgedMethod(method);\n\t\t// 对参数进行适配\n\t\tthis.arguments = AopProxyUtils.adaptArgumentsIfNecessary(method, arguments);\n\t\tthis.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers;\n\t}\n\n\t@Override\n\tpublic final Object getProxy() {\n\t\treturn this.proxy;\n\t}\n\t@Override\n\t@Nullable\n\tpublic final Object getThis() {\n\t\treturn this.target;\n\t}\n\t// 此处：getStaticPart返回的就是当前得method\n\t@Override\n\tpublic final AccessibleObject getStaticPart() {\n\t\treturn this.method;\n\t}\n\t// 注意：这里返回的可能是桥接方法哦\n\t@Override\n\tpublic final Method getMethod() {\n\t\treturn this.method;\n\t}\n\t@Override\n\tpublic final Object[] getArguments() {\n\t\treturn this.arguments;\n\t}\n\t@Override\n\tpublic void setArguments(Object... arguments) {\n\t\tthis.arguments = arguments;\n\t}\n\n    // 核心在这里\n    @Override\n\t@Nullable\n\tpublic Object proceed() throws Throwable {\n\t\t//\tWe start with an index of -1 and increment early.\n\t\tif (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {\n            // 这个方法相当于调用了目标方法\n\t\t\treturn invokeJoinpoint();\n\t\t}\n\n        // 获取集合中的 MethodInterceptor（并且currentInterceptorIndex + 1）\n\t\tObject interceptorOrInterceptionAdvice =\n\t\t\t\tthis.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);\n\t\tif (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {\n\t\t\t// Evaluate dynamic method matcher here: static part will already have\n\t\t\t// been evaluated and found to match.\n\t\t\tInterceptorAndDynamicMethodMatcher dm =\n\t\t\t\t\t(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;\n\t\t\tClass<?> targetClass = (this.targetClass != null ? this.targetClass : this.method.getDeclaringClass());\n\n\t\t\tif (dm.methodMatcher.matches(this.method, targetClass, this.arguments)) {\n                // 执行封装了横切逻辑的invoke方法\n                // 所以在interceptor.invoke方法内部, 必须调用invocation.proceed(), 才能再次恢复递归; 否则, 会发生\"短路\". 就无法执行上面的invokeJoinpoint();\n\t\t\t\treturn dm.interceptor.invoke(this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Dynamic matching failed.\n\t\t\t\t// Skip this interceptor and invoke the next in the chain.\n\t\t\t\treturn proceed();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// It's an interceptor, so we just invoke it: The pointcut will have\n\t\t\t// been evaluated statically before this object was constructed.\n\t\t\treturn ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);\n\t\t}\n\t}\n\n    \n\t/**\n\t * Invoke the joinpoint using reflection.\n\t * Subclasses can override this to use custom invocation.\n\t * @return the return value of the joinpoint\n\t * @throws Throwable if invoking the joinpoint resulted in an exception\n\t */\n\t@Nullable\n\tprotected Object invokeJoinpoint() throws Throwable {\n        // this.target指的就是被代理的目标对象\n        // 最终invokeJoinpointUsingReflection内部执行的就是method.invoke(arguments);也就是说执行了目标对象的Joinpoint\n\t\treturn AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments);\n\t}\n\n    // ...    \n\n}\n```\n\n重要的解释信息都在代码的注释中, 这里理清楚它们继承的关系, 可以看出它们是AOP Joinpoint概念实现\n{% plantuml %}\nJoinpoint <|-- Invocation\ninterface Joinpoint {}\ninterface Invocation {}\n\nInvocation <|-- MethodInvocation\ninterface MethodInvocation {}\n\nMethodInvocation <|-- ProxyMethodInvocation\ninterface ProxyMethodInvocation {}\n\nProxyMethodInvocation <|.. ReflectiveMethodInvocation\n{% endplantuml %}\n\n```java\npackage org.aopalliance.intercept;\n\nimport java.lang.reflect.AccessibleObject;\n\n/**\n * This interface represents a generic runtime joinpoint (in the AOP\n * terminology).\n *\n * <p>A runtime joinpoint is an <i>event</i> that occurs on a static\n * joinpoint (i.e. a location in a the program). For instance, an\n * invocation is the runtime joinpoint on a method (static joinpoint).\n * The static part of a given joinpoint can be generically retrieved\n * using the {@link #getStaticPart()} method.\n *\n * <p>In the context of an interception framework, a runtime joinpoint\n * is then the reification of an access to an accessible object (a\n * method, a constructor, a field), i.e. the static part of the\n * joinpoint. It is passed to the interceptors that are installed on\n * the static joinpoint.\n *\n * @author Rod Johnson\n * @see Interceptor\n */\npublic interface Joinpoint {\n\n\t/**\n\t * Proceed to the next interceptor in the chain.\n\t * <p>The implementation and the semantics of this method depends\n\t * on the actual joinpoint type (see the children interfaces).\n\t * @return see the children interfaces' proceed definition\n\t * @throws Throwable if the joinpoint throws an exception\n\t */\n\tObject proceed() throws Throwable;\n\n\t/**\n\t * Return the object that holds the current joinpoint's static part.\n\t * <p>For instance, the target object for an invocation.\n\t * @return the object (can be null if the accessible object is static)\n\t */\n\tObject getThis();\n\n\t/**\n\t * Return the static part of this joinpoint.\n\t * <p>The static part is an accessible object on which a chain of\n\t * interceptors are installed.\n\t */\n\tAccessibleObject getStaticPart();\n\n}\n```\n\n","slug":"java-chain-of-responsibility","published":1,"updated":"2021-12-30T02:47:48.767Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxsdzpye000axotg528s5jom","content":"<p>这篇博客需和另一篇将Spring AOP的相结合.</p>\n<h1 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h1><p>用这样一段OnJava8的原文来描述责任链模式</p>\n<blockquote><p>In recursion, one method calls itself over and over until it reaches a termination condition; with <strong>Chain of Responsibility</strong>, a method calls the same base-class method (with a different implementation) which calls another implementation of the base-class method, etc., until it reaches a termination condition.</p>\n<footer><strong>Bruce Eckel</strong><cite>OnJava8</cite></footer></blockquote>\n\n<p>从中体会到几点: Java中使用递归调用来执行整个链条, 链条是一个List, 这个List中保存着每个子类重写父类的同一个方法, 但是它们实现逻辑不同. </p>\n<p>在Spring AOP中, 对于某个Joinpoint. 要加入一个横切逻辑, 需要定义一个类实现MethodInterceptor, 重写其invoke方法, 在invoke方法体中添加横切逻辑. 其方法体中必须调用<code>invocation.proceed()</code>方法, 不然会造成”短路”. </p>\n<p>有多个MethodInterceptor实现的时候, 要按照逐个执行它们的invoke方法(横切逻辑), 这些匹配到的interceptor, 最终集中到了<code>ReflectiveMethodInvocation.interceptorsAndDynamicMethodMatchers</code>这个List中, 将在<code>proceed()</code>方法中执行. 这里用到了递归, 整体是”责任链模式”</p>\n<p>附上ReflectiveMethodInvocation源码来解释</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Spring&#x27;s implementation of the AOP Alliance</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> org.aopalliance.intercept.MethodInvocation&#125; interface,</span></span><br><span class=\"line\"><span class=\"comment\"> * implementing the extended</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> org.springframework.aop.ProxyMethodInvocation&#125; interface.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;Invokes the target object using reflection. Subclasses can override the</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #invokeJoinpoint()&#125; method to change this behavior, so this is also</span></span><br><span class=\"line\"><span class=\"comment\"> * a useful base class for more specialized MethodInvocation implementations.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;It is possible to clone an invocation, to invoke &#123;<span class=\"doctag\">@link</span> #proceed()&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * repeatedly (once per clone), using the &#123;<span class=\"doctag\">@link</span> #invocableClone()&#125; method.</span></span><br><span class=\"line\"><span class=\"comment\"> * It is also possible to attach custom attributes to the invocation,</span></span><br><span class=\"line\"><span class=\"comment\"> * using the &#123;<span class=\"doctag\">@link</span> #setUserAttribute&#125; / &#123;<span class=\"doctag\">@link</span> #getUserAttribute&#125; methods.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;&lt;b&gt;<span class=\"doctag\">NOTE:</span>&lt;/b&gt; This class is considered internal and should not be</span></span><br><span class=\"line\"><span class=\"comment\"> * directly accessed. The sole reason for it being public is compatibility</span></span><br><span class=\"line\"><span class=\"comment\"> * with existing framework integrations (e.g. Pitchfork). For any other</span></span><br><span class=\"line\"><span class=\"comment\"> * purposes, use the &#123;<span class=\"doctag\">@link</span> ProxyMethodInvocation&#125; interface instead.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Rod Johnson</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Juergen Hoeller</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Adrian Colyer</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #invokeJoinpoint</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #proceed</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #invocableClone</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #setUserAttribute</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #getUserAttribute</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReflectiveMethodInvocation</span> <span class=\"keyword\">implements</span> <span class=\"title\">ProxyMethodInvocation</span>, <span class=\"title\">Cloneable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> Object proxy;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> Method method;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> Object[] arguments = <span class=\"keyword\">new</span> Object[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Class&lt;?&gt; targetClass;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Lazily initialized map of user-specific attributes for this invocation.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Map&lt;String, Object&gt; userAttributes;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * List of MethodInterceptor and InterceptorAndDynamicMethodMatcher</span></span><br><span class=\"line\"><span class=\"comment\">\t * that need dynamic checks.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> List&lt;?&gt; interceptorsAndDynamicMethodMatchers;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Index from 0 of the current interceptor we&#x27;re invoking.</span></span><br><span class=\"line\"><span class=\"comment\">\t * -1 until we invoke: then the current interceptor.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> currentInterceptorIndex = -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Construct a new ReflectiveMethodInvocation with the given arguments.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> proxy the proxy object that the invocation was made on</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> target the target object to invoke</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> method the method to invoke</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> arguments the arguments to invoke the method with</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> targetClass the target class, for MethodMatcher invocations</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> interceptorsAndDynamicMethodMatchers interceptors that should be applied,</span></span><br><span class=\"line\"><span class=\"comment\">\t * along with any InterceptorAndDynamicMethodMatchers that need evaluation at runtime.</span></span><br><span class=\"line\"><span class=\"comment\">\t * MethodMatchers included in this struct must already have been found to have matched</span></span><br><span class=\"line\"><span class=\"comment\">\t * as far as was possibly statically. Passing an array might be about 10% faster,</span></span><br><span class=\"line\"><span class=\"comment\">\t * but would complicate the code. And it would work only for static pointcuts.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">ReflectiveMethodInvocation</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"keyword\">protected</span> ReflectiveMethodInvocation(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\tObject proxy, <span class=\"meta\">@Nullable</span> Object target, Method method, <span class=\"meta\">@Nullable</span> Object[] arguments,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t<span class=\"meta\">@Nullable</span> Class&lt;?&gt; targetClass, List&lt;Object&gt; interceptorsAndDynamicMethodMatchers)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.proxy = proxy;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.targetClass = targetClass;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 找到桥接方法，作为最后执行的方法。至于什么是桥接方法，自行百度关键字：bridge method</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 桥接方法是 JDK 1.5 引入泛型后，为了使Java的泛型方法生成的字节码和 1.5 版本前的字节码相兼容，由编译器自动生成的方法（子类实现父类的泛型方法时会生成桥接方法）</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.method = BridgeMethodResolver.findBridgedMethod(method);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 对参数进行适配</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.arguments = AopProxyUtils.adaptArgumentsIfNecessary(method, arguments);</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Object <span class=\"title\">getProxy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.proxy;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Object <span class=\"title\">getThis</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.target;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 此处：getStaticPart返回的就是当前得method</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> AccessibleObject <span class=\"title\">getStaticPart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.method;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 注意：这里返回的可能是桥接方法哦</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Method <span class=\"title\">getMethod</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.method;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Object[] getArguments() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arguments;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setArguments</span><span class=\"params\">(Object... arguments)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.arguments = arguments;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 核心在这里</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">proceed</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//\tWe start with an index of -1 and increment early.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.currentInterceptorIndex == <span class=\"keyword\">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这个方法相当于调用了目标方法</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> invokeJoinpoint();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取集合中的 MethodInterceptor（并且currentInterceptorIndex + 1）</span></span><br><span class=\"line\">\t\tObject interceptorOrInterceptionAdvice =</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class=\"keyword\">this</span>.currentInterceptorIndex);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (interceptorOrInterceptionAdvice <span class=\"keyword\">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// been evaluated and found to match.</span></span><br><span class=\"line\">\t\t\tInterceptorAndDynamicMethodMatcher dm =</span><br><span class=\"line\">\t\t\t\t\t(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class=\"line\">\t\t\tClass&lt;?&gt; targetClass = (<span class=\"keyword\">this</span>.targetClass != <span class=\"keyword\">null</span> ? <span class=\"keyword\">this</span>.targetClass : <span class=\"keyword\">this</span>.method.getDeclaringClass());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dm.methodMatcher.matches(<span class=\"keyword\">this</span>.method, targetClass, <span class=\"keyword\">this</span>.arguments)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 执行封装了横切逻辑的invoke方法</span></span><br><span class=\"line\">                <span class=\"comment\">// 所以在interceptor.invoke方法内部, 必须调用invocation.proceed(), 才能再次恢复递归; 否则, 会发生&quot;短路&quot;. 就无法执行上面的invokeJoinpoint();</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> dm.interceptor.invoke(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// Dynamic matching failed.</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> proceed();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// It&#x27;s an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// been evaluated statically before this object was constructed.</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Invoke the joinpoint using reflection.</span></span><br><span class=\"line\"><span class=\"comment\">\t * Subclasses can override this to use custom invocation.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the return value of the joinpoint</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@throws</span> Throwable if invoking the joinpoint resulted in an exception</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">invokeJoinpoint</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// this.target指的就是被代理的目标对象</span></span><br><span class=\"line\">        <span class=\"comment\">// 最终invokeJoinpointUsingReflection内部执行的就是method.invoke(arguments);也就是说执行了目标对象的Joinpoint</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> AopUtils.invokeJoinpointUsingReflection(<span class=\"keyword\">this</span>.target, <span class=\"keyword\">this</span>.method, <span class=\"keyword\">this</span>.arguments);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...    </span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重要的解释信息都在代码的注释中, 这里理清楚它们继承的关系, 可以看出它们是AOP Joinpoint概念实现</p>\n<img  src=http://www.plantuml.com/plantuml/svg/yyhFp2i0uX85cnfTNGNFlBByvCIIpFmyBg1OQb5QOdAgWXTSJNKjaZ12BKYS2uaBDietjIGZFmMhWUXIOFqOWc1J0ehoAohn68LL7cmUTXcR6ZqzXQ3Kj9pKv9BCibHqUG00>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.aopalliance.intercept;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.AccessibleObject;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * This interface represents a generic runtime joinpoint (in the AOP</span></span><br><span class=\"line\"><span class=\"comment\"> * terminology).</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;A runtime joinpoint is an &lt;i&gt;event&lt;/i&gt; that occurs on a static</span></span><br><span class=\"line\"><span class=\"comment\"> * joinpoint (i.e. a location in a the program). For instance, an</span></span><br><span class=\"line\"><span class=\"comment\"> * invocation is the runtime joinpoint on a method (static joinpoint).</span></span><br><span class=\"line\"><span class=\"comment\"> * The static part of a given joinpoint can be generically retrieved</span></span><br><span class=\"line\"><span class=\"comment\"> * using the &#123;<span class=\"doctag\">@link</span> #getStaticPart()&#125; method.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;In the context of an interception framework, a runtime joinpoint</span></span><br><span class=\"line\"><span class=\"comment\"> * is then the reification of an access to an accessible object (a</span></span><br><span class=\"line\"><span class=\"comment\"> * method, a constructor, a field), i.e. the static part of the</span></span><br><span class=\"line\"><span class=\"comment\"> * joinpoint. It is passed to the interceptors that are installed on</span></span><br><span class=\"line\"><span class=\"comment\"> * the static joinpoint.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Rod Johnson</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> Interceptor</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Joinpoint</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Proceed to the next interceptor in the chain.</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;The implementation and the semantics of this method depends</span></span><br><span class=\"line\"><span class=\"comment\">\t * on the actual joinpoint type (see the children interfaces).</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> see the children interfaces&#x27; proceed definition</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@throws</span> Throwable if the joinpoint throws an exception</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\">Object <span class=\"title\">proceed</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Return the object that holds the current joinpoint&#x27;s static part.</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;For instance, the target object for an invocation.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the object (can be null if the accessible object is static)</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\">Object <span class=\"title\">getThis</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Return the static part of this joinpoint.</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;The static part is an accessible object on which a chain of</span></span><br><span class=\"line\"><span class=\"comment\">\t * interceptors are installed.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\">AccessibleObject <span class=\"title\">getStaticPart</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>这篇博客需和另一篇将Spring AOP的相结合.</p>\n<h1 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h1><p>用这样一段OnJava8的原文来描述责任链模式</p>\n<blockquote><p>In recursion, one method calls itself over and over until it reaches a termination condition; with <strong>Chain of Responsibility</strong>, a method calls the same base-class method (with a different implementation) which calls another implementation of the base-class method, etc., until it reaches a termination condition.</p>\n<footer><strong>Bruce Eckel</strong><cite>OnJava8</cite></footer></blockquote>\n\n<p>从中体会到几点: Java中使用递归调用来执行整个链条, 链条是一个List, 这个List中保存着每个子类重写父类的同一个方法, 但是它们实现逻辑不同. </p>\n<p>在Spring AOP中, 对于某个Joinpoint. 要加入一个横切逻辑, 需要定义一个类实现MethodInterceptor, 重写其invoke方法, 在invoke方法体中添加横切逻辑. 其方法体中必须调用<code>invocation.proceed()</code>方法, 不然会造成”短路”. </p>\n<p>有多个MethodInterceptor实现的时候, 要按照逐个执行它们的invoke方法(横切逻辑), 这些匹配到的interceptor, 最终集中到了<code>ReflectiveMethodInvocation.interceptorsAndDynamicMethodMatchers</code>这个List中, 将在<code>proceed()</code>方法中执行. 这里用到了递归, 整体是”责任链模式”</p>\n<p>附上ReflectiveMethodInvocation源码来解释</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Spring&#x27;s implementation of the AOP Alliance</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> org.aopalliance.intercept.MethodInvocation&#125; interface,</span></span><br><span class=\"line\"><span class=\"comment\"> * implementing the extended</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> org.springframework.aop.ProxyMethodInvocation&#125; interface.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;Invokes the target object using reflection. Subclasses can override the</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #invokeJoinpoint()&#125; method to change this behavior, so this is also</span></span><br><span class=\"line\"><span class=\"comment\"> * a useful base class for more specialized MethodInvocation implementations.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;It is possible to clone an invocation, to invoke &#123;<span class=\"doctag\">@link</span> #proceed()&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * repeatedly (once per clone), using the &#123;<span class=\"doctag\">@link</span> #invocableClone()&#125; method.</span></span><br><span class=\"line\"><span class=\"comment\"> * It is also possible to attach custom attributes to the invocation,</span></span><br><span class=\"line\"><span class=\"comment\"> * using the &#123;<span class=\"doctag\">@link</span> #setUserAttribute&#125; / &#123;<span class=\"doctag\">@link</span> #getUserAttribute&#125; methods.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;&lt;b&gt;<span class=\"doctag\">NOTE:</span>&lt;/b&gt; This class is considered internal and should not be</span></span><br><span class=\"line\"><span class=\"comment\"> * directly accessed. The sole reason for it being public is compatibility</span></span><br><span class=\"line\"><span class=\"comment\"> * with existing framework integrations (e.g. Pitchfork). For any other</span></span><br><span class=\"line\"><span class=\"comment\"> * purposes, use the &#123;<span class=\"doctag\">@link</span> ProxyMethodInvocation&#125; interface instead.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Rod Johnson</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Juergen Hoeller</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Adrian Colyer</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #invokeJoinpoint</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #proceed</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #invocableClone</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #setUserAttribute</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #getUserAttribute</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReflectiveMethodInvocation</span> <span class=\"keyword\">implements</span> <span class=\"title\">ProxyMethodInvocation</span>, <span class=\"title\">Cloneable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> Object proxy;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> Method method;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> Object[] arguments = <span class=\"keyword\">new</span> Object[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Class&lt;?&gt; targetClass;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Lazily initialized map of user-specific attributes for this invocation.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Map&lt;String, Object&gt; userAttributes;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * List of MethodInterceptor and InterceptorAndDynamicMethodMatcher</span></span><br><span class=\"line\"><span class=\"comment\">\t * that need dynamic checks.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> List&lt;?&gt; interceptorsAndDynamicMethodMatchers;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Index from 0 of the current interceptor we&#x27;re invoking.</span></span><br><span class=\"line\"><span class=\"comment\">\t * -1 until we invoke: then the current interceptor.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> currentInterceptorIndex = -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Construct a new ReflectiveMethodInvocation with the given arguments.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> proxy the proxy object that the invocation was made on</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> target the target object to invoke</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> method the method to invoke</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> arguments the arguments to invoke the method with</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> targetClass the target class, for MethodMatcher invocations</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> interceptorsAndDynamicMethodMatchers interceptors that should be applied,</span></span><br><span class=\"line\"><span class=\"comment\">\t * along with any InterceptorAndDynamicMethodMatchers that need evaluation at runtime.</span></span><br><span class=\"line\"><span class=\"comment\">\t * MethodMatchers included in this struct must already have been found to have matched</span></span><br><span class=\"line\"><span class=\"comment\">\t * as far as was possibly statically. Passing an array might be about 10% faster,</span></span><br><span class=\"line\"><span class=\"comment\">\t * but would complicate the code. And it would work only for static pointcuts.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">ReflectiveMethodInvocation</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"keyword\">protected</span> ReflectiveMethodInvocation(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\tObject proxy, <span class=\"meta\">@Nullable</span> Object target, Method method, <span class=\"meta\">@Nullable</span> Object[] arguments,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t<span class=\"meta\">@Nullable</span> Class&lt;?&gt; targetClass, List&lt;Object&gt; interceptorsAndDynamicMethodMatchers)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.proxy = proxy;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.targetClass = targetClass;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 找到桥接方法，作为最后执行的方法。至于什么是桥接方法，自行百度关键字：bridge method</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 桥接方法是 JDK 1.5 引入泛型后，为了使Java的泛型方法生成的字节码和 1.5 版本前的字节码相兼容，由编译器自动生成的方法（子类实现父类的泛型方法时会生成桥接方法）</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.method = BridgeMethodResolver.findBridgedMethod(method);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 对参数进行适配</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.arguments = AopProxyUtils.adaptArgumentsIfNecessary(method, arguments);</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Object <span class=\"title\">getProxy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.proxy;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Object <span class=\"title\">getThis</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.target;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 此处：getStaticPart返回的就是当前得method</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> AccessibleObject <span class=\"title\">getStaticPart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.method;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 注意：这里返回的可能是桥接方法哦</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Method <span class=\"title\">getMethod</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.method;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Object[] getArguments() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.arguments;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setArguments</span><span class=\"params\">(Object... arguments)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.arguments = arguments;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 核心在这里</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">proceed</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//\tWe start with an index of -1 and increment early.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.currentInterceptorIndex == <span class=\"keyword\">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这个方法相当于调用了目标方法</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> invokeJoinpoint();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取集合中的 MethodInterceptor（并且currentInterceptorIndex + 1）</span></span><br><span class=\"line\">\t\tObject interceptorOrInterceptionAdvice =</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class=\"keyword\">this</span>.currentInterceptorIndex);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (interceptorOrInterceptionAdvice <span class=\"keyword\">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// been evaluated and found to match.</span></span><br><span class=\"line\">\t\t\tInterceptorAndDynamicMethodMatcher dm =</span><br><span class=\"line\">\t\t\t\t\t(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class=\"line\">\t\t\tClass&lt;?&gt; targetClass = (<span class=\"keyword\">this</span>.targetClass != <span class=\"keyword\">null</span> ? <span class=\"keyword\">this</span>.targetClass : <span class=\"keyword\">this</span>.method.getDeclaringClass());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dm.methodMatcher.matches(<span class=\"keyword\">this</span>.method, targetClass, <span class=\"keyword\">this</span>.arguments)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 执行封装了横切逻辑的invoke方法</span></span><br><span class=\"line\">                <span class=\"comment\">// 所以在interceptor.invoke方法内部, 必须调用invocation.proceed(), 才能再次恢复递归; 否则, 会发生&quot;短路&quot;. 就无法执行上面的invokeJoinpoint();</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> dm.interceptor.invoke(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// Dynamic matching failed.</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> proceed();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// It&#x27;s an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// been evaluated statically before this object was constructed.</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Invoke the joinpoint using reflection.</span></span><br><span class=\"line\"><span class=\"comment\">\t * Subclasses can override this to use custom invocation.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the return value of the joinpoint</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@throws</span> Throwable if invoking the joinpoint resulted in an exception</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">invokeJoinpoint</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// this.target指的就是被代理的目标对象</span></span><br><span class=\"line\">        <span class=\"comment\">// 最终invokeJoinpointUsingReflection内部执行的就是method.invoke(arguments);也就是说执行了目标对象的Joinpoint</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> AopUtils.invokeJoinpointUsingReflection(<span class=\"keyword\">this</span>.target, <span class=\"keyword\">this</span>.method, <span class=\"keyword\">this</span>.arguments);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...    </span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重要的解释信息都在代码的注释中, 这里理清楚它们继承的关系, 可以看出它们是AOP Joinpoint概念实现</p>\n<img  src=http://www.plantuml.com/plantuml/svg/yyhFp2i0uX85cnfTNGNFlBByvCIIpFmyBg1OQb5QOdAgWXTSJNKjaZ12BKYS2uaBDietjIGZFmMhWUXIOFqOWc1J0ehoAohn68LL7cmUTXcR6ZqzXQ3Kj9pKv9BCibHqUG00>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.aopalliance.intercept;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.AccessibleObject;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * This interface represents a generic runtime joinpoint (in the AOP</span></span><br><span class=\"line\"><span class=\"comment\"> * terminology).</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;A runtime joinpoint is an &lt;i&gt;event&lt;/i&gt; that occurs on a static</span></span><br><span class=\"line\"><span class=\"comment\"> * joinpoint (i.e. a location in a the program). For instance, an</span></span><br><span class=\"line\"><span class=\"comment\"> * invocation is the runtime joinpoint on a method (static joinpoint).</span></span><br><span class=\"line\"><span class=\"comment\"> * The static part of a given joinpoint can be generically retrieved</span></span><br><span class=\"line\"><span class=\"comment\"> * using the &#123;<span class=\"doctag\">@link</span> #getStaticPart()&#125; method.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;In the context of an interception framework, a runtime joinpoint</span></span><br><span class=\"line\"><span class=\"comment\"> * is then the reification of an access to an accessible object (a</span></span><br><span class=\"line\"><span class=\"comment\"> * method, a constructor, a field), i.e. the static part of the</span></span><br><span class=\"line\"><span class=\"comment\"> * joinpoint. It is passed to the interceptors that are installed on</span></span><br><span class=\"line\"><span class=\"comment\"> * the static joinpoint.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Rod Johnson</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> Interceptor</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Joinpoint</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Proceed to the next interceptor in the chain.</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;The implementation and the semantics of this method depends</span></span><br><span class=\"line\"><span class=\"comment\">\t * on the actual joinpoint type (see the children interfaces).</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> see the children interfaces&#x27; proceed definition</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@throws</span> Throwable if the joinpoint throws an exception</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\">Object <span class=\"title\">proceed</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Return the object that holds the current joinpoint&#x27;s static part.</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;For instance, the target object for an invocation.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the object (can be null if the accessible object is static)</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\">Object <span class=\"title\">getThis</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Return the static part of this joinpoint.</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;The static part is an accessible object on which a chain of</span></span><br><span class=\"line\"><span class=\"comment\">\t * interceptors are installed.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\">AccessibleObject <span class=\"title\">getStaticPart</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Java中的类加载器","date":"2021-06-15T02:50:33.000Z","_content":"\n# ClassLoader\nA class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a \"class file\" of that name from a file system.\n类加载器负责加载类. ClassLoader是抽象类. 对于给定类的二进制名字, 类加载器应该试图去定位或者生成构成一个类定义的数据. 一个典型的策略是将这个名字转换为文件名, 然后从文件体统中读取该名字的class file.\n\nEvery Class object contains a reference to the ClassLoader that defined it.\n每个Class对象都包含一个引用, 它指向定义它的那个ClassLoader.\n> 这一点在源码中表现的就是, 在Class类中, 有一个Filed是ClassLoader类型\n```java\npublic final class Class<T> implements java.io.Serializable,\n                              GenericDeclaration,\n                              Type,\n                              AnnotatedElement {\n\n    // ...\n\n    /*\n     * Private constructor. Only the Java Virtual Machine creates Class objects.\n     * This constructor is not used and prevents the default constructor being\n     * generated.\n     */\n    // NOTE: 这里出现了私有构造器, 说明这个构造函数是能在Class这类里使用\n    private Class(ClassLoader loader) {\n        // Initialize final field for classLoader.  The initialization value of non-null\n        // prevents future JIT optimizations from assuming this final field is null.\n        classLoader = loader;\n    }\n\n    // ...\n\n    // Initialized in JVM not by private constructor\n    // This field is filtered from reflection access, i.e. getDeclaredField\n    // will throw NoSuchFieldException\n    private final ClassLoader classLoader;\n\n    // ...\n}\n```\n\nApplications implement subclasses of ClassLoader in order to extend the manner in which the Java virtual machine dynamically loads classes.\n应用实现了ClassLoader的子类, 是为了扩展JVM动态加载类的方式.\n\nThe ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine's built-in class loader, called the \"bootstrap class loader\", does not itself have a parent but may serve as the parent of a ClassLoader instance.\nClassLoader 类使用委托模型来搜索类和资源。 ClassLoader 的每个实例都有一个关联的父类加载器。当请求查找类或资源时，ClassLoader 实例会将类或资源的搜索委托给其父类加载器，然后再尝试查找类或资源本身。虚拟机的内置类加载器，称为“引导类加载器”，它本身没有父级，但可以作为 ClassLoader 实例的父级。\n\nNormally, the Java virtual machine loads classes from the local file system in a platform-dependent manner. For example, on UNIX systems, the virtual machine loads classes from the directory defined by the CLASSPATH environment variable.\n一般情况下, JVM加载类通过本地的文件系统. 比如, UNIX系统, JVN从CLASSPATH环境变量定义的目录中来加载类.\n\nHowever, some classes may not originate from a file; they may originate from other sources, such as the network, or they could be constructed by an application. The method defineClass converts an array of bytes into an instance of class Class. Instances of this newly defined class can be created using Class.newInstance.\n然而, 有些类可能不来源于文件; 它们可能来源于其他资源, 比如网络或者被应用构造. `defineClass`方法将字节数组转换为类Class的实例. 这个新定义的类的实例可以被`Class.newInstace`创建.\n\nThe methods and constructors of objects created by a class loader may reference other classes. To determine the class(es) referred to, the Java virtual machine invokes the loadClass method of the class loader that originally created the class.\n被类加载器创建的对象, 它的方法和构造器可能引用自其他类. \n\nFor example, an application could create a network class loader to download class files from a server. Sample code might look like:\n\n   ClassLoader loader = new NetworkClassLoader(host, port);\n   Object main = loader.loadClass(\"Main\", true).newInstance();\n        . . .\n \n\nThe network class loader subclass must define the methods findClass and loadClassData to load a class from the network. Once it has downloaded the bytes that make up the class, it should use the method defineClass to create a class instance. A sample implementation is:\n\n     class NetworkClassLoader extends ClassLoader {\n         String host;\n         int port;\n\n         public Class findClass(String name) {\n             byte[] b = loadClassData(name);\n             return defineClass(name, b, 0, b.length);\n         }\n\n         private byte[] loadClassData(String name) {\n             // load the class data from the connection\n              . . .\n         }\n     }\n","source":"_posts/java-classloader.md","raw":"---\ntitle: Java中的类加载器\ndate: 2021-06-15 10:50:33\ncategories:\n- Java\ntags:\n- ClassLoader\n---\n\n# ClassLoader\nA class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a \"class file\" of that name from a file system.\n类加载器负责加载类. ClassLoader是抽象类. 对于给定类的二进制名字, 类加载器应该试图去定位或者生成构成一个类定义的数据. 一个典型的策略是将这个名字转换为文件名, 然后从文件体统中读取该名字的class file.\n\nEvery Class object contains a reference to the ClassLoader that defined it.\n每个Class对象都包含一个引用, 它指向定义它的那个ClassLoader.\n> 这一点在源码中表现的就是, 在Class类中, 有一个Filed是ClassLoader类型\n```java\npublic final class Class<T> implements java.io.Serializable,\n                              GenericDeclaration,\n                              Type,\n                              AnnotatedElement {\n\n    // ...\n\n    /*\n     * Private constructor. Only the Java Virtual Machine creates Class objects.\n     * This constructor is not used and prevents the default constructor being\n     * generated.\n     */\n    // NOTE: 这里出现了私有构造器, 说明这个构造函数是能在Class这类里使用\n    private Class(ClassLoader loader) {\n        // Initialize final field for classLoader.  The initialization value of non-null\n        // prevents future JIT optimizations from assuming this final field is null.\n        classLoader = loader;\n    }\n\n    // ...\n\n    // Initialized in JVM not by private constructor\n    // This field is filtered from reflection access, i.e. getDeclaredField\n    // will throw NoSuchFieldException\n    private final ClassLoader classLoader;\n\n    // ...\n}\n```\n\nApplications implement subclasses of ClassLoader in order to extend the manner in which the Java virtual machine dynamically loads classes.\n应用实现了ClassLoader的子类, 是为了扩展JVM动态加载类的方式.\n\nThe ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine's built-in class loader, called the \"bootstrap class loader\", does not itself have a parent but may serve as the parent of a ClassLoader instance.\nClassLoader 类使用委托模型来搜索类和资源。 ClassLoader 的每个实例都有一个关联的父类加载器。当请求查找类或资源时，ClassLoader 实例会将类或资源的搜索委托给其父类加载器，然后再尝试查找类或资源本身。虚拟机的内置类加载器，称为“引导类加载器”，它本身没有父级，但可以作为 ClassLoader 实例的父级。\n\nNormally, the Java virtual machine loads classes from the local file system in a platform-dependent manner. For example, on UNIX systems, the virtual machine loads classes from the directory defined by the CLASSPATH environment variable.\n一般情况下, JVM加载类通过本地的文件系统. 比如, UNIX系统, JVN从CLASSPATH环境变量定义的目录中来加载类.\n\nHowever, some classes may not originate from a file; they may originate from other sources, such as the network, or they could be constructed by an application. The method defineClass converts an array of bytes into an instance of class Class. Instances of this newly defined class can be created using Class.newInstance.\n然而, 有些类可能不来源于文件; 它们可能来源于其他资源, 比如网络或者被应用构造. `defineClass`方法将字节数组转换为类Class的实例. 这个新定义的类的实例可以被`Class.newInstace`创建.\n\nThe methods and constructors of objects created by a class loader may reference other classes. To determine the class(es) referred to, the Java virtual machine invokes the loadClass method of the class loader that originally created the class.\n被类加载器创建的对象, 它的方法和构造器可能引用自其他类. \n\nFor example, an application could create a network class loader to download class files from a server. Sample code might look like:\n\n   ClassLoader loader = new NetworkClassLoader(host, port);\n   Object main = loader.loadClass(\"Main\", true).newInstance();\n        . . .\n \n\nThe network class loader subclass must define the methods findClass and loadClassData to load a class from the network. Once it has downloaded the bytes that make up the class, it should use the method defineClass to create a class instance. A sample implementation is:\n\n     class NetworkClassLoader extends ClassLoader {\n         String host;\n         int port;\n\n         public Class findClass(String name) {\n             byte[] b = loadClassData(name);\n             return defineClass(name, b, 0, b.length);\n         }\n\n         private byte[] loadClassData(String name) {\n             // load the class data from the connection\n              . . .\n         }\n     }\n","slug":"java-classloader","published":1,"updated":"2021-12-30T03:01:15.553Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxsdzpyf000bxotg7gxz7t70","content":"<h1 id=\"ClassLoader\"><a href=\"#ClassLoader\" class=\"headerlink\" title=\"ClassLoader\"></a>ClassLoader</h1><p>A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a “class file” of that name from a file system.<br>类加载器负责加载类. ClassLoader是抽象类. 对于给定类的二进制名字, 类加载器应该试图去定位或者生成构成一个类定义的数据. 一个典型的策略是将这个名字转换为文件名, 然后从文件体统中读取该名字的class file.</p>\n<p>Every Class object contains a reference to the ClassLoader that defined it.<br>每个Class对象都包含一个引用, 它指向定义它的那个ClassLoader.</p>\n<blockquote>\n<p>这一点在源码中表现的就是, 在Class类中, 有一个Filed是ClassLoader类型</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Class</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span>,</span></span><br><span class=\"line\"><span class=\"class\">                              <span class=\"title\">GenericDeclaration</span>,</span></span><br><span class=\"line\"><span class=\"class\">                              <span class=\"title\">Type</span>,</span></span><br><span class=\"line\"><span class=\"class\">                              <span class=\"title\">AnnotatedElement</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Private constructor. Only the Java Virtual Machine creates Class objects.</span></span><br><span class=\"line\"><span class=\"comment\">     * This constructor is not used and prevents the default constructor being</span></span><br><span class=\"line\"><span class=\"comment\">     * generated.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> 这里出现了私有构造器, 说明这个构造函数是能在Class这类里使用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Class</span><span class=\"params\">(ClassLoader loader)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Initialize final field for classLoader.  The initialization value of non-null</span></span><br><span class=\"line\">        <span class=\"comment\">// prevents future JIT optimizations from assuming this final field is null.</span></span><br><span class=\"line\">        classLoader = loader;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Initialized in JVM not by private constructor</span></span><br><span class=\"line\">    <span class=\"comment\">// This field is filtered from reflection access, i.e. getDeclaredField</span></span><br><span class=\"line\">    <span class=\"comment\">// will throw NoSuchFieldException</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ClassLoader classLoader;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Applications implement subclasses of ClassLoader in order to extend the manner in which the Java virtual machine dynamically loads classes.<br>应用实现了ClassLoader的子类, 是为了扩展JVM动态加载类的方式.</p>\n<p>The ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine’s built-in class loader, called the “bootstrap class loader”, does not itself have a parent but may serve as the parent of a ClassLoader instance.<br>ClassLoader 类使用委托模型来搜索类和资源。 ClassLoader 的每个实例都有一个关联的父类加载器。当请求查找类或资源时，ClassLoader 实例会将类或资源的搜索委托给其父类加载器，然后再尝试查找类或资源本身。虚拟机的内置类加载器，称为“引导类加载器”，它本身没有父级，但可以作为 ClassLoader 实例的父级。</p>\n<p>Normally, the Java virtual machine loads classes from the local file system in a platform-dependent manner. For example, on UNIX systems, the virtual machine loads classes from the directory defined by the CLASSPATH environment variable.<br>一般情况下, JVM加载类通过本地的文件系统. 比如, UNIX系统, JVN从CLASSPATH环境变量定义的目录中来加载类.</p>\n<p>However, some classes may not originate from a file; they may originate from other sources, such as the network, or they could be constructed by an application. The method defineClass converts an array of bytes into an instance of class Class. Instances of this newly defined class can be created using Class.newInstance.<br>然而, 有些类可能不来源于文件; 它们可能来源于其他资源, 比如网络或者被应用构造. <code>defineClass</code>方法将字节数组转换为类Class的实例. 这个新定义的类的实例可以被<code>Class.newInstace</code>创建.</p>\n<p>The methods and constructors of objects created by a class loader may reference other classes. To determine the class(es) referred to, the Java virtual machine invokes the loadClass method of the class loader that originally created the class.<br>被类加载器创建的对象, 它的方法和构造器可能引用自其他类. </p>\n<p>For example, an application could create a network class loader to download class files from a server. Sample code might look like:</p>\n<p>   ClassLoader loader = new NetworkClassLoader(host, port);<br>   Object main = loader.loadClass(“Main”, true).newInstance();<br>        . . .</p>\n<p>The network class loader subclass must define the methods findClass and loadClassData to load a class from the network. Once it has downloaded the bytes that make up the class, it should use the method defineClass to create a class instance. A sample implementation is:</p>\n<pre><code> class NetworkClassLoader extends ClassLoader &#123;\n     String host;\n     int port;\n\n     public Class findClass(String name) &#123;\n         byte[] b = loadClassData(name);\n         return defineClass(name, b, 0, b.length);\n     &#125;\n\n     private byte[] loadClassData(String name) &#123;\n         // load the class data from the connection\n          . . .\n     &#125;\n &#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ClassLoader\"><a href=\"#ClassLoader\" class=\"headerlink\" title=\"ClassLoader\"></a>ClassLoader</h1><p>A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a “class file” of that name from a file system.<br>类加载器负责加载类. ClassLoader是抽象类. 对于给定类的二进制名字, 类加载器应该试图去定位或者生成构成一个类定义的数据. 一个典型的策略是将这个名字转换为文件名, 然后从文件体统中读取该名字的class file.</p>\n<p>Every Class object contains a reference to the ClassLoader that defined it.<br>每个Class对象都包含一个引用, 它指向定义它的那个ClassLoader.</p>\n<blockquote>\n<p>这一点在源码中表现的就是, 在Class类中, 有一个Filed是ClassLoader类型</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Class</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span>,</span></span><br><span class=\"line\"><span class=\"class\">                              <span class=\"title\">GenericDeclaration</span>,</span></span><br><span class=\"line\"><span class=\"class\">                              <span class=\"title\">Type</span>,</span></span><br><span class=\"line\"><span class=\"class\">                              <span class=\"title\">AnnotatedElement</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Private constructor. Only the Java Virtual Machine creates Class objects.</span></span><br><span class=\"line\"><span class=\"comment\">     * This constructor is not used and prevents the default constructor being</span></span><br><span class=\"line\"><span class=\"comment\">     * generated.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> 这里出现了私有构造器, 说明这个构造函数是能在Class这类里使用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Class</span><span class=\"params\">(ClassLoader loader)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Initialize final field for classLoader.  The initialization value of non-null</span></span><br><span class=\"line\">        <span class=\"comment\">// prevents future JIT optimizations from assuming this final field is null.</span></span><br><span class=\"line\">        classLoader = loader;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Initialized in JVM not by private constructor</span></span><br><span class=\"line\">    <span class=\"comment\">// This field is filtered from reflection access, i.e. getDeclaredField</span></span><br><span class=\"line\">    <span class=\"comment\">// will throw NoSuchFieldException</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ClassLoader classLoader;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Applications implement subclasses of ClassLoader in order to extend the manner in which the Java virtual machine dynamically loads classes.<br>应用实现了ClassLoader的子类, 是为了扩展JVM动态加载类的方式.</p>\n<p>The ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine’s built-in class loader, called the “bootstrap class loader”, does not itself have a parent but may serve as the parent of a ClassLoader instance.<br>ClassLoader 类使用委托模型来搜索类和资源。 ClassLoader 的每个实例都有一个关联的父类加载器。当请求查找类或资源时，ClassLoader 实例会将类或资源的搜索委托给其父类加载器，然后再尝试查找类或资源本身。虚拟机的内置类加载器，称为“引导类加载器”，它本身没有父级，但可以作为 ClassLoader 实例的父级。</p>\n<p>Normally, the Java virtual machine loads classes from the local file system in a platform-dependent manner. For example, on UNIX systems, the virtual machine loads classes from the directory defined by the CLASSPATH environment variable.<br>一般情况下, JVM加载类通过本地的文件系统. 比如, UNIX系统, JVN从CLASSPATH环境变量定义的目录中来加载类.</p>\n<p>However, some classes may not originate from a file; they may originate from other sources, such as the network, or they could be constructed by an application. The method defineClass converts an array of bytes into an instance of class Class. Instances of this newly defined class can be created using Class.newInstance.<br>然而, 有些类可能不来源于文件; 它们可能来源于其他资源, 比如网络或者被应用构造. <code>defineClass</code>方法将字节数组转换为类Class的实例. 这个新定义的类的实例可以被<code>Class.newInstace</code>创建.</p>\n<p>The methods and constructors of objects created by a class loader may reference other classes. To determine the class(es) referred to, the Java virtual machine invokes the loadClass method of the class loader that originally created the class.<br>被类加载器创建的对象, 它的方法和构造器可能引用自其他类. </p>\n<p>For example, an application could create a network class loader to download class files from a server. Sample code might look like:</p>\n<p>   ClassLoader loader = new NetworkClassLoader(host, port);<br>   Object main = loader.loadClass(“Main”, true).newInstance();<br>        . . .</p>\n<p>The network class loader subclass must define the methods findClass and loadClassData to load a class from the network. Once it has downloaded the bytes that make up the class, it should use the method defineClass to create a class instance. A sample implementation is:</p>\n<pre><code> class NetworkClassLoader extends ClassLoader &#123;\n     String host;\n     int port;\n\n     public Class findClass(String name) &#123;\n         byte[] b = loadClassData(name);\n         return defineClass(name, b, 0, b.length);\n     &#125;\n\n     private byte[] loadClassData(String name) &#123;\n         // load the class data from the connection\n          . . .\n     &#125;\n &#125;\n</code></pre>\n"},{"title":"抽象工厂","date":"2021-07-03T12:01:57.000Z","_content":"\n# 动态工厂\n{% blockquote Bruce Eckel, On Java 8 %}\nFactories: Encapsulating Object Creation\n\nA Factory forces object creation to occur through a common point, preventing creational code from appearing throught your system.\n{% endblockquote %}\n工厂模式其实是封装对象的创建过程. 强制将让对象的创建发生在一个统一的地方, 阻止代码散落在系统中.\n\n静态工厂就不说了, 就是通过传入对象的标识, 在创建方法内部判断条件new出目标对象.\n那么动态工厂, 就更加解耦, 通过传入的标识, 反射得到类, 然后`xxx.getNewInstance()`, 例子如下:\n```java\nclass Shape {\n  @Override\n  public String toString() {\n    return getClass().getSimpleName();\n  }\n}\n\ninterface ShapeFactory {\n  Shape create(String type);\n}\n\nclass Circle extends Shape {\n  public Circle() {}\n}\n\nclass Square extends Shape {}\n\nclass Triangle extends Shape {}\n\npublic class DynamicFactory implements ShapeFactory {\n\n  @Override\n  public Shape create(String type) {\n    try {\n      return (Shape)\n          Class.forName(\"package.name.\" + type).getConstructor().newInstance();\n    } catch (Exception e) {\n      System.out.println(e.getLocalizedMessage());\n      return null;\n    }\n  }\n\n  public static void main(String[] args) {\n    Shape s = new DynamicFactory().create(\"Circle\");\n    System.out.println(s.toString());\n  }\n}\n```\n\n# 抽象工厂\n抽象工厂是在工厂的基础上又封装了一层, 即将工厂传入\n```java\nclass AbstractFactory {\n    Supplier<Player> player;\n    Supplier<Obstacle> obstacle;\n}\n\nclass ConcreteFactory1 extends AbstractFactory {\n    ConcreteFactory() {\n        player = Player1::new;\n        obstacle = Obstacle1::new;\n    }\n}\npublic class GameEnvironment {\n  private Player p;\n  private Obstacle ob;\n  public getInstance(AbstractFactory factory) {\n        p = factory.player.get();\n        ob = factory.obstacle.get();\n    }\n}\n\n```\n","source":"_posts/java-factory-pattern.md","raw":"---\ntitle: 抽象工厂\ndate: 2021-07-03 20:01:57\ncategories:\n- Java\n- Pattern\ntags:\n- factory pattern\n---\n\n# 动态工厂\n{% blockquote Bruce Eckel, On Java 8 %}\nFactories: Encapsulating Object Creation\n\nA Factory forces object creation to occur through a common point, preventing creational code from appearing throught your system.\n{% endblockquote %}\n工厂模式其实是封装对象的创建过程. 强制将让对象的创建发生在一个统一的地方, 阻止代码散落在系统中.\n\n静态工厂就不说了, 就是通过传入对象的标识, 在创建方法内部判断条件new出目标对象.\n那么动态工厂, 就更加解耦, 通过传入的标识, 反射得到类, 然后`xxx.getNewInstance()`, 例子如下:\n```java\nclass Shape {\n  @Override\n  public String toString() {\n    return getClass().getSimpleName();\n  }\n}\n\ninterface ShapeFactory {\n  Shape create(String type);\n}\n\nclass Circle extends Shape {\n  public Circle() {}\n}\n\nclass Square extends Shape {}\n\nclass Triangle extends Shape {}\n\npublic class DynamicFactory implements ShapeFactory {\n\n  @Override\n  public Shape create(String type) {\n    try {\n      return (Shape)\n          Class.forName(\"package.name.\" + type).getConstructor().newInstance();\n    } catch (Exception e) {\n      System.out.println(e.getLocalizedMessage());\n      return null;\n    }\n  }\n\n  public static void main(String[] args) {\n    Shape s = new DynamicFactory().create(\"Circle\");\n    System.out.println(s.toString());\n  }\n}\n```\n\n# 抽象工厂\n抽象工厂是在工厂的基础上又封装了一层, 即将工厂传入\n```java\nclass AbstractFactory {\n    Supplier<Player> player;\n    Supplier<Obstacle> obstacle;\n}\n\nclass ConcreteFactory1 extends AbstractFactory {\n    ConcreteFactory() {\n        player = Player1::new;\n        obstacle = Obstacle1::new;\n    }\n}\npublic class GameEnvironment {\n  private Player p;\n  private Obstacle ob;\n  public getInstance(AbstractFactory factory) {\n        p = factory.player.get();\n        ob = factory.obstacle.get();\n    }\n}\n\n```\n","slug":"java-factory-pattern","published":1,"updated":"2021-12-30T03:01:28.015Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxsdzpyh000exotg922w7a6o","content":"<h1 id=\"动态工厂\"><a href=\"#动态工厂\" class=\"headerlink\" title=\"动态工厂\"></a>动态工厂</h1><blockquote><p>Factories: Encapsulating Object Creation</p>\n<p>A Factory forces object creation to occur through a common point, preventing creational code from appearing throught your system.</p>\n<footer><strong>Bruce Eckel</strong><cite>On Java 8</cite></footer></blockquote>\n<p>工厂模式其实是封装对象的创建过程. 强制将让对象的创建发生在一个统一的地方, 阻止代码散落在系统中.</p>\n<p>静态工厂就不说了, 就是通过传入对象的标识, 在创建方法内部判断条件new出目标对象.<br>那么动态工厂, 就更加解耦, 通过传入的标识, 反射得到类, 然后<code>xxx.getNewInstance()</code>, 例子如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getClass().getSimpleName();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ShapeFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">Shape <span class=\"title\">create</span><span class=\"params\">(String type)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Circle</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Triangle</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ShapeFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Shape <span class=\"title\">create</span><span class=\"params\">(String type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (Shape)</span><br><span class=\"line\">          Class.forName(<span class=\"string\">&quot;package.name.&quot;</span> + type).getConstructor().newInstance();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      System.out.println(e.getLocalizedMessage());</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Shape s = <span class=\"keyword\">new</span> DynamicFactory().create(<span class=\"string\">&quot;Circle&quot;</span>);</span><br><span class=\"line\">    System.out.println(s.toString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"抽象工厂\"><a href=\"#抽象工厂\" class=\"headerlink\" title=\"抽象工厂\"></a>抽象工厂</h1><p>抽象工厂是在工厂的基础上又封装了一层, 即将工厂传入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractFactory</span> </span>&#123;</span><br><span class=\"line\">    Supplier&lt;Player&gt; player;</span><br><span class=\"line\">    Supplier&lt;Obstacle&gt; obstacle;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteFactory1</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractFactory</span> </span>&#123;</span><br><span class=\"line\">    ConcreteFactory() &#123;</span><br><span class=\"line\">        player = Player1::<span class=\"keyword\">new</span>;</span><br><span class=\"line\">        obstacle = Obstacle1::<span class=\"keyword\">new</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GameEnvironment</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Player p;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Obstacle ob;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">getInstance</span><span class=\"params\">(AbstractFactory factory)</span> </span>&#123;</span><br><span class=\"line\">        p = factory.player.get();</span><br><span class=\"line\">        ob = factory.obstacle.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"动态工厂\"><a href=\"#动态工厂\" class=\"headerlink\" title=\"动态工厂\"></a>动态工厂</h1><blockquote><p>Factories: Encapsulating Object Creation</p>\n<p>A Factory forces object creation to occur through a common point, preventing creational code from appearing throught your system.</p>\n<footer><strong>Bruce Eckel</strong><cite>On Java 8</cite></footer></blockquote>\n<p>工厂模式其实是封装对象的创建过程. 强制将让对象的创建发生在一个统一的地方, 阻止代码散落在系统中.</p>\n<p>静态工厂就不说了, 就是通过传入对象的标识, 在创建方法内部判断条件new出目标对象.<br>那么动态工厂, 就更加解耦, 通过传入的标识, 反射得到类, 然后<code>xxx.getNewInstance()</code>, 例子如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getClass().getSimpleName();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ShapeFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">Shape <span class=\"title\">create</span><span class=\"params\">(String type)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Circle</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Triangle</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ShapeFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Shape <span class=\"title\">create</span><span class=\"params\">(String type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (Shape)</span><br><span class=\"line\">          Class.forName(<span class=\"string\">&quot;package.name.&quot;</span> + type).getConstructor().newInstance();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      System.out.println(e.getLocalizedMessage());</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Shape s = <span class=\"keyword\">new</span> DynamicFactory().create(<span class=\"string\">&quot;Circle&quot;</span>);</span><br><span class=\"line\">    System.out.println(s.toString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"抽象工厂\"><a href=\"#抽象工厂\" class=\"headerlink\" title=\"抽象工厂\"></a>抽象工厂</h1><p>抽象工厂是在工厂的基础上又封装了一层, 即将工厂传入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractFactory</span> </span>&#123;</span><br><span class=\"line\">    Supplier&lt;Player&gt; player;</span><br><span class=\"line\">    Supplier&lt;Obstacle&gt; obstacle;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteFactory1</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractFactory</span> </span>&#123;</span><br><span class=\"line\">    ConcreteFactory() &#123;</span><br><span class=\"line\">        player = Player1::<span class=\"keyword\">new</span>;</span><br><span class=\"line\">        obstacle = Obstacle1::<span class=\"keyword\">new</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GameEnvironment</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Player p;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Obstacle ob;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">getInstance</span><span class=\"params\">(AbstractFactory factory)</span> </span>&#123;</span><br><span class=\"line\">        p = factory.player.get();</span><br><span class=\"line\">        ob = factory.obstacle.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"title":"Java函数式编程","date":"2021-08-04T03:10:25.000Z","_content":"编程风格可以分为命令式(Imperative)和声明式(Declarative), 它声明了要做什么, 而不是每一步如何做. \n这正是我们在函数式编程中所看到的的.\n\n# Lambda表达式\n从概念上来说, Lambda表达式, 生产的是函数, 而不是类\n但是在JVM上, everything is a class, 但是经过各种幕后操作之后, **使得Lambda看起来像函数**\n```java\ninterface IntCall {\n\tint call(int arg);\n}\n\nclass IntCallImpl implements IntCall {\n\n\t@Override\n\tpublic int call(int arg) {\n\t\tif (arg == 0) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn arg * call(arg - 1);\n\t\t}\n\t}\n}\npublic class FunctionalPrograming {\n\tstatic IntCall fact;\n\n\t/**\n\t * 传统方法实现\n\t */\n\tpublic static void oldApproach() {\n\t\tIntCallImpl intCall = new IntCallImpl();\n\t\tfor (int i = 0; i <= 10; i++) {\n\t\t\tSystem.out.println(\"oldApproach --> \" + intCall.call(i));\n\t\t}\n\t}\n\n\t/**\n\t * 函数式编程实现\n\t */\n\tpublic static void functionalApproach() {\n        // 这里使用Lambda表达式的简洁语法, 但是其底层实现仍然是类和对象, IntCallImpl的步骤可能一步也没有少, 只是看起来像生成了一个函数.\n\t\tfact = n -> n == 0 ? 1 : n * fact.call(n - 1);\n\t\tfor (int i = 0; i <= 10; i++) {\n\t\t\tSystem.out.println(\"functionalApproach --> \" + fact.call(i));\n\t\t}\n\t}\n\n    public static void anonymousInnerClassApproach() {\n        IntCall fact = IntCallImpl::call\n    }\n\n\tpublic static void main(String[] args) {\n\t\tFunctionalPrograming.oldApproach();\n\t\tFunctionalPrograming.functionalApproach();\n\t}\n}\n```\n\n# Mehtod References\n方法引用的语法:\n{% blockquote %}\nA method reference is a class name or an object name, follow by a ::, then the name of the method \n{% endblockquote %}\n\n```java\nclass X {\n   String f() {\n      return \"X::f\";\n   }\n}\n\ninterface MarkString0 {\n   String make();\n}\n\ninterface MarkString1 {\n   String make(X x);\n}\n\npublic class UnboundMethodReferences {\n   public static void main(String[] args) {\n      // MarkString0 n = X::f                             [1]\n      X x = new X();\n      MarkString0 n = x::f;   // method references        [2]\n      System.out.println(n.make());\n\n      \n      MarkString1 m = X::f;   //unbound method references [3]\n      System.out.println(m.make(new X()));\n\n   }\n}\n```\n从逻辑上来将, 方法的引用是指向一个Method类的一个实例, 方法对象必须绑定在某个类的对象上. 按照这个逻辑, 所以`[2]`可以赋值成功, `[1]`不能. `[1]`这种方式, `class X`和`interface MarkString0`中都没有可以创建`X`的对象, 没有对象如何调用f()方法呢? 这就引出Unbound Method References\n\n## Unbound Method References\n对于这种方式(感觉不常用), 我们需要让对应的接口的第一个参数(隐性规定)必须是X. 举一反三, 如下示例:\n```java\nclass This {\n  void two(int i, double d) {}\n  void three(int i, double d, String s) {}\n  void four(int i, double d, String s, char c) {}\n}\ninterface TwoArgs {\n  void call2(This athis, int i, double d);\n}\ninterface ThreeArgs {\n  void call3(This athis, int i, double d, String s);\n}\npublic class MultiUnbound {\n  public static void main(String[] args) {\n    TwoArgs twoargs = This::two;\n    ThreeArgs threeargs = This::three;\n    This athis = new This();\n    twoargs.call2(athis, 11, 3.14);\n    threeargs.call3(athis, 11, 3.14, \"Three\");\n  }\n}\n```\n\n## 构造函数引用\n```java\nclass Dog {\n  String name;\n  int age = -1; // For \"unknown\"\n  Dog() { name = \"stray\"; }\n  Dog(String nm) { name = nm; }\n  Dog(String nm, int yrs) { name = nm; age = yrs; }\n}\ninterface MakeNoArgs {\n  Dog make();\n}\ninterface Make1Arg {\n  Dog make(String nm);\n}\ninterface Make2Args {\n  Dog make(String nm, int age);\n}\npublic class CtorReference {\n  public static void main(String[] args) {\n    MakeNoArgs mna = Dog::new; // [1]\n    Make1Arg m1a = Dog::new;   // [2]\n    Make2Args m2a = Dog::new;  // [3]\n    Dog dn = mna.make();\n    Dog d1 = m1a.make(\"Comet\");\n    Dog d2 = m2a.make(\"Ralph\", 4);\n  }\n}\n```\nDog 有三个构造函数，函数式接口内的 make() 方法反映了构造函数参数列表（ make() 方法名称可以不同）。\n\n注意我们如何对 [1]，[2] 和 [3] 中的每一个使用 Dog :: new。 这三个构造函数只有一个相同名称：:: new，但在每种情况下赋值给不同的接口，编译器可以从中知道具体使用哪个构造函数。\n\n\n# 函数式接口\n现在我们讨论本后的本质. Java是强类型语言, 编译器必须得知每个对象的类型信息, 所以method reference和Lambda表达式都必须被赋值. 通过赋值让编译器推测出准确的类型信息. 比如:\n```java\nx -> x.toString()\n```\n编译器可以轻松地知道返回值肯定是String, 但是x是什么类型呢? Lambda表达式包含类型推导. 再比如:\n```java\n(x, y) -> x + y\n```\n必须当Lambda表达式被指派给某个接口, 才能确定其类型. 比如: \n```java\n@FunctionalInterface\ninterface Functional {\n  String goodbye(String arg);\n}\ninterface FunctionalNoAnn {\n  String goodbye(String arg);\n}\n/*\n@FunctionalInterface\ninterface NotFunctional {\n  String goodbye(String arg);\n  String hello(String arg);\n}\n产生错误信息:\nNotFunctional is not a functional interface\nmultiple non-overriding abstract methods\nfound in interface NotFunctional\n*/\npublic class FunctionalAnnotation {\n  public String goodbye(String arg) {\n    return \"Goodbye, \" + arg;\n  }\n  public static void main(String[] args) {\n    FunctionalAnnotation fa =\n      new FunctionalAnnotation();\n    Functional f = fa::goodbye;\n    FunctionalNoAnn fna = fa::goodbye;\n    // Functional fac = fa; // Incompatible\n    Functional fl = a -> \"Goodbye, \" + a;\n    FunctionalNoAnn fnal = a -> \"Goodbye, \" + a;\n  }\n}\n```\n\n其中, `@FunctionalInterface`是一个可选注解, 没有也行. \n通过以上例子我们可以得知, Lambda表达式被指派的接口只能有一个抽象方法对应. 摘录一段解释\n\n{% blockquote Bruce Eckel, OnJava8 %}\nLook closely at what happens in the definitions of f and fna. Functional and\nFunctionalNoAnn define interfaces. Yet what is assigned is just the method goodbye.\nFirst, this is only a method and not a class. Second, it’s not even a method of a class\nthat implements one of those interfaces. This is a bit of magic that was added to Java\n8: if you assign a method reference or a lambda expression to a functional interface\n(and the types fit), Java will adapt your assignment to the target interface. **Under\nthe covers, the compiler wraps your method reference or lambda expression in an\ninstance of a class that implements the target interface.**\n\nA @FunctionalInterface is also called a Single Abstract Method (SAM) type.\n{% endblockquote %}\n\n\n如果将Lambda表达式作为参数传入, 看流式编程中, `Stream.of(...).map((x, y) -> x + y))`, 其中map方法接收了一个表达式. 查看其源码:\n\n```java\n<R> Stream<R> map(Function<? super T, ? extends R> mapper);\n```\n\n然后, 再查看Function接口:\n```java\npackage java.util.function;\n\nimport java.util.Objects;\n\n/**\n * Represents a function that accepts one argument and produces a result.\n *\n * <p>This is a <a href=\"package-summary.html\">functional interface</a>\n * whose functional method is {@link #apply(Object)}.\n *\n * @param <T> the type of the input to the function  方法输入的类型\n * @param <R> the type of the result of the function 方法输出的类型\n *\n * @since 1.8\n */\n@FunctionalInterface\npublic interface Function<T, R> {\n\n    /**\n     * Applies this function to the given argument.\n     *\n     * @param t the function argument\n     * @return the function result\n     */\n    R apply(T t);\n\n    // ...\n}\n```\n由Function也可以看出其中只有一个抽象方法`apply`, 那么这个肯定与Lambda表达式的格式对应. 方法的输入和输出分别由泛型`<T, R> `与之对应.\n\n那么@FunctionalInterface的意义是什么, 在源码注释中解释很清楚:\n\n```java\npackage java.lang;\n\nimport java.lang.annotation.*;\n\n/**\n * An informative annotation type used to indicate that an interface\n * type declaration is intended to be a <i>functional interface</i> as\n * defined by the Java Language Specification.\n *\n * Conceptually, a functional interface has exactly one abstract\n * method.  Since {@linkplain java.lang.reflect.Method#isDefault()\n * default methods} have an implementation, they are not abstract.  If\n * an interface declares an abstract method overriding one of the\n * public methods of {@code java.lang.Object}, that also does\n * <em>not</em> count toward the interface's abstract method count\n * since any implementation of the interface will have an\n * implementation from {@code java.lang.Object} or elsewhere.\n *\n * <p>Note that instances of functional interfaces can be created with\n * lambda expressions, method references, or constructor references.\n *\n * <p>If a type is annotated with this annotation type, compilers are\n * required to generate an error message unless:\n *\n * <ul>\n * <li> The type is an interface type and not an annotation type, enum, or class.\n * <li> The annotated type satisfies the requirements of a functional interface.\n * </ul>\n *\n * <p>However, the compiler will treat any interface meeting the\n * definition of a functional interface as a functional interface\n * regardless of whether or not a {@code FunctionalInterface}\n * annotation is present on the interface declaration.\n *\n * @jls 4.3.2. The Class Object\n * @jls 9.8 Functional Interfaces\n * @jls 9.4.3 Interface Method Body\n * @since 1.8\n */\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface FunctionalInterface {}\n```\n\n`@FunctionalInterface`是为了检测, 以限制所注释的接口中只能有一个抽象方法.\n\n在`java.util.function`中还有很多函数式接口, 这里就不在列举了.\n\n\n## 高阶函数\n其实就是生成函数的函数, 比如返回一个Lambda表达式.\n```java\npublic Function<String, String> a() {\n\t\treturn s -> s.toLowerCase();\n\t}\n```\n\n## 闭包(Closure)\n一般情况下, 函数执行完成后, 其内部定义的局部变量, 将会被垃圾回收. 如果有一个函数使用函数作用域之外的变量, 并将此函数返回, 这些变量将会在函数中继续存在, 即使母函数已经执行完毕.\n\n```java\nimport java.util.function.IntSupplier;\n\npublic class Closure2 {\n  IntSupplier makeFun(int x) {\n    int i = 0;\n    return () -> x + i;\n  }\n}\n```\nmakeFun方法返回的IntSupplier将i和x进行了\"close over\", 即使makeFun执行完毕, x和i仍然有效, 一般情况下, 它们就被回收了.\n\n此时, 考虑如下情况:\n```java\nimport java.util.function.IntSupplier;\n\npublic class Closure3 {\n  IntSupplier makeFun(int x) {\n    int i = 0;\n    // 在编译时, x++ 和 i++ 都会报错\n    return () -> x++ + i++;\n  }\n}\n```\n*Variable used in lambda expression should be final or effectively final*\nLambda表达式中引用的局部变量必须是final, 或者等同final. 使用时, final可以省略. \n\n那么, 为什么呢?\n考虑在一般情况, 不使用Lambda表达式时, 我们可能会这么写:\n```java\nimport java.util.function.IntSupplier;\n\npublic class Closure3 {\n  void makeFun(int x) {\n    int i = 0;\n    lambda(x, i);\n  }\n  void lambda(int x, int i) {\n      x++;\n      i++;\n  }\n}\n```\nx和i传入lambda时, 一定是一个定量, 不可能是一个变量, 这不符合思维逻辑. 只是Lambda表达式给我们一个将函数返回的机会, 早期的Java版本没有这个特性.\n\n#### 闭包的结论\n```java\nimport java.util.function.*;\npublic class Closure1 {\n  int i;\n  IntSupplier makeFun(int x) {\n    // 一切正常, 因为i是成员, 非局部.\n    return () -> x + i++;\n  }\n}\n```\nLambda可以无限制的引用成员变量(members), 但是当其引用局部变量(local variable)时, 局部变量必须声明为final.\n\n# 总结\nLambda表达式与Method Reference原理上是一样的, 编译器会解析它们, 之后将它们包裹在一个类中, 这个类实现了目标接口. 所以, 当我们去书写Lambda表达式的时候, 编译器也会据此生成代码.\n\n解释的更加仔细一点, 写了一个例子\n```java\ninterface TargetInterface {\n  String apply(String str);\n}\nclass Tool {\n  String connect(String data) {\n    return data + \"<--->\" + data;\n  }\n}\npublic class MethodReferencesNature {\n  public static void main(String[] args) {\n    Tool tool = new Tool();\n    TargetInterface t = tool::connect;\n    System.out.println(t.apply(\"you\"));\n  }\n}\n```\n\n以下这个示例反应了运行时生成字节码的伪代码, `$Example1`在目标接口和类之间搭建了一个桥梁\n```java\n/** 示例: 自动生成的类 */\nclass $Example1 implements TargetInterface {\n  private final Tool tool;\n  $Example1(Tool tool) {\n    this.tool = tool;\n  }\n  @Override\n  public String apply(String data) {\n    return tool.connect(data);\n  }\n}\n\n// 与Method Reference是一样的(省略main方法声明)\n$Example1 example1 = new $Example1(new Tool());\nexample1.apply(\"you\");\n```\n\n那么Lambda表达式, 就更进一步. 首先表达式是一个函数, 函数必须属于某个类. 所以, 生成的字节码时`Tool`类和`$Example1`都生成了, 所以Lambda和Method References是本质是一样的.\n","source":"_posts/java-functional-programming.md","raw":"---\ntitle: Java函数式编程\ndate: 2021-08-04 11:10:25\ncategories:\n- Java\n---\n编程风格可以分为命令式(Imperative)和声明式(Declarative), 它声明了要做什么, 而不是每一步如何做. \n这正是我们在函数式编程中所看到的的.\n\n# Lambda表达式\n从概念上来说, Lambda表达式, 生产的是函数, 而不是类\n但是在JVM上, everything is a class, 但是经过各种幕后操作之后, **使得Lambda看起来像函数**\n```java\ninterface IntCall {\n\tint call(int arg);\n}\n\nclass IntCallImpl implements IntCall {\n\n\t@Override\n\tpublic int call(int arg) {\n\t\tif (arg == 0) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn arg * call(arg - 1);\n\t\t}\n\t}\n}\npublic class FunctionalPrograming {\n\tstatic IntCall fact;\n\n\t/**\n\t * 传统方法实现\n\t */\n\tpublic static void oldApproach() {\n\t\tIntCallImpl intCall = new IntCallImpl();\n\t\tfor (int i = 0; i <= 10; i++) {\n\t\t\tSystem.out.println(\"oldApproach --> \" + intCall.call(i));\n\t\t}\n\t}\n\n\t/**\n\t * 函数式编程实现\n\t */\n\tpublic static void functionalApproach() {\n        // 这里使用Lambda表达式的简洁语法, 但是其底层实现仍然是类和对象, IntCallImpl的步骤可能一步也没有少, 只是看起来像生成了一个函数.\n\t\tfact = n -> n == 0 ? 1 : n * fact.call(n - 1);\n\t\tfor (int i = 0; i <= 10; i++) {\n\t\t\tSystem.out.println(\"functionalApproach --> \" + fact.call(i));\n\t\t}\n\t}\n\n    public static void anonymousInnerClassApproach() {\n        IntCall fact = IntCallImpl::call\n    }\n\n\tpublic static void main(String[] args) {\n\t\tFunctionalPrograming.oldApproach();\n\t\tFunctionalPrograming.functionalApproach();\n\t}\n}\n```\n\n# Mehtod References\n方法引用的语法:\n{% blockquote %}\nA method reference is a class name or an object name, follow by a ::, then the name of the method \n{% endblockquote %}\n\n```java\nclass X {\n   String f() {\n      return \"X::f\";\n   }\n}\n\ninterface MarkString0 {\n   String make();\n}\n\ninterface MarkString1 {\n   String make(X x);\n}\n\npublic class UnboundMethodReferences {\n   public static void main(String[] args) {\n      // MarkString0 n = X::f                             [1]\n      X x = new X();\n      MarkString0 n = x::f;   // method references        [2]\n      System.out.println(n.make());\n\n      \n      MarkString1 m = X::f;   //unbound method references [3]\n      System.out.println(m.make(new X()));\n\n   }\n}\n```\n从逻辑上来将, 方法的引用是指向一个Method类的一个实例, 方法对象必须绑定在某个类的对象上. 按照这个逻辑, 所以`[2]`可以赋值成功, `[1]`不能. `[1]`这种方式, `class X`和`interface MarkString0`中都没有可以创建`X`的对象, 没有对象如何调用f()方法呢? 这就引出Unbound Method References\n\n## Unbound Method References\n对于这种方式(感觉不常用), 我们需要让对应的接口的第一个参数(隐性规定)必须是X. 举一反三, 如下示例:\n```java\nclass This {\n  void two(int i, double d) {}\n  void three(int i, double d, String s) {}\n  void four(int i, double d, String s, char c) {}\n}\ninterface TwoArgs {\n  void call2(This athis, int i, double d);\n}\ninterface ThreeArgs {\n  void call3(This athis, int i, double d, String s);\n}\npublic class MultiUnbound {\n  public static void main(String[] args) {\n    TwoArgs twoargs = This::two;\n    ThreeArgs threeargs = This::three;\n    This athis = new This();\n    twoargs.call2(athis, 11, 3.14);\n    threeargs.call3(athis, 11, 3.14, \"Three\");\n  }\n}\n```\n\n## 构造函数引用\n```java\nclass Dog {\n  String name;\n  int age = -1; // For \"unknown\"\n  Dog() { name = \"stray\"; }\n  Dog(String nm) { name = nm; }\n  Dog(String nm, int yrs) { name = nm; age = yrs; }\n}\ninterface MakeNoArgs {\n  Dog make();\n}\ninterface Make1Arg {\n  Dog make(String nm);\n}\ninterface Make2Args {\n  Dog make(String nm, int age);\n}\npublic class CtorReference {\n  public static void main(String[] args) {\n    MakeNoArgs mna = Dog::new; // [1]\n    Make1Arg m1a = Dog::new;   // [2]\n    Make2Args m2a = Dog::new;  // [3]\n    Dog dn = mna.make();\n    Dog d1 = m1a.make(\"Comet\");\n    Dog d2 = m2a.make(\"Ralph\", 4);\n  }\n}\n```\nDog 有三个构造函数，函数式接口内的 make() 方法反映了构造函数参数列表（ make() 方法名称可以不同）。\n\n注意我们如何对 [1]，[2] 和 [3] 中的每一个使用 Dog :: new。 这三个构造函数只有一个相同名称：:: new，但在每种情况下赋值给不同的接口，编译器可以从中知道具体使用哪个构造函数。\n\n\n# 函数式接口\n现在我们讨论本后的本质. Java是强类型语言, 编译器必须得知每个对象的类型信息, 所以method reference和Lambda表达式都必须被赋值. 通过赋值让编译器推测出准确的类型信息. 比如:\n```java\nx -> x.toString()\n```\n编译器可以轻松地知道返回值肯定是String, 但是x是什么类型呢? Lambda表达式包含类型推导. 再比如:\n```java\n(x, y) -> x + y\n```\n必须当Lambda表达式被指派给某个接口, 才能确定其类型. 比如: \n```java\n@FunctionalInterface\ninterface Functional {\n  String goodbye(String arg);\n}\ninterface FunctionalNoAnn {\n  String goodbye(String arg);\n}\n/*\n@FunctionalInterface\ninterface NotFunctional {\n  String goodbye(String arg);\n  String hello(String arg);\n}\n产生错误信息:\nNotFunctional is not a functional interface\nmultiple non-overriding abstract methods\nfound in interface NotFunctional\n*/\npublic class FunctionalAnnotation {\n  public String goodbye(String arg) {\n    return \"Goodbye, \" + arg;\n  }\n  public static void main(String[] args) {\n    FunctionalAnnotation fa =\n      new FunctionalAnnotation();\n    Functional f = fa::goodbye;\n    FunctionalNoAnn fna = fa::goodbye;\n    // Functional fac = fa; // Incompatible\n    Functional fl = a -> \"Goodbye, \" + a;\n    FunctionalNoAnn fnal = a -> \"Goodbye, \" + a;\n  }\n}\n```\n\n其中, `@FunctionalInterface`是一个可选注解, 没有也行. \n通过以上例子我们可以得知, Lambda表达式被指派的接口只能有一个抽象方法对应. 摘录一段解释\n\n{% blockquote Bruce Eckel, OnJava8 %}\nLook closely at what happens in the definitions of f and fna. Functional and\nFunctionalNoAnn define interfaces. Yet what is assigned is just the method goodbye.\nFirst, this is only a method and not a class. Second, it’s not even a method of a class\nthat implements one of those interfaces. This is a bit of magic that was added to Java\n8: if you assign a method reference or a lambda expression to a functional interface\n(and the types fit), Java will adapt your assignment to the target interface. **Under\nthe covers, the compiler wraps your method reference or lambda expression in an\ninstance of a class that implements the target interface.**\n\nA @FunctionalInterface is also called a Single Abstract Method (SAM) type.\n{% endblockquote %}\n\n\n如果将Lambda表达式作为参数传入, 看流式编程中, `Stream.of(...).map((x, y) -> x + y))`, 其中map方法接收了一个表达式. 查看其源码:\n\n```java\n<R> Stream<R> map(Function<? super T, ? extends R> mapper);\n```\n\n然后, 再查看Function接口:\n```java\npackage java.util.function;\n\nimport java.util.Objects;\n\n/**\n * Represents a function that accepts one argument and produces a result.\n *\n * <p>This is a <a href=\"package-summary.html\">functional interface</a>\n * whose functional method is {@link #apply(Object)}.\n *\n * @param <T> the type of the input to the function  方法输入的类型\n * @param <R> the type of the result of the function 方法输出的类型\n *\n * @since 1.8\n */\n@FunctionalInterface\npublic interface Function<T, R> {\n\n    /**\n     * Applies this function to the given argument.\n     *\n     * @param t the function argument\n     * @return the function result\n     */\n    R apply(T t);\n\n    // ...\n}\n```\n由Function也可以看出其中只有一个抽象方法`apply`, 那么这个肯定与Lambda表达式的格式对应. 方法的输入和输出分别由泛型`<T, R> `与之对应.\n\n那么@FunctionalInterface的意义是什么, 在源码注释中解释很清楚:\n\n```java\npackage java.lang;\n\nimport java.lang.annotation.*;\n\n/**\n * An informative annotation type used to indicate that an interface\n * type declaration is intended to be a <i>functional interface</i> as\n * defined by the Java Language Specification.\n *\n * Conceptually, a functional interface has exactly one abstract\n * method.  Since {@linkplain java.lang.reflect.Method#isDefault()\n * default methods} have an implementation, they are not abstract.  If\n * an interface declares an abstract method overriding one of the\n * public methods of {@code java.lang.Object}, that also does\n * <em>not</em> count toward the interface's abstract method count\n * since any implementation of the interface will have an\n * implementation from {@code java.lang.Object} or elsewhere.\n *\n * <p>Note that instances of functional interfaces can be created with\n * lambda expressions, method references, or constructor references.\n *\n * <p>If a type is annotated with this annotation type, compilers are\n * required to generate an error message unless:\n *\n * <ul>\n * <li> The type is an interface type and not an annotation type, enum, or class.\n * <li> The annotated type satisfies the requirements of a functional interface.\n * </ul>\n *\n * <p>However, the compiler will treat any interface meeting the\n * definition of a functional interface as a functional interface\n * regardless of whether or not a {@code FunctionalInterface}\n * annotation is present on the interface declaration.\n *\n * @jls 4.3.2. The Class Object\n * @jls 9.8 Functional Interfaces\n * @jls 9.4.3 Interface Method Body\n * @since 1.8\n */\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface FunctionalInterface {}\n```\n\n`@FunctionalInterface`是为了检测, 以限制所注释的接口中只能有一个抽象方法.\n\n在`java.util.function`中还有很多函数式接口, 这里就不在列举了.\n\n\n## 高阶函数\n其实就是生成函数的函数, 比如返回一个Lambda表达式.\n```java\npublic Function<String, String> a() {\n\t\treturn s -> s.toLowerCase();\n\t}\n```\n\n## 闭包(Closure)\n一般情况下, 函数执行完成后, 其内部定义的局部变量, 将会被垃圾回收. 如果有一个函数使用函数作用域之外的变量, 并将此函数返回, 这些变量将会在函数中继续存在, 即使母函数已经执行完毕.\n\n```java\nimport java.util.function.IntSupplier;\n\npublic class Closure2 {\n  IntSupplier makeFun(int x) {\n    int i = 0;\n    return () -> x + i;\n  }\n}\n```\nmakeFun方法返回的IntSupplier将i和x进行了\"close over\", 即使makeFun执行完毕, x和i仍然有效, 一般情况下, 它们就被回收了.\n\n此时, 考虑如下情况:\n```java\nimport java.util.function.IntSupplier;\n\npublic class Closure3 {\n  IntSupplier makeFun(int x) {\n    int i = 0;\n    // 在编译时, x++ 和 i++ 都会报错\n    return () -> x++ + i++;\n  }\n}\n```\n*Variable used in lambda expression should be final or effectively final*\nLambda表达式中引用的局部变量必须是final, 或者等同final. 使用时, final可以省略. \n\n那么, 为什么呢?\n考虑在一般情况, 不使用Lambda表达式时, 我们可能会这么写:\n```java\nimport java.util.function.IntSupplier;\n\npublic class Closure3 {\n  void makeFun(int x) {\n    int i = 0;\n    lambda(x, i);\n  }\n  void lambda(int x, int i) {\n      x++;\n      i++;\n  }\n}\n```\nx和i传入lambda时, 一定是一个定量, 不可能是一个变量, 这不符合思维逻辑. 只是Lambda表达式给我们一个将函数返回的机会, 早期的Java版本没有这个特性.\n\n#### 闭包的结论\n```java\nimport java.util.function.*;\npublic class Closure1 {\n  int i;\n  IntSupplier makeFun(int x) {\n    // 一切正常, 因为i是成员, 非局部.\n    return () -> x + i++;\n  }\n}\n```\nLambda可以无限制的引用成员变量(members), 但是当其引用局部变量(local variable)时, 局部变量必须声明为final.\n\n# 总结\nLambda表达式与Method Reference原理上是一样的, 编译器会解析它们, 之后将它们包裹在一个类中, 这个类实现了目标接口. 所以, 当我们去书写Lambda表达式的时候, 编译器也会据此生成代码.\n\n解释的更加仔细一点, 写了一个例子\n```java\ninterface TargetInterface {\n  String apply(String str);\n}\nclass Tool {\n  String connect(String data) {\n    return data + \"<--->\" + data;\n  }\n}\npublic class MethodReferencesNature {\n  public static void main(String[] args) {\n    Tool tool = new Tool();\n    TargetInterface t = tool::connect;\n    System.out.println(t.apply(\"you\"));\n  }\n}\n```\n\n以下这个示例反应了运行时生成字节码的伪代码, `$Example1`在目标接口和类之间搭建了一个桥梁\n```java\n/** 示例: 自动生成的类 */\nclass $Example1 implements TargetInterface {\n  private final Tool tool;\n  $Example1(Tool tool) {\n    this.tool = tool;\n  }\n  @Override\n  public String apply(String data) {\n    return tool.connect(data);\n  }\n}\n\n// 与Method Reference是一样的(省略main方法声明)\n$Example1 example1 = new $Example1(new Tool());\nexample1.apply(\"you\");\n```\n\n那么Lambda表达式, 就更进一步. 首先表达式是一个函数, 函数必须属于某个类. 所以, 生成的字节码时`Tool`类和`$Example1`都生成了, 所以Lambda和Method References是本质是一样的.\n","slug":"java-functional-programming","published":1,"updated":"2021-12-30T03:01:37.188Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxsdzpyj000gxotgc1s61qa7","content":"<p>编程风格可以分为命令式(Imperative)和声明式(Declarative), 它声明了要做什么, 而不是每一步如何做.<br>这正是我们在函数式编程中所看到的的.</p>\n<h1 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h1><p>从概念上来说, Lambda表达式, 生产的是函数, 而不是类<br>但是在JVM上, everything is a class, 但是经过各种幕后操作之后, <strong>使得Lambda看起来像函数</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IntCall</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">call</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntCallImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">IntCall</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">call</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (arg == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> arg * call(arg - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FunctionalPrograming</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> IntCall fact;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 传统方法实现</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">oldApproach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tIntCallImpl intCall = <span class=\"keyword\">new</span> IntCallImpl();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">&quot;oldApproach --&gt; &quot;</span> + intCall.call(i));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 函数式编程实现</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">functionalApproach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里使用Lambda表达式的简洁语法, 但是其底层实现仍然是类和对象, IntCallImpl的步骤可能一步也没有少, 只是看起来像生成了一个函数.</span></span><br><span class=\"line\">\t\tfact = n -&gt; n == <span class=\"number\">0</span> ? <span class=\"number\">1</span> : n * fact.call(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">&quot;functionalApproach --&gt; &quot;</span> + fact.call(i));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">anonymousInnerClassApproach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        IntCall fact = IntCallImpl::call</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tFunctionalPrograming.oldApproach();</span><br><span class=\"line\">\t\tFunctionalPrograming.functionalApproach();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Mehtod-References\"><a href=\"#Mehtod-References\" class=\"headerlink\" title=\"Mehtod References\"></a>Mehtod References</h1><p>方法引用的语法:</p>\n<blockquote><p>A method reference is a class name or an object name, follow by a ::, then the name of the method </p>\n</blockquote>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\">String <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;X::f&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MarkString0</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\">String <span class=\"title\">make</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MarkString1</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\">String <span class=\"title\">make</span><span class=\"params\">(X x)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UnboundMethodReferences</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// MarkString0 n = X::f                             [1]</span></span><br><span class=\"line\">      X x = <span class=\"keyword\">new</span> X();</span><br><span class=\"line\">      MarkString0 n = x::f;   <span class=\"comment\">// method references        [2]</span></span><br><span class=\"line\">      System.out.println(n.make());</span><br><span class=\"line\"></span><br><span class=\"line\">      </span><br><span class=\"line\">      MarkString1 m = X::f;   <span class=\"comment\">//unbound method references [3]</span></span><br><span class=\"line\">      System.out.println(m.make(<span class=\"keyword\">new</span> X()));</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从逻辑上来将, 方法的引用是指向一个Method类的一个实例, 方法对象必须绑定在某个类的对象上. 按照这个逻辑, 所以<code>[2]</code>可以赋值成功, <code>[1]</code>不能. <code>[1]</code>这种方式, <code>class X</code>和<code>interface MarkString0</code>中都没有可以创建<code>X</code>的对象, 没有对象如何调用f()方法呢? 这就引出Unbound Method References</p>\n<h2 id=\"Unbound-Method-References\"><a href=\"#Unbound-Method-References\" class=\"headerlink\" title=\"Unbound Method References\"></a>Unbound Method References</h2><p>对于这种方式(感觉不常用), 我们需要让对应的接口的第一个参数(隐性规定)必须是X. 举一反三, 如下示例:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">This</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">two</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">double</span> d)</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">three</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">double</span> d, String s)</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">four</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">double</span> d, String s, <span class=\"keyword\">char</span> c)</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TwoArgs</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">call2</span><span class=\"params\">(This athis, <span class=\"keyword\">int</span> i, <span class=\"keyword\">double</span> d)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ThreeArgs</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">call3</span><span class=\"params\">(This athis, <span class=\"keyword\">int</span> i, <span class=\"keyword\">double</span> d, String s)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultiUnbound</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    TwoArgs twoargs = This::two;</span><br><span class=\"line\">    ThreeArgs threeargs = This::three;</span><br><span class=\"line\">    This athis = <span class=\"keyword\">new</span> This();</span><br><span class=\"line\">    twoargs.call2(athis, <span class=\"number\">11</span>, <span class=\"number\">3.14</span>);</span><br><span class=\"line\">    threeargs.call3(athis, <span class=\"number\">11</span>, <span class=\"number\">3.14</span>, <span class=\"string\">&quot;Three&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"构造函数引用\"><a href=\"#构造函数引用\" class=\"headerlink\" title=\"构造函数引用\"></a>构造函数引用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> </span>&#123;</span><br><span class=\"line\">  String name;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> age = -<span class=\"number\">1</span>; <span class=\"comment\">// For &quot;unknown&quot;</span></span><br><span class=\"line\">  Dog() &#123; name = <span class=\"string\">&quot;stray&quot;</span>; &#125;</span><br><span class=\"line\">  Dog(String nm) &#123; name = nm; &#125;</span><br><span class=\"line\">  Dog(String nm, <span class=\"keyword\">int</span> yrs) &#123; name = nm; age = yrs; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MakeNoArgs</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">Dog <span class=\"title\">make</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Make1Arg</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">Dog <span class=\"title\">make</span><span class=\"params\">(String nm)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Make2Args</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">Dog <span class=\"title\">make</span><span class=\"params\">(String nm, <span class=\"keyword\">int</span> age)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CtorReference</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    MakeNoArgs mna = Dog::<span class=\"keyword\">new</span>; <span class=\"comment\">// [1]</span></span><br><span class=\"line\">    Make1Arg m1a = Dog::<span class=\"keyword\">new</span>;   <span class=\"comment\">// [2]</span></span><br><span class=\"line\">    Make2Args m2a = Dog::<span class=\"keyword\">new</span>;  <span class=\"comment\">// [3]</span></span><br><span class=\"line\">    Dog dn = mna.make();</span><br><span class=\"line\">    Dog d1 = m1a.make(<span class=\"string\">&quot;Comet&quot;</span>);</span><br><span class=\"line\">    Dog d2 = m2a.make(<span class=\"string\">&quot;Ralph&quot;</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Dog 有三个构造函数，函数式接口内的 make() 方法反映了构造函数参数列表（ make() 方法名称可以不同）。</p>\n<p>注意我们如何对 [1]，[2] 和 [3] 中的每一个使用 Dog :: new。 这三个构造函数只有一个相同名称：:: new，但在每种情况下赋值给不同的接口，编译器可以从中知道具体使用哪个构造函数。</p>\n<h1 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h1><p>现在我们讨论本后的本质. Java是强类型语言, 编译器必须得知每个对象的类型信息, 所以method reference和Lambda表达式都必须被赋值. 通过赋值让编译器推测出准确的类型信息. 比如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x -&gt; x.toString()</span><br></pre></td></tr></table></figure>\n<p>编译器可以轻松地知道返回值肯定是String, 但是x是什么类型呢? Lambda表达式包含类型推导. 再比如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(x, y) -&gt; x + y</span><br></pre></td></tr></table></figure>\n<p>必须当Lambda表达式被指派给某个接口, 才能确定其类型. 比如: </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Functional</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">String <span class=\"title\">goodbye</span><span class=\"params\">(String arg)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">FunctionalNoAnn</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">String <span class=\"title\">goodbye</span><span class=\"params\">(String arg)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"comment\">interface NotFunctional &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  String goodbye(String arg);</span></span><br><span class=\"line\"><span class=\"comment\">  String hello(String arg);</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">产生错误信息:</span></span><br><span class=\"line\"><span class=\"comment\">NotFunctional is not a functional interface</span></span><br><span class=\"line\"><span class=\"comment\">multiple non-overriding abstract methods</span></span><br><span class=\"line\"><span class=\"comment\">found in interface NotFunctional</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FunctionalAnnotation</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">goodbye</span><span class=\"params\">(String arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Goodbye, &quot;</span> + arg;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    FunctionalAnnotation fa =</span><br><span class=\"line\">      <span class=\"keyword\">new</span> FunctionalAnnotation();</span><br><span class=\"line\">    Functional f = fa::goodbye;</span><br><span class=\"line\">    FunctionalNoAnn fna = fa::goodbye;</span><br><span class=\"line\">    <span class=\"comment\">// Functional fac = fa; // Incompatible</span></span><br><span class=\"line\">    Functional fl = a -&gt; <span class=\"string\">&quot;Goodbye, &quot;</span> + a;</span><br><span class=\"line\">    FunctionalNoAnn fnal = a -&gt; <span class=\"string\">&quot;Goodbye, &quot;</span> + a;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中, <code>@FunctionalInterface</code>是一个可选注解, 没有也行.<br>通过以上例子我们可以得知, Lambda表达式被指派的接口只能有一个抽象方法对应. 摘录一段解释</p>\n<blockquote><p>Look closely at what happens in the definitions of f and fna. Functional and<br>FunctionalNoAnn define interfaces. Yet what is assigned is just the method goodbye.<br>First, this is only a method and not a class. Second, it’s not even a method of a class<br>that implements one of those interfaces. This is a bit of magic that was added to Java<br>8: if you assign a method reference or a lambda expression to a functional interface<br>(and the types fit), Java will adapt your assignment to the target interface. <strong>Under<br>the covers, the compiler wraps your method reference or lambda expression in an<br>instance of a class that implements the target interface.</strong></p>\n<p>A @FunctionalInterface is also called a Single Abstract Method (SAM) type.</p>\n<footer><strong>Bruce Eckel</strong><cite>OnJava8</cite></footer></blockquote>\n\n\n<p>如果将Lambda表达式作为参数传入, 看流式编程中, <code>Stream.of(...).map((x, y) -&gt; x + y))</code>, 其中map方法接收了一个表达式. 查看其源码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;R&gt; <span class=\"function\">Stream&lt;R&gt; <span class=\"title\">map</span><span class=\"params\">(Function&lt;? <span class=\"keyword\">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>然后, 再查看Function接口:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> java.util.function;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Objects;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Represents a function that accepts one argument and produces a result.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * whose functional method is &#123;<span class=\"doctag\">@link</span> #apply(Object)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &lt;T&gt; the type of the input to the function  方法输入的类型</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &lt;R&gt; the type of the result of the function 方法输出的类型</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 1.8</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Function</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">R</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Applies this function to the given argument.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> t the function argument</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> the function result</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">R <span class=\"title\">apply</span><span class=\"params\">(T t)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由Function也可以看出其中只有一个抽象方法<code>apply</code>, 那么这个肯定与Lambda表达式的格式对应. 方法的输入和输出分别由泛型<code>&lt;T, R&gt; </code>与之对应.</p>\n<p>那么@FunctionalInterface的意义是什么, 在源码注释中解释很清楚:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> java.lang;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * An informative annotation type used to indicate that an interface</span></span><br><span class=\"line\"><span class=\"comment\"> * type declaration is intended to be a &lt;i&gt;functional interface&lt;/i&gt; as</span></span><br><span class=\"line\"><span class=\"comment\"> * defined by the Java Language Specification.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Conceptually, a functional interface has exactly one abstract</span></span><br><span class=\"line\"><span class=\"comment\"> * method.  Since &#123;<span class=\"doctag\">@linkplain</span> java.lang.reflect.Method#isDefault()</span></span><br><span class=\"line\"><span class=\"comment\"> * default methods&#125; have an implementation, they are not abstract.  If</span></span><br><span class=\"line\"><span class=\"comment\"> * an interface declares an abstract method overriding one of the</span></span><br><span class=\"line\"><span class=\"comment\"> * public methods of &#123;<span class=\"doctag\">@code</span> java.lang.Object&#125;, that also does</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;em&gt;not&lt;/em&gt; count toward the interface&#x27;s abstract method count</span></span><br><span class=\"line\"><span class=\"comment\"> * since any implementation of the interface will have an</span></span><br><span class=\"line\"><span class=\"comment\"> * implementation from &#123;<span class=\"doctag\">@code</span> java.lang.Object&#125; or elsewhere.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;Note that instances of functional interfaces can be created with</span></span><br><span class=\"line\"><span class=\"comment\"> * lambda expressions, method references, or constructor references.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;If a type is annotated with this annotation type, compilers are</span></span><br><span class=\"line\"><span class=\"comment\"> * required to generate an error message unless:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;li&gt; The type is an interface type and not an annotation type, enum, or class.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;li&gt; The annotated type satisfies the requirements of a functional interface.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;However, the compiler will treat any interface meeting the</span></span><br><span class=\"line\"><span class=\"comment\"> * definition of a functional interface as a functional interface</span></span><br><span class=\"line\"><span class=\"comment\"> * regardless of whether or not a &#123;<span class=\"doctag\">@code</span> FunctionalInterface&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * annotation is present on the interface declaration.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@jls</span> 4.3.2. The Class Object</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@jls</span> 9.8 Functional Interfaces</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@jls</span> 9.4.3 Interface Method Body</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 1.8</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> FunctionalInterface &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>@FunctionalInterface</code>是为了检测, 以限制所注释的接口中只能有一个抽象方法.</p>\n<p>在<code>java.util.function</code>中还有很多函数式接口, 这里就不在列举了.</p>\n<h2 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h2><p>其实就是生成函数的函数, 比如返回一个Lambda表达式.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Function&lt;String, String&gt; <span class=\"title\">a</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s -&gt; s.toLowerCase();</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"闭包-Closure\"><a href=\"#闭包-Closure\" class=\"headerlink\" title=\"闭包(Closure)\"></a>闭包(Closure)</h2><p>一般情况下, 函数执行完成后, 其内部定义的局部变量, 将会被垃圾回收. 如果有一个函数使用函数作用域之外的变量, 并将此函数返回, 这些变量将会在函数中继续存在, 即使母函数已经执行完毕.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.IntSupplier;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Closure2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">IntSupplier <span class=\"title\">makeFun</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> () -&gt; x + i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>makeFun方法返回的IntSupplier将i和x进行了”close over”, 即使makeFun执行完毕, x和i仍然有效, 一般情况下, 它们就被回收了.</p>\n<p>此时, 考虑如下情况:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.IntSupplier;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Closure3</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">IntSupplier <span class=\"title\">makeFun</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 在编译时, x++ 和 i++ 都会报错</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> () -&gt; x++ + i++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>Variable used in lambda expression should be final or effectively final</em><br>Lambda表达式中引用的局部变量必须是final, 或者等同final. 使用时, final可以省略. </p>\n<p>那么, 为什么呢?<br>考虑在一般情况, 不使用Lambda表达式时, 我们可能会这么写:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.IntSupplier;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Closure3</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">makeFun</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    lambda(x, i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lambda</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">      x++;</span><br><span class=\"line\">      i++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>x和i传入lambda时, 一定是一个定量, 不可能是一个变量, 这不符合思维逻辑. 只是Lambda表达式给我们一个将函数返回的机会, 早期的Java版本没有这个特性.</p>\n<h4 id=\"闭包的结论\"><a href=\"#闭包的结论\" class=\"headerlink\" title=\"闭包的结论\"></a>闭包的结论</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.*;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Closure1</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  <span class=\"function\">IntSupplier <span class=\"title\">makeFun</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 一切正常, 因为i是成员, 非局部.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> () -&gt; x + i++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Lambda可以无限制的引用成员变量(members), 但是当其引用局部变量(local variable)时, 局部变量必须声明为final.</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>Lambda表达式与Method Reference原理上是一样的, 编译器会解析它们, 之后将它们包裹在一个类中, 这个类实现了目标接口. 所以, 当我们去书写Lambda表达式的时候, 编译器也会据此生成代码.</p>\n<p>解释的更加仔细一点, 写了一个例子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TargetInterface</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">String <span class=\"title\">apply</span><span class=\"params\">(String str)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tool</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">String <span class=\"title\">connect</span><span class=\"params\">(String data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data + <span class=\"string\">&quot;&lt;---&gt;&quot;</span> + data;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MethodReferencesNature</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Tool tool = <span class=\"keyword\">new</span> Tool();</span><br><span class=\"line\">    TargetInterface t = tool::connect;</span><br><span class=\"line\">    System.out.println(t.apply(<span class=\"string\">&quot;you&quot;</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以下这个示例反应了运行时生成字节码的伪代码, <code>$Example1</code>在目标接口和类之间搭建了一个桥梁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 示例: 自动生成的类 */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> $<span class=\"title\">Example1</span> <span class=\"keyword\">implements</span> <span class=\"title\">TargetInterface</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Tool tool;</span><br><span class=\"line\">  $Example1(Tool tool) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.tool = tool;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">apply</span><span class=\"params\">(String data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tool.connect(data);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 与Method Reference是一样的(省略main方法声明)</span></span><br><span class=\"line\">$Example1 example1 = <span class=\"keyword\">new</span> $Example1(<span class=\"keyword\">new</span> Tool());</span><br><span class=\"line\">example1.apply(<span class=\"string\">&quot;you&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>那么Lambda表达式, 就更进一步. 首先表达式是一个函数, 函数必须属于某个类. 所以, 生成的字节码时<code>Tool</code>类和<code>$Example1</code>都生成了, 所以Lambda和Method References是本质是一样的.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>编程风格可以分为命令式(Imperative)和声明式(Declarative), 它声明了要做什么, 而不是每一步如何做.<br>这正是我们在函数式编程中所看到的的.</p>\n<h1 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h1><p>从概念上来说, Lambda表达式, 生产的是函数, 而不是类<br>但是在JVM上, everything is a class, 但是经过各种幕后操作之后, <strong>使得Lambda看起来像函数</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IntCall</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">call</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntCallImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">IntCall</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">call</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (arg == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> arg * call(arg - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FunctionalPrograming</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> IntCall fact;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 传统方法实现</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">oldApproach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tIntCallImpl intCall = <span class=\"keyword\">new</span> IntCallImpl();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">&quot;oldApproach --&gt; &quot;</span> + intCall.call(i));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 函数式编程实现</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">functionalApproach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里使用Lambda表达式的简洁语法, 但是其底层实现仍然是类和对象, IntCallImpl的步骤可能一步也没有少, 只是看起来像生成了一个函数.</span></span><br><span class=\"line\">\t\tfact = n -&gt; n == <span class=\"number\">0</span> ? <span class=\"number\">1</span> : n * fact.call(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">&quot;functionalApproach --&gt; &quot;</span> + fact.call(i));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">anonymousInnerClassApproach</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        IntCall fact = IntCallImpl::call</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tFunctionalPrograming.oldApproach();</span><br><span class=\"line\">\t\tFunctionalPrograming.functionalApproach();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Mehtod-References\"><a href=\"#Mehtod-References\" class=\"headerlink\" title=\"Mehtod References\"></a>Mehtod References</h1><p>方法引用的语法:</p>\n<blockquote><p>A method reference is a class name or an object name, follow by a ::, then the name of the method </p>\n</blockquote>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\">String <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;X::f&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MarkString0</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\">String <span class=\"title\">make</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MarkString1</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\">String <span class=\"title\">make</span><span class=\"params\">(X x)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UnboundMethodReferences</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// MarkString0 n = X::f                             [1]</span></span><br><span class=\"line\">      X x = <span class=\"keyword\">new</span> X();</span><br><span class=\"line\">      MarkString0 n = x::f;   <span class=\"comment\">// method references        [2]</span></span><br><span class=\"line\">      System.out.println(n.make());</span><br><span class=\"line\"></span><br><span class=\"line\">      </span><br><span class=\"line\">      MarkString1 m = X::f;   <span class=\"comment\">//unbound method references [3]</span></span><br><span class=\"line\">      System.out.println(m.make(<span class=\"keyword\">new</span> X()));</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从逻辑上来将, 方法的引用是指向一个Method类的一个实例, 方法对象必须绑定在某个类的对象上. 按照这个逻辑, 所以<code>[2]</code>可以赋值成功, <code>[1]</code>不能. <code>[1]</code>这种方式, <code>class X</code>和<code>interface MarkString0</code>中都没有可以创建<code>X</code>的对象, 没有对象如何调用f()方法呢? 这就引出Unbound Method References</p>\n<h2 id=\"Unbound-Method-References\"><a href=\"#Unbound-Method-References\" class=\"headerlink\" title=\"Unbound Method References\"></a>Unbound Method References</h2><p>对于这种方式(感觉不常用), 我们需要让对应的接口的第一个参数(隐性规定)必须是X. 举一反三, 如下示例:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">This</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">two</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">double</span> d)</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">three</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">double</span> d, String s)</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">four</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">double</span> d, String s, <span class=\"keyword\">char</span> c)</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TwoArgs</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">call2</span><span class=\"params\">(This athis, <span class=\"keyword\">int</span> i, <span class=\"keyword\">double</span> d)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ThreeArgs</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">call3</span><span class=\"params\">(This athis, <span class=\"keyword\">int</span> i, <span class=\"keyword\">double</span> d, String s)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultiUnbound</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    TwoArgs twoargs = This::two;</span><br><span class=\"line\">    ThreeArgs threeargs = This::three;</span><br><span class=\"line\">    This athis = <span class=\"keyword\">new</span> This();</span><br><span class=\"line\">    twoargs.call2(athis, <span class=\"number\">11</span>, <span class=\"number\">3.14</span>);</span><br><span class=\"line\">    threeargs.call3(athis, <span class=\"number\">11</span>, <span class=\"number\">3.14</span>, <span class=\"string\">&quot;Three&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"构造函数引用\"><a href=\"#构造函数引用\" class=\"headerlink\" title=\"构造函数引用\"></a>构造函数引用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> </span>&#123;</span><br><span class=\"line\">  String name;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> age = -<span class=\"number\">1</span>; <span class=\"comment\">// For &quot;unknown&quot;</span></span><br><span class=\"line\">  Dog() &#123; name = <span class=\"string\">&quot;stray&quot;</span>; &#125;</span><br><span class=\"line\">  Dog(String nm) &#123; name = nm; &#125;</span><br><span class=\"line\">  Dog(String nm, <span class=\"keyword\">int</span> yrs) &#123; name = nm; age = yrs; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MakeNoArgs</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">Dog <span class=\"title\">make</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Make1Arg</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">Dog <span class=\"title\">make</span><span class=\"params\">(String nm)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Make2Args</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">Dog <span class=\"title\">make</span><span class=\"params\">(String nm, <span class=\"keyword\">int</span> age)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CtorReference</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    MakeNoArgs mna = Dog::<span class=\"keyword\">new</span>; <span class=\"comment\">// [1]</span></span><br><span class=\"line\">    Make1Arg m1a = Dog::<span class=\"keyword\">new</span>;   <span class=\"comment\">// [2]</span></span><br><span class=\"line\">    Make2Args m2a = Dog::<span class=\"keyword\">new</span>;  <span class=\"comment\">// [3]</span></span><br><span class=\"line\">    Dog dn = mna.make();</span><br><span class=\"line\">    Dog d1 = m1a.make(<span class=\"string\">&quot;Comet&quot;</span>);</span><br><span class=\"line\">    Dog d2 = m2a.make(<span class=\"string\">&quot;Ralph&quot;</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Dog 有三个构造函数，函数式接口内的 make() 方法反映了构造函数参数列表（ make() 方法名称可以不同）。</p>\n<p>注意我们如何对 [1]，[2] 和 [3] 中的每一个使用 Dog :: new。 这三个构造函数只有一个相同名称：:: new，但在每种情况下赋值给不同的接口，编译器可以从中知道具体使用哪个构造函数。</p>\n<h1 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h1><p>现在我们讨论本后的本质. Java是强类型语言, 编译器必须得知每个对象的类型信息, 所以method reference和Lambda表达式都必须被赋值. 通过赋值让编译器推测出准确的类型信息. 比如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x -&gt; x.toString()</span><br></pre></td></tr></table></figure>\n<p>编译器可以轻松地知道返回值肯定是String, 但是x是什么类型呢? Lambda表达式包含类型推导. 再比如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(x, y) -&gt; x + y</span><br></pre></td></tr></table></figure>\n<p>必须当Lambda表达式被指派给某个接口, 才能确定其类型. 比如: </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Functional</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">String <span class=\"title\">goodbye</span><span class=\"params\">(String arg)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">FunctionalNoAnn</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">String <span class=\"title\">goodbye</span><span class=\"params\">(String arg)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"comment\">interface NotFunctional &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  String goodbye(String arg);</span></span><br><span class=\"line\"><span class=\"comment\">  String hello(String arg);</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">产生错误信息:</span></span><br><span class=\"line\"><span class=\"comment\">NotFunctional is not a functional interface</span></span><br><span class=\"line\"><span class=\"comment\">multiple non-overriding abstract methods</span></span><br><span class=\"line\"><span class=\"comment\">found in interface NotFunctional</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FunctionalAnnotation</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">goodbye</span><span class=\"params\">(String arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Goodbye, &quot;</span> + arg;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    FunctionalAnnotation fa =</span><br><span class=\"line\">      <span class=\"keyword\">new</span> FunctionalAnnotation();</span><br><span class=\"line\">    Functional f = fa::goodbye;</span><br><span class=\"line\">    FunctionalNoAnn fna = fa::goodbye;</span><br><span class=\"line\">    <span class=\"comment\">// Functional fac = fa; // Incompatible</span></span><br><span class=\"line\">    Functional fl = a -&gt; <span class=\"string\">&quot;Goodbye, &quot;</span> + a;</span><br><span class=\"line\">    FunctionalNoAnn fnal = a -&gt; <span class=\"string\">&quot;Goodbye, &quot;</span> + a;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中, <code>@FunctionalInterface</code>是一个可选注解, 没有也行.<br>通过以上例子我们可以得知, Lambda表达式被指派的接口只能有一个抽象方法对应. 摘录一段解释</p>\n<blockquote><p>Look closely at what happens in the definitions of f and fna. Functional and<br>FunctionalNoAnn define interfaces. Yet what is assigned is just the method goodbye.<br>First, this is only a method and not a class. Second, it’s not even a method of a class<br>that implements one of those interfaces. This is a bit of magic that was added to Java<br>8: if you assign a method reference or a lambda expression to a functional interface<br>(and the types fit), Java will adapt your assignment to the target interface. <strong>Under<br>the covers, the compiler wraps your method reference or lambda expression in an<br>instance of a class that implements the target interface.</strong></p>\n<p>A @FunctionalInterface is also called a Single Abstract Method (SAM) type.</p>\n<footer><strong>Bruce Eckel</strong><cite>OnJava8</cite></footer></blockquote>\n\n\n<p>如果将Lambda表达式作为参数传入, 看流式编程中, <code>Stream.of(...).map((x, y) -&gt; x + y))</code>, 其中map方法接收了一个表达式. 查看其源码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;R&gt; <span class=\"function\">Stream&lt;R&gt; <span class=\"title\">map</span><span class=\"params\">(Function&lt;? <span class=\"keyword\">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>然后, 再查看Function接口:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> java.util.function;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Objects;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Represents a function that accepts one argument and produces a result.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * whose functional method is &#123;<span class=\"doctag\">@link</span> #apply(Object)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &lt;T&gt; the type of the input to the function  方法输入的类型</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &lt;R&gt; the type of the result of the function 方法输出的类型</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 1.8</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Function</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">R</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Applies this function to the given argument.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> t the function argument</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> the function result</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">R <span class=\"title\">apply</span><span class=\"params\">(T t)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由Function也可以看出其中只有一个抽象方法<code>apply</code>, 那么这个肯定与Lambda表达式的格式对应. 方法的输入和输出分别由泛型<code>&lt;T, R&gt; </code>与之对应.</p>\n<p>那么@FunctionalInterface的意义是什么, 在源码注释中解释很清楚:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> java.lang;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * An informative annotation type used to indicate that an interface</span></span><br><span class=\"line\"><span class=\"comment\"> * type declaration is intended to be a &lt;i&gt;functional interface&lt;/i&gt; as</span></span><br><span class=\"line\"><span class=\"comment\"> * defined by the Java Language Specification.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Conceptually, a functional interface has exactly one abstract</span></span><br><span class=\"line\"><span class=\"comment\"> * method.  Since &#123;<span class=\"doctag\">@linkplain</span> java.lang.reflect.Method#isDefault()</span></span><br><span class=\"line\"><span class=\"comment\"> * default methods&#125; have an implementation, they are not abstract.  If</span></span><br><span class=\"line\"><span class=\"comment\"> * an interface declares an abstract method overriding one of the</span></span><br><span class=\"line\"><span class=\"comment\"> * public methods of &#123;<span class=\"doctag\">@code</span> java.lang.Object&#125;, that also does</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;em&gt;not&lt;/em&gt; count toward the interface&#x27;s abstract method count</span></span><br><span class=\"line\"><span class=\"comment\"> * since any implementation of the interface will have an</span></span><br><span class=\"line\"><span class=\"comment\"> * implementation from &#123;<span class=\"doctag\">@code</span> java.lang.Object&#125; or elsewhere.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;Note that instances of functional interfaces can be created with</span></span><br><span class=\"line\"><span class=\"comment\"> * lambda expressions, method references, or constructor references.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;If a type is annotated with this annotation type, compilers are</span></span><br><span class=\"line\"><span class=\"comment\"> * required to generate an error message unless:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;li&gt; The type is an interface type and not an annotation type, enum, or class.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;li&gt; The annotated type satisfies the requirements of a functional interface.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;However, the compiler will treat any interface meeting the</span></span><br><span class=\"line\"><span class=\"comment\"> * definition of a functional interface as a functional interface</span></span><br><span class=\"line\"><span class=\"comment\"> * regardless of whether or not a &#123;<span class=\"doctag\">@code</span> FunctionalInterface&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * annotation is present on the interface declaration.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@jls</span> 4.3.2. The Class Object</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@jls</span> 9.8 Functional Interfaces</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@jls</span> 9.4.3 Interface Method Body</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 1.8</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> FunctionalInterface &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>@FunctionalInterface</code>是为了检测, 以限制所注释的接口中只能有一个抽象方法.</p>\n<p>在<code>java.util.function</code>中还有很多函数式接口, 这里就不在列举了.</p>\n<h2 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h2><p>其实就是生成函数的函数, 比如返回一个Lambda表达式.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Function&lt;String, String&gt; <span class=\"title\">a</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s -&gt; s.toLowerCase();</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"闭包-Closure\"><a href=\"#闭包-Closure\" class=\"headerlink\" title=\"闭包(Closure)\"></a>闭包(Closure)</h2><p>一般情况下, 函数执行完成后, 其内部定义的局部变量, 将会被垃圾回收. 如果有一个函数使用函数作用域之外的变量, 并将此函数返回, 这些变量将会在函数中继续存在, 即使母函数已经执行完毕.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.IntSupplier;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Closure2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">IntSupplier <span class=\"title\">makeFun</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> () -&gt; x + i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>makeFun方法返回的IntSupplier将i和x进行了”close over”, 即使makeFun执行完毕, x和i仍然有效, 一般情况下, 它们就被回收了.</p>\n<p>此时, 考虑如下情况:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.IntSupplier;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Closure3</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">IntSupplier <span class=\"title\">makeFun</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 在编译时, x++ 和 i++ 都会报错</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> () -&gt; x++ + i++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>Variable used in lambda expression should be final or effectively final</em><br>Lambda表达式中引用的局部变量必须是final, 或者等同final. 使用时, final可以省略. </p>\n<p>那么, 为什么呢?<br>考虑在一般情况, 不使用Lambda表达式时, 我们可能会这么写:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.IntSupplier;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Closure3</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">makeFun</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    lambda(x, i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lambda</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">      x++;</span><br><span class=\"line\">      i++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>x和i传入lambda时, 一定是一个定量, 不可能是一个变量, 这不符合思维逻辑. 只是Lambda表达式给我们一个将函数返回的机会, 早期的Java版本没有这个特性.</p>\n<h4 id=\"闭包的结论\"><a href=\"#闭包的结论\" class=\"headerlink\" title=\"闭包的结论\"></a>闭包的结论</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.*;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Closure1</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  <span class=\"function\">IntSupplier <span class=\"title\">makeFun</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 一切正常, 因为i是成员, 非局部.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> () -&gt; x + i++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Lambda可以无限制的引用成员变量(members), 但是当其引用局部变量(local variable)时, 局部变量必须声明为final.</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>Lambda表达式与Method Reference原理上是一样的, 编译器会解析它们, 之后将它们包裹在一个类中, 这个类实现了目标接口. 所以, 当我们去书写Lambda表达式的时候, 编译器也会据此生成代码.</p>\n<p>解释的更加仔细一点, 写了一个例子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TargetInterface</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">String <span class=\"title\">apply</span><span class=\"params\">(String str)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tool</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">String <span class=\"title\">connect</span><span class=\"params\">(String data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data + <span class=\"string\">&quot;&lt;---&gt;&quot;</span> + data;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MethodReferencesNature</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Tool tool = <span class=\"keyword\">new</span> Tool();</span><br><span class=\"line\">    TargetInterface t = tool::connect;</span><br><span class=\"line\">    System.out.println(t.apply(<span class=\"string\">&quot;you&quot;</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以下这个示例反应了运行时生成字节码的伪代码, <code>$Example1</code>在目标接口和类之间搭建了一个桥梁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 示例: 自动生成的类 */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> $<span class=\"title\">Example1</span> <span class=\"keyword\">implements</span> <span class=\"title\">TargetInterface</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Tool tool;</span><br><span class=\"line\">  $Example1(Tool tool) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.tool = tool;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">apply</span><span class=\"params\">(String data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tool.connect(data);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 与Method Reference是一样的(省略main方法声明)</span></span><br><span class=\"line\">$Example1 example1 = <span class=\"keyword\">new</span> $Example1(<span class=\"keyword\">new</span> Tool());</span><br><span class=\"line\">example1.apply(<span class=\"string\">&quot;you&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>那么Lambda表达式, 就更进一步. 首先表达式是一个函数, 函数必须属于某个类. 所以, 生成的字节码时<code>Tool</code>类和<code>$Example1</code>都生成了, 所以Lambda和Method References是本质是一样的.</p>\n"},{"title":"Java内部类","date":"2021-11-04T02:24:37.000Z","_content":"\n## 匿名内部类\n{% blockquote %}\nAnonymous classes enable you to make your code more concise. They enable you to declare and instantiate a class at the same time. They are like local classes except that they do not have a name. Use them if you need to use a local class only once.\n{% endblockquote %}\n匿名内部类可以使你的代码更加简洁，你可以在定义一个类的同时对其进行实例化。它与局部类很相似，不同的是它没有类名，如果某个局部类你只需要用一次，那么你就可以使用匿名内部类\n\n语法如下:\n```java\ninterface Contents {\n\tint value();\n}\npublic class Parcel {\n\tpublic Contents getContents () {\n\t\treturn new Contents() {\n\t\t\tprivate int i = 11;\n\t\t\t@Override\n\t\t\tpublic int value() {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t};\n\t}\n    public static void main(String[] args) {\n\t\tParcel p = new Parcel();\n\t\tp.getContents().value();\n\t}\n\n// output:\n// 11\n}\n```\n声明一个表达式, new后加接口(类)名, 表示这个匿名内部类实现(继承)了对应的接口(类)","source":"_posts/java-inner-class.md","raw":"---\ntitle: Java内部类\ndate: 2021-11-04 10:24:37\ncategories:\n- Java\n---\n\n## 匿名内部类\n{% blockquote %}\nAnonymous classes enable you to make your code more concise. They enable you to declare and instantiate a class at the same time. They are like local classes except that they do not have a name. Use them if you need to use a local class only once.\n{% endblockquote %}\n匿名内部类可以使你的代码更加简洁，你可以在定义一个类的同时对其进行实例化。它与局部类很相似，不同的是它没有类名，如果某个局部类你只需要用一次，那么你就可以使用匿名内部类\n\n语法如下:\n```java\ninterface Contents {\n\tint value();\n}\npublic class Parcel {\n\tpublic Contents getContents () {\n\t\treturn new Contents() {\n\t\t\tprivate int i = 11;\n\t\t\t@Override\n\t\t\tpublic int value() {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t};\n\t}\n    public static void main(String[] args) {\n\t\tParcel p = new Parcel();\n\t\tp.getContents().value();\n\t}\n\n// output:\n// 11\n}\n```\n声明一个表达式, new后加接口(类)名, 表示这个匿名内部类实现(继承)了对应的接口(类)","slug":"java-inner-class","published":1,"updated":"2021-12-30T02:50:21.081Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxsdzpym000jxotg96oo7rra","content":"<h2 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h2><blockquote><p>Anonymous classes enable you to make your code more concise. They enable you to declare and instantiate a class at the same time. They are like local classes except that they do not have a name. Use them if you need to use a local class only once.</p>\n</blockquote>\n<p>匿名内部类可以使你的代码更加简洁，你可以在定义一个类的同时对其进行实例化。它与局部类很相似，不同的是它没有类名，如果某个局部类你只需要用一次，那么你就可以使用匿名内部类</p>\n<p>语法如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Contents</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">value</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parcel</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Contents <span class=\"title\">getContents</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Contents() &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> i = <span class=\"number\">11</span>;</span><br><span class=\"line\">\t\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">value</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tParcel p = <span class=\"keyword\">new</span> Parcel();</span><br><span class=\"line\">\t\tp.getContents().value();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// 11</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>声明一个表达式, new后加接口(类)名, 表示这个匿名内部类实现(继承)了对应的接口(类)</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h2><blockquote><p>Anonymous classes enable you to make your code more concise. They enable you to declare and instantiate a class at the same time. They are like local classes except that they do not have a name. Use them if you need to use a local class only once.</p>\n</blockquote>\n<p>匿名内部类可以使你的代码更加简洁，你可以在定义一个类的同时对其进行实例化。它与局部类很相似，不同的是它没有类名，如果某个局部类你只需要用一次，那么你就可以使用匿名内部类</p>\n<p>语法如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Contents</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">value</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parcel</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Contents <span class=\"title\">getContents</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Contents() &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> i = <span class=\"number\">11</span>;</span><br><span class=\"line\">\t\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">value</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tParcel p = <span class=\"keyword\">new</span> Parcel();</span><br><span class=\"line\">\t\tp.getContents().value();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// 11</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>声明一个表达式, new后加接口(类)名, 表示这个匿名内部类实现(继承)了对应的接口(类)</p>\n"},{"title":"Java动态代理","date":"2021-08-01T01:23:05.000Z","_content":"\nSpringAOP采用动态代理和字节码生成技术实现.\n\n# Static Proxy\n在软件系统中, 代理机制的实现有现成的设计模式支持, 就是代理模式. 在代理模式中, 通常有这几种抽象概念.\n - ISubject 该接口是对被访问资源的抽象\n - SubjectImpl 被访问资源的具体实现\n - SubjectProxy 被访问资源的代理实现\n - Client 访问者\n> 没有代理的情况\n```java\npublic class Client {\n    private ISubject subject;\n    Client(ISubject subject){\n        this.subject = subject;\n    }\n\n    public void doSomething() {\n        String url = ...;\n\t\tsubject.request(url);\n\t}\n    public static void main(String[] args) {\n        Client client = new Client(new SubjectImpl());\n        client.doSomething();\n    }\n}\npublic class SubjectImpl implements ISubject {\n    @Override\n    public String request(url) {\n        return \"OK\" + url;\n    }\n}\n```\n\n> 有了代理之后的情况\n```java\npublic class Client {\n    private ISubject subject;\n    Client(ISubject subject){\n        this.subject = subject;\n    }\n\n    public void doSomething() {\n        String url = ...;\n\t\tsubject.request(url);\n\t}\n    public static void main(String[] args) {\n        // 这里增加了一个多余的强制转换\n        ISubject proxy = (ISubject)new SubjectProxy(new SubjectImpl());\n        Client client = new Client(proxy);\n        client.doSomething();\n    }\n\t\n}\npublic class SubjectImpl implements ISubject {\n    @Override\n    public String request(url) {\n        return \"OK\" + url;\n    }\n}\npublic class SubjectProxy implements ISubject {\n    private ISubject subject;\n    SubjectProxy(ISubject subject){\n        this.subject = subject;\n    }\n    @Override\n    public String request(String url){\n        // add pre-process logic if neccessary\n        String res = subject.request(url);\n        // add post process logic if neccessary\n        return \"Proxy:\" + res;\n    }\n}\n```\n\n可以看出, 没有代理之前是两个类, 有了代理是三个类, 解耦的代价就是必须在其中多加一层, 才能将其分开. 新手来, 乍一看, 这TM不是多此一举吗? 不过SubjectProxy的作用不仅仅是请求的转发, 而是可以对请求添加更多的访问控制. 如注释中的, pre-process和post-process. 在请求转发给Subject之前或之后都可以根据情况插入其他处理逻辑. 这一点就和Python中的装饰器模式一样了.\n\n问题又来了, 我直接修改SubjectImpl.request()方法体不香吗? 为什么要增加一个类? 原因是, 分工不同, 考虑到协同开发和团队合作, 项目中有很多成员, 你怎么可以时不时就修改别人的工作呢? 所以看似软件开发是为了代码的解耦, 其实代码的解耦归根结底是来源于实际工作中的解耦, 脱离现实这一切都毫无意义.\n\n# Dynamic Proxy\n加入现在有很多接口都有request方法, 而且都需要代理的时候, 那么就需要单独为每个接口都写一个代理类, 这是不现实的. 所以, 有了动态代理, 为指定接口在系统运行期间生成代理对象. \n动态代理机制的实现主要由一个类和一个接口组成, 即Proxy类和InvocationHandler接口.\n\n使用动态代理实现一个\"request服务时间控制\"功能:\n```java\npublic class RequestCtrlInvocationHandler implements InvocationHandler {\n    private static final Log logger = LogFactory.getLog(RequestCtrlInvocationHandler.class);\n    private Object target;\n    public RequestCtrlInvocationHandler(Objec target) {\n        this.target = target;\n    }\n    public Objec invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        if(method.getName.equal(\"request\")) {\n            TimeOfDay startTime = new TiemOfDay(0, 0, 0);\n            TimeOfDay endTime = new TiemOfDay(5, 59, 59);\n            TiemOfDay currentTime = new TimeDay();\n            if(currentTime.isAfter(startTime) && currentTime.isBefore(endTime)) {\n                logger.warn(\"Service is not available now.\");\n                return null;\n            }\n            return method.invoke(target, args);\n        }\n        return null;\n    }\n}\n\npublic class Client{\n    public static void main(String[] args) {\n        ISubject subject = (ISubject)Proxy.newProxyInstance(ISubject.class.getClassLoader(), new Class[]{ISubject.class}, new RequestCtrlInvocationHandler(new ISubjectImpl()));\n        // 这里不增加doSomething方法了, 简单演示一下调用\n        String url = ...;\n        subject.request(url);\n    }\n}\n```\n那么在运行期间, JVM会为我们创建class字节码, 翻译过来大概如下:\n```Java\npublic class $Proxy0 implements ISubject {\n    InvocationHandler handler;\n    public $Proxy0(InvocationHandler handler) {\n        this.handler = handler;\n    }\n    public void request(String url){\n        handler.invoke(this, ISubject.class.getMethod(\"request\", String.class), new Object[]{url});\n    }\n}\n```\n\n## 动态代理源码\n有必要动态代理的源码扒出来加固上边的分析过程\n```java\npublic class Proxy implements java.io.Serializable {\n\n    /** parameter types of a proxy class constructor */\n    private static final Class<?>[] constructorParams =\n        { InvocationHandler.class };\n    \n    /**\n     * a cache of proxy classes\n     */\n    private static final WeakCache<ClassLoader, Class<?>[], Class<?>>\n        proxyClassCache = new WeakCache<>(new KeyFactory(), new ProxyClassFactory());\n\n    // ...\n    \n    /**\n     * Generate a proxy class.  Must call the checkProxyAccess method\n     * to perform permission checks before calling this.\n     */\n    private static Class<?> getProxyClass0(ClassLoader loader,\n                                           Class<?>... interfaces) {\n        if (interfaces.length > 65535) {\n            throw new IllegalArgumentException(\"interface limit exceeded\");\n        }\n\n        // If the proxy class defined by the given loader implementing\n        // the given interfaces exists, this will simply return the cached copy;\n        // otherwise, it will create the proxy class via the ProxyClassFactory\n        return proxyClassCache.get(loader, interfaces);\n    }\n\n    \n    /**\n     * A factory function that generates, defines and returns the proxy class given\n     * the ClassLoader and array of interfaces.\n     */\n    private static final class ProxyClassFactory\n        implements BiFunction<ClassLoader, Class<?>[], Class<?>>\n    {\n        // prefix for all proxy class names\n        private static final String proxyClassNamePrefix = \"$Proxy\";\n\n        @Override\n        public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {\n\n            Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);\n\n            //... \n\n            /*\n             * Choose a name for the proxy class to generate.\n             */\n            long num = nextUniqueNumber.getAndIncrement();\n            String proxyName = proxyPkg + proxyClassNamePrefix + num;\n\n            /*\n             * Generate the specified proxy class.\n             */\n            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(\n                proxyName, interfaces, accessFlags);\n            // ...\n        }\n    }\n    \n    @CallerSensitive\n    public static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n        throws IllegalArgumentException\n    {\n        // ...\n\n        final Class<?>[] intfs = interfaces.clone();\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);\n        }\n\n        /*\n         * Look up or generate the designated proxy class.\n         */\n        Class<?> cl = getProxyClass0(loader, intfs);\n\n        /*\n         * Invoke its constructor with the designated invocation handler.\n         */\n        try {\n            if (sm != null) {\n                checkNewProxyPermission(Reflection.getCallerClass(), cl);\n            }\n\n            final Constructor<?> cons = cl.getConstructor(constructorParams);\n            final InvocationHandler ih = h;\n            if (!Modifier.isPublic(cl.getModifiers())) {\n                AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                    public Void run() {\n                        cons.setAccessible(true);\n                        return null;\n                    }\n                });\n            }\n            return cons.newInstance(new Object[]{h});\n        } catch (IllegalAccessException|InstantiationException e) {\n            // ...\n        } catch (InvocationTargetException e) {\n            // ...\n        } catch (NoSuchMethodException e) {\n            // ...\n        }\n    }\n}\n```\n> 其中这个newProxyInstance方法要注重说一下，大概分为四步：\n - 第一步，先进行权限检测`checkProxyAccess`，主要是借助于`System.getSecurityManager().checkxxxPermission(...)`，其中权限主要涉及：文件，socket等\n - 第二步，生产代理对象, `getProxyClass0(loader, intfs)`根据传入`newProxyInstance(...)`的参数得到一个代理对象，其中传入的参数有三个, 根据前两个参数到proxyClassCache中查找是否有缓存，如果没有，根据`ProxyClassFactory`生产出一个代理对象，`ProxyClassFactory`是一个静态内部类, 其中代理对象的生成过程，主要涉及`apply(..)`中的`ProxyGenerator.generateProxyClass(proxyName...)`行(以下附上了`ProxyGenerator`的部分源码)，当我打开`generateProxyClass`方法的源码才恍然大悟，`generateClassFile()`在内存中生成一个class类(文件一般不保存, 类名一般叫做`$Proxy0`)，来定义代理类，原来Java的动态不过如此。\n ```Java\npublic class ProxyGenerator {\n    // ...\n    public static byte[] generateProxyClass(final String var0, Class<?>[] var1, int var2) {\n        ProxyGenerator var3 = new ProxyGenerator(var0, var1, var2);\n        final byte[] var4 = var3.generateClassFile();\n        if (saveGeneratedFiles) {\n            // ...\n            // 生成一个简单的代理对象, 一般不需要进行.class的保存, 所以这里的`saveGeneratedFiles`为false\n        }\n        \n        return var4;\n    }\n}\n```\n - 第三步，根据第二步生成的代理类，调用`cl.getConstructor({ InvocationHandler.class })`, 相当于调用了代理类的构造方法, 在通过构造器调用`cons.newInstance(new RequestCtrlInvocationHandler(new ISubjectImpl()))`，最终强制转换ISubject对象。\n - 第四步，当代理对象调用`ISubject`的`request`时，首先进入`RequestCtrlInvocationHandler`的invoke方法，在该方法的最后，通过method.invoke(...)来真正调用`ISubjectImpl.request`\n\n 问题1: 代理为什么需要实现某个接口, 继承某个类, 不可以代理吗?\n 答: 代理描述的场景是代理目标类所有的方法, 如果目标类只是继承的话, 它并不一定重写了所有的方法, 所以有些方法没办法代理. 如果要对没有实现任何接口的类, 可以使用CGLIB, 为目标类生成一个子类, 就可以通过子类调用父类的方法, 并在方法的前后加上pre-process或者post-process\n\n\n\n","source":"_posts/java-proxy-and-dynamic-proxy.md","raw":"---\ntitle: Java动态代理\ndate: 2021-08-01 09:23:05\ncategories:\n- Java\n- Pattern\ntags:\n- Proxy\n---\n\nSpringAOP采用动态代理和字节码生成技术实现.\n\n# Static Proxy\n在软件系统中, 代理机制的实现有现成的设计模式支持, 就是代理模式. 在代理模式中, 通常有这几种抽象概念.\n - ISubject 该接口是对被访问资源的抽象\n - SubjectImpl 被访问资源的具体实现\n - SubjectProxy 被访问资源的代理实现\n - Client 访问者\n> 没有代理的情况\n```java\npublic class Client {\n    private ISubject subject;\n    Client(ISubject subject){\n        this.subject = subject;\n    }\n\n    public void doSomething() {\n        String url = ...;\n\t\tsubject.request(url);\n\t}\n    public static void main(String[] args) {\n        Client client = new Client(new SubjectImpl());\n        client.doSomething();\n    }\n}\npublic class SubjectImpl implements ISubject {\n    @Override\n    public String request(url) {\n        return \"OK\" + url;\n    }\n}\n```\n\n> 有了代理之后的情况\n```java\npublic class Client {\n    private ISubject subject;\n    Client(ISubject subject){\n        this.subject = subject;\n    }\n\n    public void doSomething() {\n        String url = ...;\n\t\tsubject.request(url);\n\t}\n    public static void main(String[] args) {\n        // 这里增加了一个多余的强制转换\n        ISubject proxy = (ISubject)new SubjectProxy(new SubjectImpl());\n        Client client = new Client(proxy);\n        client.doSomething();\n    }\n\t\n}\npublic class SubjectImpl implements ISubject {\n    @Override\n    public String request(url) {\n        return \"OK\" + url;\n    }\n}\npublic class SubjectProxy implements ISubject {\n    private ISubject subject;\n    SubjectProxy(ISubject subject){\n        this.subject = subject;\n    }\n    @Override\n    public String request(String url){\n        // add pre-process logic if neccessary\n        String res = subject.request(url);\n        // add post process logic if neccessary\n        return \"Proxy:\" + res;\n    }\n}\n```\n\n可以看出, 没有代理之前是两个类, 有了代理是三个类, 解耦的代价就是必须在其中多加一层, 才能将其分开. 新手来, 乍一看, 这TM不是多此一举吗? 不过SubjectProxy的作用不仅仅是请求的转发, 而是可以对请求添加更多的访问控制. 如注释中的, pre-process和post-process. 在请求转发给Subject之前或之后都可以根据情况插入其他处理逻辑. 这一点就和Python中的装饰器模式一样了.\n\n问题又来了, 我直接修改SubjectImpl.request()方法体不香吗? 为什么要增加一个类? 原因是, 分工不同, 考虑到协同开发和团队合作, 项目中有很多成员, 你怎么可以时不时就修改别人的工作呢? 所以看似软件开发是为了代码的解耦, 其实代码的解耦归根结底是来源于实际工作中的解耦, 脱离现实这一切都毫无意义.\n\n# Dynamic Proxy\n加入现在有很多接口都有request方法, 而且都需要代理的时候, 那么就需要单独为每个接口都写一个代理类, 这是不现实的. 所以, 有了动态代理, 为指定接口在系统运行期间生成代理对象. \n动态代理机制的实现主要由一个类和一个接口组成, 即Proxy类和InvocationHandler接口.\n\n使用动态代理实现一个\"request服务时间控制\"功能:\n```java\npublic class RequestCtrlInvocationHandler implements InvocationHandler {\n    private static final Log logger = LogFactory.getLog(RequestCtrlInvocationHandler.class);\n    private Object target;\n    public RequestCtrlInvocationHandler(Objec target) {\n        this.target = target;\n    }\n    public Objec invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        if(method.getName.equal(\"request\")) {\n            TimeOfDay startTime = new TiemOfDay(0, 0, 0);\n            TimeOfDay endTime = new TiemOfDay(5, 59, 59);\n            TiemOfDay currentTime = new TimeDay();\n            if(currentTime.isAfter(startTime) && currentTime.isBefore(endTime)) {\n                logger.warn(\"Service is not available now.\");\n                return null;\n            }\n            return method.invoke(target, args);\n        }\n        return null;\n    }\n}\n\npublic class Client{\n    public static void main(String[] args) {\n        ISubject subject = (ISubject)Proxy.newProxyInstance(ISubject.class.getClassLoader(), new Class[]{ISubject.class}, new RequestCtrlInvocationHandler(new ISubjectImpl()));\n        // 这里不增加doSomething方法了, 简单演示一下调用\n        String url = ...;\n        subject.request(url);\n    }\n}\n```\n那么在运行期间, JVM会为我们创建class字节码, 翻译过来大概如下:\n```Java\npublic class $Proxy0 implements ISubject {\n    InvocationHandler handler;\n    public $Proxy0(InvocationHandler handler) {\n        this.handler = handler;\n    }\n    public void request(String url){\n        handler.invoke(this, ISubject.class.getMethod(\"request\", String.class), new Object[]{url});\n    }\n}\n```\n\n## 动态代理源码\n有必要动态代理的源码扒出来加固上边的分析过程\n```java\npublic class Proxy implements java.io.Serializable {\n\n    /** parameter types of a proxy class constructor */\n    private static final Class<?>[] constructorParams =\n        { InvocationHandler.class };\n    \n    /**\n     * a cache of proxy classes\n     */\n    private static final WeakCache<ClassLoader, Class<?>[], Class<?>>\n        proxyClassCache = new WeakCache<>(new KeyFactory(), new ProxyClassFactory());\n\n    // ...\n    \n    /**\n     * Generate a proxy class.  Must call the checkProxyAccess method\n     * to perform permission checks before calling this.\n     */\n    private static Class<?> getProxyClass0(ClassLoader loader,\n                                           Class<?>... interfaces) {\n        if (interfaces.length > 65535) {\n            throw new IllegalArgumentException(\"interface limit exceeded\");\n        }\n\n        // If the proxy class defined by the given loader implementing\n        // the given interfaces exists, this will simply return the cached copy;\n        // otherwise, it will create the proxy class via the ProxyClassFactory\n        return proxyClassCache.get(loader, interfaces);\n    }\n\n    \n    /**\n     * A factory function that generates, defines and returns the proxy class given\n     * the ClassLoader and array of interfaces.\n     */\n    private static final class ProxyClassFactory\n        implements BiFunction<ClassLoader, Class<?>[], Class<?>>\n    {\n        // prefix for all proxy class names\n        private static final String proxyClassNamePrefix = \"$Proxy\";\n\n        @Override\n        public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {\n\n            Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);\n\n            //... \n\n            /*\n             * Choose a name for the proxy class to generate.\n             */\n            long num = nextUniqueNumber.getAndIncrement();\n            String proxyName = proxyPkg + proxyClassNamePrefix + num;\n\n            /*\n             * Generate the specified proxy class.\n             */\n            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(\n                proxyName, interfaces, accessFlags);\n            // ...\n        }\n    }\n    \n    @CallerSensitive\n    public static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n        throws IllegalArgumentException\n    {\n        // ...\n\n        final Class<?>[] intfs = interfaces.clone();\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);\n        }\n\n        /*\n         * Look up or generate the designated proxy class.\n         */\n        Class<?> cl = getProxyClass0(loader, intfs);\n\n        /*\n         * Invoke its constructor with the designated invocation handler.\n         */\n        try {\n            if (sm != null) {\n                checkNewProxyPermission(Reflection.getCallerClass(), cl);\n            }\n\n            final Constructor<?> cons = cl.getConstructor(constructorParams);\n            final InvocationHandler ih = h;\n            if (!Modifier.isPublic(cl.getModifiers())) {\n                AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                    public Void run() {\n                        cons.setAccessible(true);\n                        return null;\n                    }\n                });\n            }\n            return cons.newInstance(new Object[]{h});\n        } catch (IllegalAccessException|InstantiationException e) {\n            // ...\n        } catch (InvocationTargetException e) {\n            // ...\n        } catch (NoSuchMethodException e) {\n            // ...\n        }\n    }\n}\n```\n> 其中这个newProxyInstance方法要注重说一下，大概分为四步：\n - 第一步，先进行权限检测`checkProxyAccess`，主要是借助于`System.getSecurityManager().checkxxxPermission(...)`，其中权限主要涉及：文件，socket等\n - 第二步，生产代理对象, `getProxyClass0(loader, intfs)`根据传入`newProxyInstance(...)`的参数得到一个代理对象，其中传入的参数有三个, 根据前两个参数到proxyClassCache中查找是否有缓存，如果没有，根据`ProxyClassFactory`生产出一个代理对象，`ProxyClassFactory`是一个静态内部类, 其中代理对象的生成过程，主要涉及`apply(..)`中的`ProxyGenerator.generateProxyClass(proxyName...)`行(以下附上了`ProxyGenerator`的部分源码)，当我打开`generateProxyClass`方法的源码才恍然大悟，`generateClassFile()`在内存中生成一个class类(文件一般不保存, 类名一般叫做`$Proxy0`)，来定义代理类，原来Java的动态不过如此。\n ```Java\npublic class ProxyGenerator {\n    // ...\n    public static byte[] generateProxyClass(final String var0, Class<?>[] var1, int var2) {\n        ProxyGenerator var3 = new ProxyGenerator(var0, var1, var2);\n        final byte[] var4 = var3.generateClassFile();\n        if (saveGeneratedFiles) {\n            // ...\n            // 生成一个简单的代理对象, 一般不需要进行.class的保存, 所以这里的`saveGeneratedFiles`为false\n        }\n        \n        return var4;\n    }\n}\n```\n - 第三步，根据第二步生成的代理类，调用`cl.getConstructor({ InvocationHandler.class })`, 相当于调用了代理类的构造方法, 在通过构造器调用`cons.newInstance(new RequestCtrlInvocationHandler(new ISubjectImpl()))`，最终强制转换ISubject对象。\n - 第四步，当代理对象调用`ISubject`的`request`时，首先进入`RequestCtrlInvocationHandler`的invoke方法，在该方法的最后，通过method.invoke(...)来真正调用`ISubjectImpl.request`\n\n 问题1: 代理为什么需要实现某个接口, 继承某个类, 不可以代理吗?\n 答: 代理描述的场景是代理目标类所有的方法, 如果目标类只是继承的话, 它并不一定重写了所有的方法, 所以有些方法没办法代理. 如果要对没有实现任何接口的类, 可以使用CGLIB, 为目标类生成一个子类, 就可以通过子类调用父类的方法, 并在方法的前后加上pre-process或者post-process\n\n\n\n","slug":"java-proxy-and-dynamic-proxy","published":1,"updated":"2021-12-30T03:03:23.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxsdzpyp000kxotg3azoa26w","content":"<p>SpringAOP采用动态代理和字节码生成技术实现.</p>\n<h1 id=\"Static-Proxy\"><a href=\"#Static-Proxy\" class=\"headerlink\" title=\"Static Proxy\"></a>Static Proxy</h1><p>在软件系统中, 代理机制的实现有现成的设计模式支持, 就是代理模式. 在代理模式中, 通常有这几种抽象概念.</p>\n<ul>\n<li>ISubject 该接口是对被访问资源的抽象</li>\n<li>SubjectImpl 被访问资源的具体实现</li>\n<li>SubjectProxy 被访问资源的代理实现</li>\n<li>Client 访问者<blockquote>\n<p>没有代理的情况</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ISubject subject;</span><br><span class=\"line\">    Client(ISubject subject)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.subject = subject;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String url = ...;</span><br><span class=\"line\">\t\tsubject.request(url);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Client client = <span class=\"keyword\">new</span> Client(<span class=\"keyword\">new</span> SubjectImpl());</span><br><span class=\"line\">        client.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubjectImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ISubject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">request</span><span class=\"params\">(url)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;OK&quot;</span> + url;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<blockquote>\n<p>有了代理之后的情况</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ISubject subject;</span><br><span class=\"line\">    Client(ISubject subject)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.subject = subject;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String url = ...;</span><br><span class=\"line\">\t\tsubject.request(url);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里增加了一个多余的强制转换</span></span><br><span class=\"line\">        ISubject proxy = (ISubject)<span class=\"keyword\">new</span> SubjectProxy(<span class=\"keyword\">new</span> SubjectImpl());</span><br><span class=\"line\">        Client client = <span class=\"keyword\">new</span> Client(proxy);</span><br><span class=\"line\">        client.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubjectImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ISubject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">request</span><span class=\"params\">(url)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;OK&quot;</span> + url;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubjectProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">ISubject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ISubject subject;</span><br><span class=\"line\">    SubjectProxy(ISubject subject)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.subject = subject;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">request</span><span class=\"params\">(String url)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// add pre-process logic if neccessary</span></span><br><span class=\"line\">        String res = subject.request(url);</span><br><span class=\"line\">        <span class=\"comment\">// add post process logic if neccessary</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Proxy:&quot;</span> + res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出, 没有代理之前是两个类, 有了代理是三个类, 解耦的代价就是必须在其中多加一层, 才能将其分开. 新手来, 乍一看, 这TM不是多此一举吗? 不过SubjectProxy的作用不仅仅是请求的转发, 而是可以对请求添加更多的访问控制. 如注释中的, pre-process和post-process. 在请求转发给Subject之前或之后都可以根据情况插入其他处理逻辑. 这一点就和Python中的装饰器模式一样了.</p>\n<p>问题又来了, 我直接修改SubjectImpl.request()方法体不香吗? 为什么要增加一个类? 原因是, 分工不同, 考虑到协同开发和团队合作, 项目中有很多成员, 你怎么可以时不时就修改别人的工作呢? 所以看似软件开发是为了代码的解耦, 其实代码的解耦归根结底是来源于实际工作中的解耦, 脱离现实这一切都毫无意义.</p>\n<h1 id=\"Dynamic-Proxy\"><a href=\"#Dynamic-Proxy\" class=\"headerlink\" title=\"Dynamic Proxy\"></a>Dynamic Proxy</h1><p>加入现在有很多接口都有request方法, 而且都需要代理的时候, 那么就需要单独为每个接口都写一个代理类, 这是不现实的. 所以, 有了动态代理, 为指定接口在系统运行期间生成代理对象.<br>动态代理机制的实现主要由一个类和一个接口组成, 即Proxy类和InvocationHandler接口.</p>\n<p>使用动态代理实现一个”request服务时间控制”功能:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RequestCtrlInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Log logger = LogFactory.getLog(RequestCtrlInvocationHandler.class);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RequestCtrlInvocationHandler</span><span class=\"params\">(Objec target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Objec <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(method.getName.equal(<span class=\"string\">&quot;request&quot;</span>)) &#123;</span><br><span class=\"line\">            TimeOfDay startTime = <span class=\"keyword\">new</span> TiemOfDay(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">            TimeOfDay endTime = <span class=\"keyword\">new</span> TiemOfDay(<span class=\"number\">5</span>, <span class=\"number\">59</span>, <span class=\"number\">59</span>);</span><br><span class=\"line\">            TiemOfDay currentTime = <span class=\"keyword\">new</span> TimeDay();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(currentTime.isAfter(startTime) &amp;&amp; currentTime.isBefore(endTime)) &#123;</span><br><span class=\"line\">                logger.warn(<span class=\"string\">&quot;Service is not available now.&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> method.invoke(target, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ISubject subject = (ISubject)Proxy.newProxyInstance(ISubject.class.getClassLoader(), <span class=\"keyword\">new</span> Class[]&#123;ISubject.class&#125;, <span class=\"keyword\">new</span> RequestCtrlInvocationHandler(<span class=\"keyword\">new</span> ISubjectImpl()));</span><br><span class=\"line\">        <span class=\"comment\">// 这里不增加doSomething方法了, 简单演示一下调用</span></span><br><span class=\"line\">        String url = ...;</span><br><span class=\"line\">        subject.request(url);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么在运行期间, JVM会为我们创建class字节码, 翻译过来大概如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> $<span class=\"title\">Proxy0</span> <span class=\"keyword\">implements</span> <span class=\"title\">ISubject</span> </span>&#123;</span><br><span class=\"line\">    InvocationHandler handler;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> $Proxy0(InvocationHandler handler) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handler = handler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">(String url)</span></span>&#123;</span><br><span class=\"line\">        handler.invoke(<span class=\"keyword\">this</span>, ISubject.class.getMethod(<span class=\"string\">&quot;request&quot;</span>, String.class), <span class=\"keyword\">new</span> Object[]&#123;url&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"动态代理源码\"><a href=\"#动态代理源码\" class=\"headerlink\" title=\"动态代理源码\"></a>动态代理源码</h2><p>有必要动态代理的源码扒出来加固上边的分析过程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** parameter types of a proxy class constructor */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Class&lt;?&gt;[] constructorParams =</span><br><span class=\"line\">        &#123; InvocationHandler.class &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * a cache of proxy classes</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class=\"line\">        proxyClassCache = <span class=\"keyword\">new</span> WeakCache&lt;&gt;(<span class=\"keyword\">new</span> KeyFactory(), <span class=\"keyword\">new</span> ProxyClassFactory());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Generate a proxy class.  Must call the checkProxyAccess method</span></span><br><span class=\"line\"><span class=\"comment\">     * to perform permission checks before calling this.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class=\"line\">                                           Class&lt;?&gt;... interfaces) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (interfaces.length &gt; <span class=\"number\">65535</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;interface limit exceeded&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If the proxy class defined by the given loader implementing</span></span><br><span class=\"line\">        <span class=\"comment\">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class=\"line\">        <span class=\"comment\">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * A factory function that generates, defines and returns the proxy class given</span></span><br><span class=\"line\"><span class=\"comment\">     * the ClassLoader and array of interfaces.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyClassFactory</span></span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">BiFunction</span>&lt;<span class=\"title\">ClassLoader</span>, <span class=\"title\">Class</span>&lt;?&gt;[], <span class=\"title\">Class</span>&lt;?&gt;&gt;</span></span><br><span class=\"line\"><span class=\"class\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// prefix for all proxy class names</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String proxyClassNamePrefix = <span class=\"string\">&quot;$Proxy&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class=\"keyword\">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//... </span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">             * Choose a name for the proxy class to generate.</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"keyword\">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class=\"line\">            String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">             * Generate the specified proxy class.</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class=\"line\">                proxyName, interfaces, accessFlags);</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@CallerSensitive</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">newProxyInstance</span><span class=\"params\">(ClassLoader loader,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                          InvocationHandler h)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> IllegalArgumentException</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sm != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Look up or generate the designated proxy class.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Invoke its constructor with the designated invocation handler.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sm != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class=\"line\">            <span class=\"keyword\">final</span> InvocationHandler ih = h;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class=\"line\">                AccessController.doPrivileged(<span class=\"keyword\">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> Void <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        cons.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cons.newInstance(<span class=\"keyword\">new</span> Object[]&#123;h&#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InvocationTargetException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>其中这个newProxyInstance方法要注重说一下，大概分为四步：</p>\n</blockquote>\n<ul>\n<li>第一步，先进行权限检测<code>checkProxyAccess</code>，主要是借助于<code>System.getSecurityManager().checkxxxPermission(...)</code>，其中权限主要涉及：文件，socket等</li>\n<li>第二步，生产代理对象, <code>getProxyClass0(loader, intfs)</code>根据传入<code>newProxyInstance(...)</code>的参数得到一个代理对象，其中传入的参数有三个, 根据前两个参数到proxyClassCache中查找是否有缓存，如果没有，根据<code>ProxyClassFactory</code>生产出一个代理对象，<code>ProxyClassFactory</code>是一个静态内部类, 其中代理对象的生成过程，主要涉及<code>apply(..)</code>中的<code>ProxyGenerator.generateProxyClass(proxyName...)</code>行(以下附上了<code>ProxyGenerator</code>的部分源码)，当我打开<code>generateProxyClass</code>方法的源码才恍然大悟，<code>generateClassFile()</code>在内存中生成一个class类(文件一般不保存, 类名一般叫做<code>$Proxy0</code>)，来定义代理类，原来Java的动态不过如此。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyGenerator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">byte</span>[] generateProxyClass(<span class=\"keyword\">final</span> String var0, Class&lt;?&gt;[] var1, <span class=\"keyword\">int</span> var2) &#123;</span><br><span class=\"line\">        ProxyGenerator var3 = <span class=\"keyword\">new</span> ProxyGenerator(var0, var1, var2);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] var4 = var3.generateClassFile();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (saveGeneratedFiles) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">            <span class=\"comment\">// 生成一个简单的代理对象, 一般不需要进行.class的保存, 所以这里的`saveGeneratedFiles`为false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> var4;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>第三步，根据第二步生成的代理类，调用<code>cl.getConstructor(&#123; InvocationHandler.class &#125;)</code>, 相当于调用了代理类的构造方法, 在通过构造器调用<code>cons.newInstance(new RequestCtrlInvocationHandler(new ISubjectImpl()))</code>，最终强制转换ISubject对象。</li>\n<li>第四步，当代理对象调用<code>ISubject</code>的<code>request</code>时，首先进入<code>RequestCtrlInvocationHandler</code>的invoke方法，在该方法的最后，通过method.invoke(…)来真正调用<code>ISubjectImpl.request</code></li>\n</ul>\n<p> 问题1: 代理为什么需要实现某个接口, 继承某个类, 不可以代理吗?<br> 答: 代理描述的场景是代理目标类所有的方法, 如果目标类只是继承的话, 它并不一定重写了所有的方法, 所以有些方法没办法代理. 如果要对没有实现任何接口的类, 可以使用CGLIB, 为目标类生成一个子类, 就可以通过子类调用父类的方法, 并在方法的前后加上pre-process或者post-process</p>\n","site":{"data":{}},"excerpt":"","more":"<p>SpringAOP采用动态代理和字节码生成技术实现.</p>\n<h1 id=\"Static-Proxy\"><a href=\"#Static-Proxy\" class=\"headerlink\" title=\"Static Proxy\"></a>Static Proxy</h1><p>在软件系统中, 代理机制的实现有现成的设计模式支持, 就是代理模式. 在代理模式中, 通常有这几种抽象概念.</p>\n<ul>\n<li>ISubject 该接口是对被访问资源的抽象</li>\n<li>SubjectImpl 被访问资源的具体实现</li>\n<li>SubjectProxy 被访问资源的代理实现</li>\n<li>Client 访问者<blockquote>\n<p>没有代理的情况</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ISubject subject;</span><br><span class=\"line\">    Client(ISubject subject)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.subject = subject;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String url = ...;</span><br><span class=\"line\">\t\tsubject.request(url);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Client client = <span class=\"keyword\">new</span> Client(<span class=\"keyword\">new</span> SubjectImpl());</span><br><span class=\"line\">        client.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubjectImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ISubject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">request</span><span class=\"params\">(url)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;OK&quot;</span> + url;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<blockquote>\n<p>有了代理之后的情况</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ISubject subject;</span><br><span class=\"line\">    Client(ISubject subject)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.subject = subject;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String url = ...;</span><br><span class=\"line\">\t\tsubject.request(url);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里增加了一个多余的强制转换</span></span><br><span class=\"line\">        ISubject proxy = (ISubject)<span class=\"keyword\">new</span> SubjectProxy(<span class=\"keyword\">new</span> SubjectImpl());</span><br><span class=\"line\">        Client client = <span class=\"keyword\">new</span> Client(proxy);</span><br><span class=\"line\">        client.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubjectImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ISubject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">request</span><span class=\"params\">(url)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;OK&quot;</span> + url;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubjectProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">ISubject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ISubject subject;</span><br><span class=\"line\">    SubjectProxy(ISubject subject)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.subject = subject;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">request</span><span class=\"params\">(String url)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// add pre-process logic if neccessary</span></span><br><span class=\"line\">        String res = subject.request(url);</span><br><span class=\"line\">        <span class=\"comment\">// add post process logic if neccessary</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Proxy:&quot;</span> + res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出, 没有代理之前是两个类, 有了代理是三个类, 解耦的代价就是必须在其中多加一层, 才能将其分开. 新手来, 乍一看, 这TM不是多此一举吗? 不过SubjectProxy的作用不仅仅是请求的转发, 而是可以对请求添加更多的访问控制. 如注释中的, pre-process和post-process. 在请求转发给Subject之前或之后都可以根据情况插入其他处理逻辑. 这一点就和Python中的装饰器模式一样了.</p>\n<p>问题又来了, 我直接修改SubjectImpl.request()方法体不香吗? 为什么要增加一个类? 原因是, 分工不同, 考虑到协同开发和团队合作, 项目中有很多成员, 你怎么可以时不时就修改别人的工作呢? 所以看似软件开发是为了代码的解耦, 其实代码的解耦归根结底是来源于实际工作中的解耦, 脱离现实这一切都毫无意义.</p>\n<h1 id=\"Dynamic-Proxy\"><a href=\"#Dynamic-Proxy\" class=\"headerlink\" title=\"Dynamic Proxy\"></a>Dynamic Proxy</h1><p>加入现在有很多接口都有request方法, 而且都需要代理的时候, 那么就需要单独为每个接口都写一个代理类, 这是不现实的. 所以, 有了动态代理, 为指定接口在系统运行期间生成代理对象.<br>动态代理机制的实现主要由一个类和一个接口组成, 即Proxy类和InvocationHandler接口.</p>\n<p>使用动态代理实现一个”request服务时间控制”功能:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RequestCtrlInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Log logger = LogFactory.getLog(RequestCtrlInvocationHandler.class);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RequestCtrlInvocationHandler</span><span class=\"params\">(Objec target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Objec <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(method.getName.equal(<span class=\"string\">&quot;request&quot;</span>)) &#123;</span><br><span class=\"line\">            TimeOfDay startTime = <span class=\"keyword\">new</span> TiemOfDay(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">            TimeOfDay endTime = <span class=\"keyword\">new</span> TiemOfDay(<span class=\"number\">5</span>, <span class=\"number\">59</span>, <span class=\"number\">59</span>);</span><br><span class=\"line\">            TiemOfDay currentTime = <span class=\"keyword\">new</span> TimeDay();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(currentTime.isAfter(startTime) &amp;&amp; currentTime.isBefore(endTime)) &#123;</span><br><span class=\"line\">                logger.warn(<span class=\"string\">&quot;Service is not available now.&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> method.invoke(target, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ISubject subject = (ISubject)Proxy.newProxyInstance(ISubject.class.getClassLoader(), <span class=\"keyword\">new</span> Class[]&#123;ISubject.class&#125;, <span class=\"keyword\">new</span> RequestCtrlInvocationHandler(<span class=\"keyword\">new</span> ISubjectImpl()));</span><br><span class=\"line\">        <span class=\"comment\">// 这里不增加doSomething方法了, 简单演示一下调用</span></span><br><span class=\"line\">        String url = ...;</span><br><span class=\"line\">        subject.request(url);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么在运行期间, JVM会为我们创建class字节码, 翻译过来大概如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> $<span class=\"title\">Proxy0</span> <span class=\"keyword\">implements</span> <span class=\"title\">ISubject</span> </span>&#123;</span><br><span class=\"line\">    InvocationHandler handler;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> $Proxy0(InvocationHandler handler) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handler = handler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">(String url)</span></span>&#123;</span><br><span class=\"line\">        handler.invoke(<span class=\"keyword\">this</span>, ISubject.class.getMethod(<span class=\"string\">&quot;request&quot;</span>, String.class), <span class=\"keyword\">new</span> Object[]&#123;url&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"动态代理源码\"><a href=\"#动态代理源码\" class=\"headerlink\" title=\"动态代理源码\"></a>动态代理源码</h2><p>有必要动态代理的源码扒出来加固上边的分析过程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** parameter types of a proxy class constructor */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Class&lt;?&gt;[] constructorParams =</span><br><span class=\"line\">        &#123; InvocationHandler.class &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * a cache of proxy classes</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class=\"line\">        proxyClassCache = <span class=\"keyword\">new</span> WeakCache&lt;&gt;(<span class=\"keyword\">new</span> KeyFactory(), <span class=\"keyword\">new</span> ProxyClassFactory());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Generate a proxy class.  Must call the checkProxyAccess method</span></span><br><span class=\"line\"><span class=\"comment\">     * to perform permission checks before calling this.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class=\"line\">                                           Class&lt;?&gt;... interfaces) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (interfaces.length &gt; <span class=\"number\">65535</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;interface limit exceeded&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If the proxy class defined by the given loader implementing</span></span><br><span class=\"line\">        <span class=\"comment\">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class=\"line\">        <span class=\"comment\">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * A factory function that generates, defines and returns the proxy class given</span></span><br><span class=\"line\"><span class=\"comment\">     * the ClassLoader and array of interfaces.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyClassFactory</span></span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">BiFunction</span>&lt;<span class=\"title\">ClassLoader</span>, <span class=\"title\">Class</span>&lt;?&gt;[], <span class=\"title\">Class</span>&lt;?&gt;&gt;</span></span><br><span class=\"line\"><span class=\"class\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// prefix for all proxy class names</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String proxyClassNamePrefix = <span class=\"string\">&quot;$Proxy&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class=\"keyword\">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//... </span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">             * Choose a name for the proxy class to generate.</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"keyword\">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class=\"line\">            String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">             * Generate the specified proxy class.</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class=\"line\">                proxyName, interfaces, accessFlags);</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@CallerSensitive</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">newProxyInstance</span><span class=\"params\">(ClassLoader loader,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                          InvocationHandler h)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> IllegalArgumentException</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sm != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Look up or generate the designated proxy class.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Invoke its constructor with the designated invocation handler.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sm != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class=\"line\">            <span class=\"keyword\">final</span> InvocationHandler ih = h;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class=\"line\">                AccessController.doPrivileged(<span class=\"keyword\">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> Void <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        cons.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cons.newInstance(<span class=\"keyword\">new</span> Object[]&#123;h&#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InvocationTargetException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>其中这个newProxyInstance方法要注重说一下，大概分为四步：</p>\n</blockquote>\n<ul>\n<li>第一步，先进行权限检测<code>checkProxyAccess</code>，主要是借助于<code>System.getSecurityManager().checkxxxPermission(...)</code>，其中权限主要涉及：文件，socket等</li>\n<li>第二步，生产代理对象, <code>getProxyClass0(loader, intfs)</code>根据传入<code>newProxyInstance(...)</code>的参数得到一个代理对象，其中传入的参数有三个, 根据前两个参数到proxyClassCache中查找是否有缓存，如果没有，根据<code>ProxyClassFactory</code>生产出一个代理对象，<code>ProxyClassFactory</code>是一个静态内部类, 其中代理对象的生成过程，主要涉及<code>apply(..)</code>中的<code>ProxyGenerator.generateProxyClass(proxyName...)</code>行(以下附上了<code>ProxyGenerator</code>的部分源码)，当我打开<code>generateProxyClass</code>方法的源码才恍然大悟，<code>generateClassFile()</code>在内存中生成一个class类(文件一般不保存, 类名一般叫做<code>$Proxy0</code>)，来定义代理类，原来Java的动态不过如此。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyGenerator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">byte</span>[] generateProxyClass(<span class=\"keyword\">final</span> String var0, Class&lt;?&gt;[] var1, <span class=\"keyword\">int</span> var2) &#123;</span><br><span class=\"line\">        ProxyGenerator var3 = <span class=\"keyword\">new</span> ProxyGenerator(var0, var1, var2);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] var4 = var3.generateClassFile();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (saveGeneratedFiles) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">            <span class=\"comment\">// 生成一个简单的代理对象, 一般不需要进行.class的保存, 所以这里的`saveGeneratedFiles`为false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> var4;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>第三步，根据第二步生成的代理类，调用<code>cl.getConstructor(&#123; InvocationHandler.class &#125;)</code>, 相当于调用了代理类的构造方法, 在通过构造器调用<code>cons.newInstance(new RequestCtrlInvocationHandler(new ISubjectImpl()))</code>，最终强制转换ISubject对象。</li>\n<li>第四步，当代理对象调用<code>ISubject</code>的<code>request</code>时，首先进入<code>RequestCtrlInvocationHandler</code>的invoke方法，在该方法的最后，通过method.invoke(…)来真正调用<code>ISubjectImpl.request</code></li>\n</ul>\n<p> 问题1: 代理为什么需要实现某个接口, 继承某个类, 不可以代理吗?<br> 答: 代理描述的场景是代理目标类所有的方法, 如果目标类只是继承的话, 它并不一定重写了所有的方法, 所以有些方法没办法代理. 如果要对没有实现任何接口的类, 可以使用CGLIB, 为目标类生成一个子类, 就可以通过子类调用父类的方法, 并在方法的前后加上pre-process或者post-process</p>\n"},{"title":"java-reflection","date":"2021-08-12T09:46:37.000Z","_content":"反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。\n\n{% blockquote Oracle %}\nReflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.\nThe API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.\n{% endblockquote %}\n\n\n# 反射原理\n简言之，反射是为了在运行时获得程序中类的属性和方法等信息。在Java中程序中的类在编译时期就确定下来了，反射机制可以动态创建对象并调用其members，对象的类型在编译时是未知的，在运行时才知道运行的对象是谁。\n\n反射应用的三种形式，总结起来分别是：\n1. 运行时得到类的信息\n2. 类型转换\n3. instanceof\n\nJava中使用反射遵循以下流程。java.lang.reflect包中有Field, Method和Constructor（它们都继承AccessibleObject，实现了Member接口），在运行时JVM为类创建Field，Method和Constructor等的对象。你可以使用Constructor创建新对象，使用某个特定的Method对象调用invoke方法，或者使用Class.forName（当你没有对象的时候，你可以使用Class.forName得到类，当你拥有对象的时候，你可以通过该对象调用getClass，他们的结果是等价的），getSuperClass，getFields，getMethods，getConstructors来得到这些Member对象的数组。\n\n以上一直在强调“动态”，但是归根结底Java仍然是一门静态语言，与Python才是真动态，在Java里所有的类在编译时期就已经完全确定了，不会再增加新的类，但是Python不一样，在运行时才知道某个类的存在，可以在运行时往类中增加额外的属性，不像Java要使用什么必须先声明出来。\n\n很多人都认为反射在实际的 Java 开发应用中并不广泛，其实不然。当我们在使用 IDE(如 Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。\n\n反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。\n\n## Class.forName(...)\n反射中最常用的方法, 它与XXX.class.getClass()等价, 不做过多介绍\n`Class.forName(...).getContructor()`只能获取到`Member.PUBLIC`的构造方法, 一个类如果不声明任何构造方法就会由一个默认的构造方法, 如果这个类是`Member.PUBLIC`那么默认的构造方法也是, 如果这个类是包访问权限, 那么默认构造器也是包访问权限啊\n\n## Method Invoke\n在实际应用中, 经常会用到method.invoke, 比如在动态代理中, 附上其源码来分析一下: \n```java\n\n    /**\n     * Invokes the underlying method represented by this {@code Method}\n     * object, on the specified object with the specified parameters.\n     * Individual parameters are automatically unwrapped to match\n     * primitive formal parameters, and both primitive and reference\n     * parameters are subject to method invocation conversions as\n     * necessary.\n     *\n     * <p>If the underlying method is static, then the specified {@code obj}\n     * argument is ignored. It may be null.\n     *\n     * <p>If the number of formal parameters required by the underlying method is\n     * 0, the supplied {@code args} array may be of length 0 or null.\n     *\n     * <p>If the underlying method is an instance method, it is invoked\n     * using dynamic method lookup as documented in The Java Language\n     * Specification, Second Edition, section 15.12.4.4; in particular,\n     * overriding based on the runtime type of the target object will occur.\n     *\n     * <p>If the underlying method is static, the class that declared\n     * the method is initialized if it has not already been initialized.\n     *\n     * <p>If the method completes normally, the value it returns is\n     * returned to the caller of invoke; if the value has a primitive\n     * type, it is first appropriately wrapped in an object. However,\n     * if the value has the type of an array of a primitive type, the\n     * elements of the array are <i>not</i> wrapped in objects; in\n     * other words, an array of primitive type is returned.  If the\n     * underlying method return type is void, the invocation returns\n     * null.\n     *\n     * @param obj  the object the underlying method is invoked from\n     * @param args the arguments used for the method call\n     * @return the result of dispatching the method represented by\n     * this object on {@code obj} with parameters\n     * {@code args}\n     *\n     * @exception IllegalAccessException    if this {@code Method} object\n     *              is enforcing Java language access control and the underlying\n     *              method is inaccessible.\n     * @exception IllegalArgumentException  if the method is an\n     *              instance method and the specified object argument\n     *              is not an instance of the class or interface\n     *              declaring the underlying method (or of a subclass\n     *              or implementor thereof); if the number of actual\n     *              and formal parameters differ; if an unwrapping\n     *              conversion for primitive arguments fails; or if,\n     *              after possible unwrapping, a parameter value\n     *              cannot be converted to the corresponding formal\n     *              parameter type by a method invocation conversion.\n     * @exception InvocationTargetException if the underlying method\n     *              throws an exception.\n     * @exception NullPointerException      if the specified object is null\n     *              and the method is an instance method.\n     * @exception ExceptionInInitializerError if the initialization\n     * provoked by this method fails.\n     */\n    @CallerSensitive\n    public Object invoke(Object obj, Object... args)\n        throws IllegalAccessException, IllegalArgumentException,\n           InvocationTargetException\n    {\n        if (!override) {\n            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {\n                Class<?> caller = Reflection.getCallerClass();\n                checkAccess(caller, clazz, obj, modifiers);\n            }\n        }\n        MethodAccessor ma = methodAccessor;             // read volatile\n        if (ma == null) {\n            ma = acquireMethodAccessor();\n        }\n        return ma.invoke(obj, args);\n    }\n```\n以上源码中, 首先进行了权限检查，接着调用了methodAccessor的invoke方法，其中methodAccessor是一个共享的变量(volatile)。Reflection.getCallerClass()方法是一个native修饰的方法，native表示该方法的实现由C/C++来编写，放在本地的共享库中。\n\nMethodAccessor是一个接口, 最终通过NativeMethodAccessorImpl来实现invoke, 然后调用native方法invoke0:\n```java\nclass NativeMethodAccessorImpl extends MethodAccessorImpl {\n    private final Method method;\n    private DelegatingMethodAccessorImpl parent;\n    private int numInvocations;\n\n    NativeMethodAccessorImpl(Method var1) {\n        this.method = var1;\n    }\n\n    public Object invoke(Object var1, Object[] var2) throws IllegalArgumentException, InvocationTargetException {\n        if (++this.numInvocations > ReflectionFactory.inflationThreshold() && !ReflectUtil.isVMAnonymousClass(this.method.getDeclaringClass())) {\n            MethodAccessorImpl var3 = (MethodAccessorImpl)(new MethodAccessorGenerator()).generateMethod(this.method.getDeclaringClass(), this.method.getName(), this.method.getParameterTypes(), this.method.getReturnType(), this.method.getExceptionTypes(), this.method.getModifiers());\n            this.parent.setDelegate(var3);\n        }\n\n        return invoke0(this.method, var1, var2);\n    }\n\n    void setParent(DelegatingMethodAccessorImpl var1) {\n        this.parent = var1;\n    }\n\n    private static native Object invoke0(Method var0, Object var1, Object[] var2);\n}\n```\n","source":"_posts/java-reflection.md","raw":"---\ntitle: java-reflection\ndate: 2021-08-12 17:46:37\ncategories:\n- Java\ntags:\n- Reflection\n---\n反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。\n\n{% blockquote Oracle %}\nReflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.\nThe API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.\n{% endblockquote %}\n\n\n# 反射原理\n简言之，反射是为了在运行时获得程序中类的属性和方法等信息。在Java中程序中的类在编译时期就确定下来了，反射机制可以动态创建对象并调用其members，对象的类型在编译时是未知的，在运行时才知道运行的对象是谁。\n\n反射应用的三种形式，总结起来分别是：\n1. 运行时得到类的信息\n2. 类型转换\n3. instanceof\n\nJava中使用反射遵循以下流程。java.lang.reflect包中有Field, Method和Constructor（它们都继承AccessibleObject，实现了Member接口），在运行时JVM为类创建Field，Method和Constructor等的对象。你可以使用Constructor创建新对象，使用某个特定的Method对象调用invoke方法，或者使用Class.forName（当你没有对象的时候，你可以使用Class.forName得到类，当你拥有对象的时候，你可以通过该对象调用getClass，他们的结果是等价的），getSuperClass，getFields，getMethods，getConstructors来得到这些Member对象的数组。\n\n以上一直在强调“动态”，但是归根结底Java仍然是一门静态语言，与Python才是真动态，在Java里所有的类在编译时期就已经完全确定了，不会再增加新的类，但是Python不一样，在运行时才知道某个类的存在，可以在运行时往类中增加额外的属性，不像Java要使用什么必须先声明出来。\n\n很多人都认为反射在实际的 Java 开发应用中并不广泛，其实不然。当我们在使用 IDE(如 Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。\n\n反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。\n\n## Class.forName(...)\n反射中最常用的方法, 它与XXX.class.getClass()等价, 不做过多介绍\n`Class.forName(...).getContructor()`只能获取到`Member.PUBLIC`的构造方法, 一个类如果不声明任何构造方法就会由一个默认的构造方法, 如果这个类是`Member.PUBLIC`那么默认的构造方法也是, 如果这个类是包访问权限, 那么默认构造器也是包访问权限啊\n\n## Method Invoke\n在实际应用中, 经常会用到method.invoke, 比如在动态代理中, 附上其源码来分析一下: \n```java\n\n    /**\n     * Invokes the underlying method represented by this {@code Method}\n     * object, on the specified object with the specified parameters.\n     * Individual parameters are automatically unwrapped to match\n     * primitive formal parameters, and both primitive and reference\n     * parameters are subject to method invocation conversions as\n     * necessary.\n     *\n     * <p>If the underlying method is static, then the specified {@code obj}\n     * argument is ignored. It may be null.\n     *\n     * <p>If the number of formal parameters required by the underlying method is\n     * 0, the supplied {@code args} array may be of length 0 or null.\n     *\n     * <p>If the underlying method is an instance method, it is invoked\n     * using dynamic method lookup as documented in The Java Language\n     * Specification, Second Edition, section 15.12.4.4; in particular,\n     * overriding based on the runtime type of the target object will occur.\n     *\n     * <p>If the underlying method is static, the class that declared\n     * the method is initialized if it has not already been initialized.\n     *\n     * <p>If the method completes normally, the value it returns is\n     * returned to the caller of invoke; if the value has a primitive\n     * type, it is first appropriately wrapped in an object. However,\n     * if the value has the type of an array of a primitive type, the\n     * elements of the array are <i>not</i> wrapped in objects; in\n     * other words, an array of primitive type is returned.  If the\n     * underlying method return type is void, the invocation returns\n     * null.\n     *\n     * @param obj  the object the underlying method is invoked from\n     * @param args the arguments used for the method call\n     * @return the result of dispatching the method represented by\n     * this object on {@code obj} with parameters\n     * {@code args}\n     *\n     * @exception IllegalAccessException    if this {@code Method} object\n     *              is enforcing Java language access control and the underlying\n     *              method is inaccessible.\n     * @exception IllegalArgumentException  if the method is an\n     *              instance method and the specified object argument\n     *              is not an instance of the class or interface\n     *              declaring the underlying method (or of a subclass\n     *              or implementor thereof); if the number of actual\n     *              and formal parameters differ; if an unwrapping\n     *              conversion for primitive arguments fails; or if,\n     *              after possible unwrapping, a parameter value\n     *              cannot be converted to the corresponding formal\n     *              parameter type by a method invocation conversion.\n     * @exception InvocationTargetException if the underlying method\n     *              throws an exception.\n     * @exception NullPointerException      if the specified object is null\n     *              and the method is an instance method.\n     * @exception ExceptionInInitializerError if the initialization\n     * provoked by this method fails.\n     */\n    @CallerSensitive\n    public Object invoke(Object obj, Object... args)\n        throws IllegalAccessException, IllegalArgumentException,\n           InvocationTargetException\n    {\n        if (!override) {\n            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {\n                Class<?> caller = Reflection.getCallerClass();\n                checkAccess(caller, clazz, obj, modifiers);\n            }\n        }\n        MethodAccessor ma = methodAccessor;             // read volatile\n        if (ma == null) {\n            ma = acquireMethodAccessor();\n        }\n        return ma.invoke(obj, args);\n    }\n```\n以上源码中, 首先进行了权限检查，接着调用了methodAccessor的invoke方法，其中methodAccessor是一个共享的变量(volatile)。Reflection.getCallerClass()方法是一个native修饰的方法，native表示该方法的实现由C/C++来编写，放在本地的共享库中。\n\nMethodAccessor是一个接口, 最终通过NativeMethodAccessorImpl来实现invoke, 然后调用native方法invoke0:\n```java\nclass NativeMethodAccessorImpl extends MethodAccessorImpl {\n    private final Method method;\n    private DelegatingMethodAccessorImpl parent;\n    private int numInvocations;\n\n    NativeMethodAccessorImpl(Method var1) {\n        this.method = var1;\n    }\n\n    public Object invoke(Object var1, Object[] var2) throws IllegalArgumentException, InvocationTargetException {\n        if (++this.numInvocations > ReflectionFactory.inflationThreshold() && !ReflectUtil.isVMAnonymousClass(this.method.getDeclaringClass())) {\n            MethodAccessorImpl var3 = (MethodAccessorImpl)(new MethodAccessorGenerator()).generateMethod(this.method.getDeclaringClass(), this.method.getName(), this.method.getParameterTypes(), this.method.getReturnType(), this.method.getExceptionTypes(), this.method.getModifiers());\n            this.parent.setDelegate(var3);\n        }\n\n        return invoke0(this.method, var1, var2);\n    }\n\n    void setParent(DelegatingMethodAccessorImpl var1) {\n        this.parent = var1;\n    }\n\n    private static native Object invoke0(Method var0, Object var1, Object[] var2);\n}\n```\n","slug":"java-reflection","published":1,"updated":"2021-12-30T03:03:32.637Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxsdzpys000pxotga2iw86jk","content":"<p>反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</p>\n<blockquote><p>Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.<br>The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.</p>\n<footer><strong>Oracle</strong></footer></blockquote>\n\n\n<h1 id=\"反射原理\"><a href=\"#反射原理\" class=\"headerlink\" title=\"反射原理\"></a>反射原理</h1><p>简言之，反射是为了在运行时获得程序中类的属性和方法等信息。在Java中程序中的类在编译时期就确定下来了，反射机制可以动态创建对象并调用其members，对象的类型在编译时是未知的，在运行时才知道运行的对象是谁。</p>\n<p>反射应用的三种形式，总结起来分别是：</p>\n<ol>\n<li>运行时得到类的信息</li>\n<li>类型转换</li>\n<li>instanceof</li>\n</ol>\n<p>Java中使用反射遵循以下流程。java.lang.reflect包中有Field, Method和Constructor（它们都继承AccessibleObject，实现了Member接口），在运行时JVM为类创建Field，Method和Constructor等的对象。你可以使用Constructor创建新对象，使用某个特定的Method对象调用invoke方法，或者使用Class.forName（当你没有对象的时候，你可以使用Class.forName得到类，当你拥有对象的时候，你可以通过该对象调用getClass，他们的结果是等价的），getSuperClass，getFields，getMethods，getConstructors来得到这些Member对象的数组。</p>\n<p>以上一直在强调“动态”，但是归根结底Java仍然是一门静态语言，与Python才是真动态，在Java里所有的类在编译时期就已经完全确定了，不会再增加新的类，但是Python不一样，在运行时才知道某个类的存在，可以在运行时往类中增加额外的属性，不像Java要使用什么必须先声明出来。</p>\n<p>很多人都认为反射在实际的 Java 开发应用中并不广泛，其实不然。当我们在使用 IDE(如 Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。</p>\n<p>反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。</p>\n<h2 id=\"Class-forName-…\"><a href=\"#Class-forName-…\" class=\"headerlink\" title=\"Class.forName(…)\"></a>Class.forName(…)</h2><p>反射中最常用的方法, 它与XXX.class.getClass()等价, 不做过多介绍<br><code>Class.forName(...).getContructor()</code>只能获取到<code>Member.PUBLIC</code>的构造方法, 一个类如果不声明任何构造方法就会由一个默认的构造方法, 如果这个类是<code>Member.PUBLIC</code>那么默认的构造方法也是, 如果这个类是包访问权限, 那么默认构造器也是包访问权限啊</p>\n<h2 id=\"Method-Invoke\"><a href=\"#Method-Invoke\" class=\"headerlink\" title=\"Method Invoke\"></a>Method Invoke</h2><p>在实际应用中, 经常会用到method.invoke, 比如在动态代理中, 附上其源码来分析一下: </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Invokes the underlying method represented by this &#123;<span class=\"doctag\">@code</span> Method&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * object, on the specified object with the specified parameters.</span></span><br><span class=\"line\"><span class=\"comment\"> * Individual parameters are automatically unwrapped to match</span></span><br><span class=\"line\"><span class=\"comment\"> * primitive formal parameters, and both primitive and reference</span></span><br><span class=\"line\"><span class=\"comment\"> * parameters are subject to method invocation conversions as</span></span><br><span class=\"line\"><span class=\"comment\"> * necessary.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;If the underlying method is static, then the specified &#123;<span class=\"doctag\">@code</span> obj&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * argument is ignored. It may be null.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;If the number of formal parameters required by the underlying method is</span></span><br><span class=\"line\"><span class=\"comment\"> * 0, the supplied &#123;<span class=\"doctag\">@code</span> args&#125; array may be of length 0 or null.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;If the underlying method is an instance method, it is invoked</span></span><br><span class=\"line\"><span class=\"comment\"> * using dynamic method lookup as documented in The Java Language</span></span><br><span class=\"line\"><span class=\"comment\"> * Specification, Second Edition, section 15.12.4.4; in particular,</span></span><br><span class=\"line\"><span class=\"comment\"> * overriding based on the runtime type of the target object will occur.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;If the underlying method is static, the class that declared</span></span><br><span class=\"line\"><span class=\"comment\"> * the method is initialized if it has not already been initialized.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;If the method completes normally, the value it returns is</span></span><br><span class=\"line\"><span class=\"comment\"> * returned to the caller of invoke; if the value has a primitive</span></span><br><span class=\"line\"><span class=\"comment\"> * type, it is first appropriately wrapped in an object. However,</span></span><br><span class=\"line\"><span class=\"comment\"> * if the value has the type of an array of a primitive type, the</span></span><br><span class=\"line\"><span class=\"comment\"> * elements of the array are &lt;i&gt;not&lt;/i&gt; wrapped in objects; in</span></span><br><span class=\"line\"><span class=\"comment\"> * other words, an array of primitive type is returned.  If the</span></span><br><span class=\"line\"><span class=\"comment\"> * underlying method return type is void, the invocation returns</span></span><br><span class=\"line\"><span class=\"comment\"> * null.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> obj  the object the underlying method is invoked from</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> args the arguments used for the method call</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the result of dispatching the method represented by</span></span><br><span class=\"line\"><span class=\"comment\"> * this object on &#123;<span class=\"doctag\">@code</span> obj&#125; with parameters</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> args&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@exception</span> IllegalAccessException    if this &#123;<span class=\"doctag\">@code</span> Method&#125; object</span></span><br><span class=\"line\"><span class=\"comment\"> *              is enforcing Java language access control and the underlying</span></span><br><span class=\"line\"><span class=\"comment\"> *              method is inaccessible.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@exception</span> IllegalArgumentException  if the method is an</span></span><br><span class=\"line\"><span class=\"comment\"> *              instance method and the specified object argument</span></span><br><span class=\"line\"><span class=\"comment\"> *              is not an instance of the class or interface</span></span><br><span class=\"line\"><span class=\"comment\"> *              declaring the underlying method (or of a subclass</span></span><br><span class=\"line\"><span class=\"comment\"> *              or implementor thereof); if the number of actual</span></span><br><span class=\"line\"><span class=\"comment\"> *              and formal parameters differ; if an unwrapping</span></span><br><span class=\"line\"><span class=\"comment\"> *              conversion for primitive arguments fails; or if,</span></span><br><span class=\"line\"><span class=\"comment\"> *              after possible unwrapping, a parameter value</span></span><br><span class=\"line\"><span class=\"comment\"> *              cannot be converted to the corresponding formal</span></span><br><span class=\"line\"><span class=\"comment\"> *              parameter type by a method invocation conversion.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@exception</span> InvocationTargetException if the underlying method</span></span><br><span class=\"line\"><span class=\"comment\"> *              throws an exception.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@exception</span> NullPointerException      if the specified object is null</span></span><br><span class=\"line\"><span class=\"comment\"> *              and the method is an instance method.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@exception</span> ExceptionInInitializerError if the initialization</span></span><br><span class=\"line\"><span class=\"comment\"> * provoked by this method fails.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@CallerSensitive</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object obj, Object... args)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class=\"line\"><span class=\"function\">       InvocationTargetException</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!override) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class=\"line\">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class=\"line\">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    MethodAccessor ma = methodAccessor;             <span class=\"comment\">// read volatile</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ma == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ma = acquireMethodAccessor();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ma.invoke(obj, args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上源码中, 首先进行了权限检查，接着调用了methodAccessor的invoke方法，其中methodAccessor是一个共享的变量(volatile)。Reflection.getCallerClass()方法是一个native修饰的方法，native表示该方法的实现由C/C++来编写，放在本地的共享库中。</p>\n<p>MethodAccessor是一个接口, 最终通过NativeMethodAccessorImpl来实现invoke, 然后调用native方法invoke0:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NativeMethodAccessorImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">MethodAccessorImpl</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Method method;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> DelegatingMethodAccessorImpl parent;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> numInvocations;</span><br><span class=\"line\"></span><br><span class=\"line\">    NativeMethodAccessorImpl(Method var1) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.method = var1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object var1, Object[] var2)</span> <span class=\"keyword\">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++<span class=\"keyword\">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class=\"keyword\">this</span>.method.getDeclaringClass())) &#123;</span><br><span class=\"line\">            MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class=\"keyword\">new</span> MethodAccessorGenerator()).generateMethod(<span class=\"keyword\">this</span>.method.getDeclaringClass(), <span class=\"keyword\">this</span>.method.getName(), <span class=\"keyword\">this</span>.method.getParameterTypes(), <span class=\"keyword\">this</span>.method.getReturnType(), <span class=\"keyword\">this</span>.method.getExceptionTypes(), <span class=\"keyword\">this</span>.method.getModifiers());</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.parent.setDelegate(var3);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> invoke0(<span class=\"keyword\">this</span>.method, var1, var2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setParent</span><span class=\"params\">(DelegatingMethodAccessorImpl var1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.parent = var1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> Object <span class=\"title\">invoke0</span><span class=\"params\">(Method var0, Object var1, Object[] var2)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</p>\n<blockquote><p>Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.<br>The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.</p>\n<footer><strong>Oracle</strong></footer></blockquote>\n\n\n<h1 id=\"反射原理\"><a href=\"#反射原理\" class=\"headerlink\" title=\"反射原理\"></a>反射原理</h1><p>简言之，反射是为了在运行时获得程序中类的属性和方法等信息。在Java中程序中的类在编译时期就确定下来了，反射机制可以动态创建对象并调用其members，对象的类型在编译时是未知的，在运行时才知道运行的对象是谁。</p>\n<p>反射应用的三种形式，总结起来分别是：</p>\n<ol>\n<li>运行时得到类的信息</li>\n<li>类型转换</li>\n<li>instanceof</li>\n</ol>\n<p>Java中使用反射遵循以下流程。java.lang.reflect包中有Field, Method和Constructor（它们都继承AccessibleObject，实现了Member接口），在运行时JVM为类创建Field，Method和Constructor等的对象。你可以使用Constructor创建新对象，使用某个特定的Method对象调用invoke方法，或者使用Class.forName（当你没有对象的时候，你可以使用Class.forName得到类，当你拥有对象的时候，你可以通过该对象调用getClass，他们的结果是等价的），getSuperClass，getFields，getMethods，getConstructors来得到这些Member对象的数组。</p>\n<p>以上一直在强调“动态”，但是归根结底Java仍然是一门静态语言，与Python才是真动态，在Java里所有的类在编译时期就已经完全确定了，不会再增加新的类，但是Python不一样，在运行时才知道某个类的存在，可以在运行时往类中增加额外的属性，不像Java要使用什么必须先声明出来。</p>\n<p>很多人都认为反射在实际的 Java 开发应用中并不广泛，其实不然。当我们在使用 IDE(如 Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。</p>\n<p>反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。</p>\n<h2 id=\"Class-forName-…\"><a href=\"#Class-forName-…\" class=\"headerlink\" title=\"Class.forName(…)\"></a>Class.forName(…)</h2><p>反射中最常用的方法, 它与XXX.class.getClass()等价, 不做过多介绍<br><code>Class.forName(...).getContructor()</code>只能获取到<code>Member.PUBLIC</code>的构造方法, 一个类如果不声明任何构造方法就会由一个默认的构造方法, 如果这个类是<code>Member.PUBLIC</code>那么默认的构造方法也是, 如果这个类是包访问权限, 那么默认构造器也是包访问权限啊</p>\n<h2 id=\"Method-Invoke\"><a href=\"#Method-Invoke\" class=\"headerlink\" title=\"Method Invoke\"></a>Method Invoke</h2><p>在实际应用中, 经常会用到method.invoke, 比如在动态代理中, 附上其源码来分析一下: </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Invokes the underlying method represented by this &#123;<span class=\"doctag\">@code</span> Method&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * object, on the specified object with the specified parameters.</span></span><br><span class=\"line\"><span class=\"comment\"> * Individual parameters are automatically unwrapped to match</span></span><br><span class=\"line\"><span class=\"comment\"> * primitive formal parameters, and both primitive and reference</span></span><br><span class=\"line\"><span class=\"comment\"> * parameters are subject to method invocation conversions as</span></span><br><span class=\"line\"><span class=\"comment\"> * necessary.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;If the underlying method is static, then the specified &#123;<span class=\"doctag\">@code</span> obj&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * argument is ignored. It may be null.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;If the number of formal parameters required by the underlying method is</span></span><br><span class=\"line\"><span class=\"comment\"> * 0, the supplied &#123;<span class=\"doctag\">@code</span> args&#125; array may be of length 0 or null.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;If the underlying method is an instance method, it is invoked</span></span><br><span class=\"line\"><span class=\"comment\"> * using dynamic method lookup as documented in The Java Language</span></span><br><span class=\"line\"><span class=\"comment\"> * Specification, Second Edition, section 15.12.4.4; in particular,</span></span><br><span class=\"line\"><span class=\"comment\"> * overriding based on the runtime type of the target object will occur.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;If the underlying method is static, the class that declared</span></span><br><span class=\"line\"><span class=\"comment\"> * the method is initialized if it has not already been initialized.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;If the method completes normally, the value it returns is</span></span><br><span class=\"line\"><span class=\"comment\"> * returned to the caller of invoke; if the value has a primitive</span></span><br><span class=\"line\"><span class=\"comment\"> * type, it is first appropriately wrapped in an object. However,</span></span><br><span class=\"line\"><span class=\"comment\"> * if the value has the type of an array of a primitive type, the</span></span><br><span class=\"line\"><span class=\"comment\"> * elements of the array are &lt;i&gt;not&lt;/i&gt; wrapped in objects; in</span></span><br><span class=\"line\"><span class=\"comment\"> * other words, an array of primitive type is returned.  If the</span></span><br><span class=\"line\"><span class=\"comment\"> * underlying method return type is void, the invocation returns</span></span><br><span class=\"line\"><span class=\"comment\"> * null.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> obj  the object the underlying method is invoked from</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> args the arguments used for the method call</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the result of dispatching the method represented by</span></span><br><span class=\"line\"><span class=\"comment\"> * this object on &#123;<span class=\"doctag\">@code</span> obj&#125; with parameters</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> args&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@exception</span> IllegalAccessException    if this &#123;<span class=\"doctag\">@code</span> Method&#125; object</span></span><br><span class=\"line\"><span class=\"comment\"> *              is enforcing Java language access control and the underlying</span></span><br><span class=\"line\"><span class=\"comment\"> *              method is inaccessible.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@exception</span> IllegalArgumentException  if the method is an</span></span><br><span class=\"line\"><span class=\"comment\"> *              instance method and the specified object argument</span></span><br><span class=\"line\"><span class=\"comment\"> *              is not an instance of the class or interface</span></span><br><span class=\"line\"><span class=\"comment\"> *              declaring the underlying method (or of a subclass</span></span><br><span class=\"line\"><span class=\"comment\"> *              or implementor thereof); if the number of actual</span></span><br><span class=\"line\"><span class=\"comment\"> *              and formal parameters differ; if an unwrapping</span></span><br><span class=\"line\"><span class=\"comment\"> *              conversion for primitive arguments fails; or if,</span></span><br><span class=\"line\"><span class=\"comment\"> *              after possible unwrapping, a parameter value</span></span><br><span class=\"line\"><span class=\"comment\"> *              cannot be converted to the corresponding formal</span></span><br><span class=\"line\"><span class=\"comment\"> *              parameter type by a method invocation conversion.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@exception</span> InvocationTargetException if the underlying method</span></span><br><span class=\"line\"><span class=\"comment\"> *              throws an exception.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@exception</span> NullPointerException      if the specified object is null</span></span><br><span class=\"line\"><span class=\"comment\"> *              and the method is an instance method.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@exception</span> ExceptionInInitializerError if the initialization</span></span><br><span class=\"line\"><span class=\"comment\"> * provoked by this method fails.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@CallerSensitive</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object obj, Object... args)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class=\"line\"><span class=\"function\">       InvocationTargetException</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!override) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class=\"line\">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class=\"line\">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    MethodAccessor ma = methodAccessor;             <span class=\"comment\">// read volatile</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ma == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ma = acquireMethodAccessor();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ma.invoke(obj, args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上源码中, 首先进行了权限检查，接着调用了methodAccessor的invoke方法，其中methodAccessor是一个共享的变量(volatile)。Reflection.getCallerClass()方法是一个native修饰的方法，native表示该方法的实现由C/C++来编写，放在本地的共享库中。</p>\n<p>MethodAccessor是一个接口, 最终通过NativeMethodAccessorImpl来实现invoke, 然后调用native方法invoke0:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NativeMethodAccessorImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">MethodAccessorImpl</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Method method;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> DelegatingMethodAccessorImpl parent;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> numInvocations;</span><br><span class=\"line\"></span><br><span class=\"line\">    NativeMethodAccessorImpl(Method var1) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.method = var1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object var1, Object[] var2)</span> <span class=\"keyword\">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++<span class=\"keyword\">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class=\"keyword\">this</span>.method.getDeclaringClass())) &#123;</span><br><span class=\"line\">            MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class=\"keyword\">new</span> MethodAccessorGenerator()).generateMethod(<span class=\"keyword\">this</span>.method.getDeclaringClass(), <span class=\"keyword\">this</span>.method.getName(), <span class=\"keyword\">this</span>.method.getParameterTypes(), <span class=\"keyword\">this</span>.method.getReturnType(), <span class=\"keyword\">this</span>.method.getExceptionTypes(), <span class=\"keyword\">this</span>.method.getModifiers());</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.parent.setDelegate(var3);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> invoke0(<span class=\"keyword\">this</span>.method, var1, var2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setParent</span><span class=\"params\">(DelegatingMethodAccessorImpl var1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.parent = var1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> Object <span class=\"title\">invoke0</span><span class=\"params\">(Method var0, Object var1, Object[] var2)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"流式编程","date":"2021-06-07T10:59:42.000Z","_content":"\nJava8引入新的概念Streams. 如何将此融入到现有的生态百万行代码的类库中. 一个巨大挑战来自使用接口的库, 如果将一个新的方法添加到接口, 那就破坏了每一个实现接口的类,因为这些类要实现你新添加的方法.   \n设计者给出的解决方案是, 在接口中添加被default修饰的方法.\n通过这种方案, 将流式平滑地嵌入到现有的类中. \n流的操作有三种: creating streams, intermediate operations, terminal operations.\n\n{% blockquote Bruce Eckel, OnJava8 %}\n**Declarative programming** is a style where we state what we want done, rather than\nspecifying how, and it’s what you see in functional programming. Notice it’s much\nmore difficult to understand the **imperative programming**.\n{% endblockquote %}\n对比一下声明式编程和命令式编程\n```java\n// Declarative programming\nnew Random(47).ints(5, 20).distinct().limit(7).sorted().forEach(System.out::println);\n```\n\n```java\n// Imperative programming\nRandom rand = new Random(47);\nSortedSet<Integer> rints = new TreeSet<>();\nwhile(rints.size() < 7) {\n    int r = rand.nextInt(20);\n    if(r < 5) continue;\n    rints.add(r);\n}\nSystem.out.println(rints);\n```\n显然命令式编程更难理解, 而且在Streams过程中, 没有明显地看到任何变量的定义.\n语义清晰是Java Stream API的优点之一.\n\n# Creating Streams\n1. 通过Streams.of(...)将一组元素转换为Stream\n2. 每隔集合可以通过调用其`.stream()`方法来产生一个流.\n3. `Stream.generate(...)`, generate接收一个参数`Supplier<T>`, 通过调用实现了`Supplier<T>`接口的类的get方法(也可以传Lambda表达式, 原理也是有个类实现了Supplier接口, 具体在函数式编程里有详细介绍). 不过generate必须有一个限制, 不能无限制的运行. 否则会造成`java.lang.OutOfMemoryError: Java heap space`错误. 比如, 中间加入了limit函数\n```java\nStream.generate(() -> \"h\").limit(30).collect(Collectors.joining());\n```\n4. `Stream.iterate(...)`, iterate接收的参数第一个是seed, 第二个其实是`Function<T>`, 如下例子, 生成斐波那契数列:\n```java\nint x = 1;\n// seed将会作为i的初始化值, 返回值y将作为参数再次会传递给该函数\nStream.iterate(0, (i) -> {int y = i + x; x = i; return y;}).limit(30).forEach(System.out::println);\n```\n5. 使用建造者模式. 其实建造者模式类似于新建一个集合, 然后往里put元素.\n```java\nStream.Builder<String> builder = Stream.builder();\nString res = builder.build().map(...).collect(Collector.joining(\" \"));\n```\n6. `Arrays.stream()`\n\n# Intermediate Operations\n1. .map(...)\n2. .peek(...), 使用peek()帮助调试\n3. .skip(...)\n4. .limit(...)\n5. .sorted(Comparator.reverseOrder())\n6. .filter(Predicate)\n7. .distinct()\n8. parallel(), 这个重点说一下, 这个是将流中计算机制换为并行计算, 所以最终输出元素的顺序是随机的. 要是再此基础上要得到有序的输出, 需要上如`forEachOrdered(...)`等的Terminal Operations\n\n\n# Terminal Operations\n1. .collect(Collector.toList())\n2. .toArray()\n3. .forEach()\n4. .reduce(...), 最终输出的是一个元素. \n```java\n// Reduce函数功能展示\nimport java.util.Random;\nimport java.util.stream.Stream;\n\nclass IntegerSupplier {\n    // 生成一个100以内的随机数流(建造者模式)\n\tstatic Stream<Integer> supply() {\n\t\tRandom rand = new Random(15);\n\t\tfinal int BOUND = 100;\n\t\tStream.Builder<Integer> builder = Stream.builder();\n\t\tfor(int i = 0; i < 30; i++) {\n\t\t\tbuilder.add(rand.nextInt(BOUND));\n\t\t}\n\t\treturn builder.build();\n\t}\n}\n\npublic class Reduce {\n\tpublic static void main(String[] args) {\n\t\t// reduce(BinaryOperator), BinaryOperator这个函数式接口对应的函数只有两个参数\n\t\t// 其中fr0既作为初始化的第一个值, 又作为每次的返回值传入, 在输出中可以看到\n\t\t// 最终reduce返回的值, Integer被Optional包裹\n\t\tIntegerSupplier.supply().reduce((fr0, fr1) -> {\n\t\t\tSystem.out.println(fr0 + \"--compare to--\" + fr1);\n\t\t\treturn fr0 < fr1 ? fr0 : fr1;\n\t\t}).ifPresent(System.out::println);\n\t}\n}\n// output:\n/* 41--compare to--72\n * 72--compare to--38\n * 72--compare to--67\n * 72--compare to--85\n * 85--compare to--60\n * 85--compare to--59\n * Optional[85]\n*/\n```\n\n### Optional类\n为了防止流执行的过程中, 出现\"空流\"而中断抛出异常, 所以引入了Optional类, 为空时将会返回`Optional.empty`\n```java\n// 空流, 等价于: Stream<String> s = Stream.empty();\nStream.<String>empty().findFirst()\n// output: Optional.empty\n```\n原理是将返回值塞到了Optional对象中, Optional类提供了很多诸如`isPresent()`, `orElse`, `orElseGet`等方法, 在Python3.7以后引入类型系统后也有了Optional类型, 如果一个变量被标识为Optional, 那么这个对象可能为none.\n\n","source":"_posts/java-streams.md","raw":"---\ntitle: 流式编程\ndate: 2021-06-07 18:59:42\ncategories:\n- Java\ntags:\n- Stream\n---\n\nJava8引入新的概念Streams. 如何将此融入到现有的生态百万行代码的类库中. 一个巨大挑战来自使用接口的库, 如果将一个新的方法添加到接口, 那就破坏了每一个实现接口的类,因为这些类要实现你新添加的方法.   \n设计者给出的解决方案是, 在接口中添加被default修饰的方法.\n通过这种方案, 将流式平滑地嵌入到现有的类中. \n流的操作有三种: creating streams, intermediate operations, terminal operations.\n\n{% blockquote Bruce Eckel, OnJava8 %}\n**Declarative programming** is a style where we state what we want done, rather than\nspecifying how, and it’s what you see in functional programming. Notice it’s much\nmore difficult to understand the **imperative programming**.\n{% endblockquote %}\n对比一下声明式编程和命令式编程\n```java\n// Declarative programming\nnew Random(47).ints(5, 20).distinct().limit(7).sorted().forEach(System.out::println);\n```\n\n```java\n// Imperative programming\nRandom rand = new Random(47);\nSortedSet<Integer> rints = new TreeSet<>();\nwhile(rints.size() < 7) {\n    int r = rand.nextInt(20);\n    if(r < 5) continue;\n    rints.add(r);\n}\nSystem.out.println(rints);\n```\n显然命令式编程更难理解, 而且在Streams过程中, 没有明显地看到任何变量的定义.\n语义清晰是Java Stream API的优点之一.\n\n# Creating Streams\n1. 通过Streams.of(...)将一组元素转换为Stream\n2. 每隔集合可以通过调用其`.stream()`方法来产生一个流.\n3. `Stream.generate(...)`, generate接收一个参数`Supplier<T>`, 通过调用实现了`Supplier<T>`接口的类的get方法(也可以传Lambda表达式, 原理也是有个类实现了Supplier接口, 具体在函数式编程里有详细介绍). 不过generate必须有一个限制, 不能无限制的运行. 否则会造成`java.lang.OutOfMemoryError: Java heap space`错误. 比如, 中间加入了limit函数\n```java\nStream.generate(() -> \"h\").limit(30).collect(Collectors.joining());\n```\n4. `Stream.iterate(...)`, iterate接收的参数第一个是seed, 第二个其实是`Function<T>`, 如下例子, 生成斐波那契数列:\n```java\nint x = 1;\n// seed将会作为i的初始化值, 返回值y将作为参数再次会传递给该函数\nStream.iterate(0, (i) -> {int y = i + x; x = i; return y;}).limit(30).forEach(System.out::println);\n```\n5. 使用建造者模式. 其实建造者模式类似于新建一个集合, 然后往里put元素.\n```java\nStream.Builder<String> builder = Stream.builder();\nString res = builder.build().map(...).collect(Collector.joining(\" \"));\n```\n6. `Arrays.stream()`\n\n# Intermediate Operations\n1. .map(...)\n2. .peek(...), 使用peek()帮助调试\n3. .skip(...)\n4. .limit(...)\n5. .sorted(Comparator.reverseOrder())\n6. .filter(Predicate)\n7. .distinct()\n8. parallel(), 这个重点说一下, 这个是将流中计算机制换为并行计算, 所以最终输出元素的顺序是随机的. 要是再此基础上要得到有序的输出, 需要上如`forEachOrdered(...)`等的Terminal Operations\n\n\n# Terminal Operations\n1. .collect(Collector.toList())\n2. .toArray()\n3. .forEach()\n4. .reduce(...), 最终输出的是一个元素. \n```java\n// Reduce函数功能展示\nimport java.util.Random;\nimport java.util.stream.Stream;\n\nclass IntegerSupplier {\n    // 生成一个100以内的随机数流(建造者模式)\n\tstatic Stream<Integer> supply() {\n\t\tRandom rand = new Random(15);\n\t\tfinal int BOUND = 100;\n\t\tStream.Builder<Integer> builder = Stream.builder();\n\t\tfor(int i = 0; i < 30; i++) {\n\t\t\tbuilder.add(rand.nextInt(BOUND));\n\t\t}\n\t\treturn builder.build();\n\t}\n}\n\npublic class Reduce {\n\tpublic static void main(String[] args) {\n\t\t// reduce(BinaryOperator), BinaryOperator这个函数式接口对应的函数只有两个参数\n\t\t// 其中fr0既作为初始化的第一个值, 又作为每次的返回值传入, 在输出中可以看到\n\t\t// 最终reduce返回的值, Integer被Optional包裹\n\t\tIntegerSupplier.supply().reduce((fr0, fr1) -> {\n\t\t\tSystem.out.println(fr0 + \"--compare to--\" + fr1);\n\t\t\treturn fr0 < fr1 ? fr0 : fr1;\n\t\t}).ifPresent(System.out::println);\n\t}\n}\n// output:\n/* 41--compare to--72\n * 72--compare to--38\n * 72--compare to--67\n * 72--compare to--85\n * 85--compare to--60\n * 85--compare to--59\n * Optional[85]\n*/\n```\n\n### Optional类\n为了防止流执行的过程中, 出现\"空流\"而中断抛出异常, 所以引入了Optional类, 为空时将会返回`Optional.empty`\n```java\n// 空流, 等价于: Stream<String> s = Stream.empty();\nStream.<String>empty().findFirst()\n// output: Optional.empty\n```\n原理是将返回值塞到了Optional对象中, Optional类提供了很多诸如`isPresent()`, `orElse`, `orElseGet`等方法, 在Python3.7以后引入类型系统后也有了Optional类型, 如果一个变量被标识为Optional, 那么这个对象可能为none.\n\n","slug":"java-streams","published":1,"updated":"2021-12-30T03:03:41.445Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxsdzpyt000rxotg46dx0vzu","content":"<p>Java8引入新的概念Streams. 如何将此融入到现有的生态百万行代码的类库中. 一个巨大挑战来自使用接口的库, 如果将一个新的方法添加到接口, 那就破坏了每一个实现接口的类,因为这些类要实现你新添加的方法.<br>设计者给出的解决方案是, 在接口中添加被default修饰的方法.<br>通过这种方案, 将流式平滑地嵌入到现有的类中.<br>流的操作有三种: creating streams, intermediate operations, terminal operations.</p>\n<blockquote><p><strong>Declarative programming</strong> is a style where we state what we want done, rather than<br>specifying how, and it’s what you see in functional programming. Notice it’s much<br>more difficult to understand the <strong>imperative programming</strong>.</p>\n<footer><strong>Bruce Eckel</strong><cite>OnJava8</cite></footer></blockquote>\n<p>对比一下声明式编程和命令式编程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Declarative programming</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Random(<span class=\"number\">47</span>).ints(<span class=\"number\">5</span>, <span class=\"number\">20</span>).distinct().limit(<span class=\"number\">7</span>).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Imperative programming</span></span><br><span class=\"line\">Random rand = <span class=\"keyword\">new</span> Random(<span class=\"number\">47</span>);</span><br><span class=\"line\">SortedSet&lt;Integer&gt; rints = <span class=\"keyword\">new</span> TreeSet&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(rints.size() &lt; <span class=\"number\">7</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = rand.nextInt(<span class=\"number\">20</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt; <span class=\"number\">5</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    rints.add(r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(rints);</span><br></pre></td></tr></table></figure>\n<p>显然命令式编程更难理解, 而且在Streams过程中, 没有明显地看到任何变量的定义.<br>语义清晰是Java Stream API的优点之一.</p>\n<h1 id=\"Creating-Streams\"><a href=\"#Creating-Streams\" class=\"headerlink\" title=\"Creating Streams\"></a>Creating Streams</h1><ol>\n<li>通过Streams.of(…)将一组元素转换为Stream</li>\n<li>每隔集合可以通过调用其<code>.stream()</code>方法来产生一个流.</li>\n<li><code>Stream.generate(...)</code>, generate接收一个参数<code>Supplier&lt;T&gt;</code>, 通过调用实现了<code>Supplier&lt;T&gt;</code>接口的类的get方法(也可以传Lambda表达式, 原理也是有个类实现了Supplier接口, 具体在函数式编程里有详细介绍). 不过generate必须有一个限制, 不能无限制的运行. 否则会造成<code>java.lang.OutOfMemoryError: Java heap space</code>错误. 比如, 中间加入了limit函数<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.generate(() -&gt; <span class=\"string\">&quot;h&quot;</span>).limit(<span class=\"number\">30</span>).collect(Collectors.joining());</span><br></pre></td></tr></table></figure></li>\n<li><code>Stream.iterate(...)</code>, iterate接收的参数第一个是seed, 第二个其实是<code>Function&lt;T&gt;</code>, 如下例子, 生成斐波那契数列:<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// seed将会作为i的初始化值, 返回值y将作为参数再次会传递给该函数</span></span><br><span class=\"line\">Stream.iterate(<span class=\"number\">0</span>, (i) -&gt; &#123;<span class=\"keyword\">int</span> y = i + x; x = i; <span class=\"keyword\">return</span> y;&#125;).limit(<span class=\"number\">30</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>\n<li>使用建造者模式. 其实建造者模式类似于新建一个集合, 然后往里put元素.<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.Builder&lt;String&gt; builder = Stream.builder();</span><br><span class=\"line\">String res = builder.build().map(...).collect(Collector.joining(<span class=\"string\">&quot; &quot;</span>));</span><br></pre></td></tr></table></figure></li>\n<li><code>Arrays.stream()</code></li>\n</ol>\n<h1 id=\"Intermediate-Operations\"><a href=\"#Intermediate-Operations\" class=\"headerlink\" title=\"Intermediate Operations\"></a>Intermediate Operations</h1><ol>\n<li>.map(…)</li>\n<li>.peek(…), 使用peek()帮助调试</li>\n<li>.skip(…)</li>\n<li>.limit(…)</li>\n<li>.sorted(Comparator.reverseOrder())</li>\n<li>.filter(Predicate)</li>\n<li>.distinct()</li>\n<li>parallel(), 这个重点说一下, 这个是将流中计算机制换为并行计算, 所以最终输出元素的顺序是随机的. 要是再此基础上要得到有序的输出, 需要上如<code>forEachOrdered(...)</code>等的Terminal Operations</li>\n</ol>\n<h1 id=\"Terminal-Operations\"><a href=\"#Terminal-Operations\" class=\"headerlink\" title=\"Terminal Operations\"></a>Terminal Operations</h1><ol>\n<li>.collect(Collector.toList())</li>\n<li>.toArray()</li>\n<li>.forEach()</li>\n<li>.reduce(…), 最终输出的是一个元素. <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Reduce函数功能展示</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Random;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.Stream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntegerSupplier</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 生成一个100以内的随机数流(建造者模式)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> Stream&lt;Integer&gt; <span class=\"title\">supply</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tRandom rand = <span class=\"keyword\">new</span> Random(<span class=\"number\">15</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> BOUND = <span class=\"number\">100</span>;</span><br><span class=\"line\">\t\tStream.Builder&lt;Integer&gt; builder = Stream.builder();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">30</span>; i++) &#123;</span><br><span class=\"line\">\t\t\tbuilder.add(rand.nextInt(BOUND));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> builder.build();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Reduce</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// reduce(BinaryOperator), BinaryOperator这个函数式接口对应的函数只有两个参数</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 其中fr0既作为初始化的第一个值, 又作为每次的返回值传入, 在输出中可以看到</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 最终reduce返回的值, Integer被Optional包裹</span></span><br><span class=\"line\">\t\tIntegerSupplier.supply().reduce((fr0, fr1) -&gt; &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(fr0 + <span class=\"string\">&quot;--compare to--&quot;</span> + fr1);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> fr0 &lt; fr1 ? fr0 : fr1;</span><br><span class=\"line\">\t\t&#125;).ifPresent(System.out::println);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">/* 41--compare to--72</span></span><br><span class=\"line\"><span class=\"comment\"> * 72--compare to--38</span></span><br><span class=\"line\"><span class=\"comment\"> * 72--compare to--67</span></span><br><span class=\"line\"><span class=\"comment\"> * 72--compare to--85</span></span><br><span class=\"line\"><span class=\"comment\"> * 85--compare to--60</span></span><br><span class=\"line\"><span class=\"comment\"> * 85--compare to--59</span></span><br><span class=\"line\"><span class=\"comment\"> * Optional[85]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Optional类\"><a href=\"#Optional类\" class=\"headerlink\" title=\"Optional类\"></a>Optional类</h3><p>为了防止流执行的过程中, 出现”空流”而中断抛出异常, 所以引入了Optional类, 为空时将会返回<code>Optional.empty</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 空流, 等价于: Stream&lt;String&gt; s = Stream.empty();</span></span><br><span class=\"line\">Stream.&lt;String&gt;empty().findFirst()</span><br><span class=\"line\"><span class=\"comment\">// output: Optional.empty</span></span><br></pre></td></tr></table></figure>\n<p>原理是将返回值塞到了Optional对象中, Optional类提供了很多诸如<code>isPresent()</code>, <code>orElse</code>, <code>orElseGet</code>等方法, 在Python3.7以后引入类型系统后也有了Optional类型, 如果一个变量被标识为Optional, 那么这个对象可能为none.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Java8引入新的概念Streams. 如何将此融入到现有的生态百万行代码的类库中. 一个巨大挑战来自使用接口的库, 如果将一个新的方法添加到接口, 那就破坏了每一个实现接口的类,因为这些类要实现你新添加的方法.<br>设计者给出的解决方案是, 在接口中添加被default修饰的方法.<br>通过这种方案, 将流式平滑地嵌入到现有的类中.<br>流的操作有三种: creating streams, intermediate operations, terminal operations.</p>\n<blockquote><p><strong>Declarative programming</strong> is a style where we state what we want done, rather than<br>specifying how, and it’s what you see in functional programming. Notice it’s much<br>more difficult to understand the <strong>imperative programming</strong>.</p>\n<footer><strong>Bruce Eckel</strong><cite>OnJava8</cite></footer></blockquote>\n<p>对比一下声明式编程和命令式编程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Declarative programming</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Random(<span class=\"number\">47</span>).ints(<span class=\"number\">5</span>, <span class=\"number\">20</span>).distinct().limit(<span class=\"number\">7</span>).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Imperative programming</span></span><br><span class=\"line\">Random rand = <span class=\"keyword\">new</span> Random(<span class=\"number\">47</span>);</span><br><span class=\"line\">SortedSet&lt;Integer&gt; rints = <span class=\"keyword\">new</span> TreeSet&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(rints.size() &lt; <span class=\"number\">7</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = rand.nextInt(<span class=\"number\">20</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt; <span class=\"number\">5</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    rints.add(r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(rints);</span><br></pre></td></tr></table></figure>\n<p>显然命令式编程更难理解, 而且在Streams过程中, 没有明显地看到任何变量的定义.<br>语义清晰是Java Stream API的优点之一.</p>\n<h1 id=\"Creating-Streams\"><a href=\"#Creating-Streams\" class=\"headerlink\" title=\"Creating Streams\"></a>Creating Streams</h1><ol>\n<li>通过Streams.of(…)将一组元素转换为Stream</li>\n<li>每隔集合可以通过调用其<code>.stream()</code>方法来产生一个流.</li>\n<li><code>Stream.generate(...)</code>, generate接收一个参数<code>Supplier&lt;T&gt;</code>, 通过调用实现了<code>Supplier&lt;T&gt;</code>接口的类的get方法(也可以传Lambda表达式, 原理也是有个类实现了Supplier接口, 具体在函数式编程里有详细介绍). 不过generate必须有一个限制, 不能无限制的运行. 否则会造成<code>java.lang.OutOfMemoryError: Java heap space</code>错误. 比如, 中间加入了limit函数<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.generate(() -&gt; <span class=\"string\">&quot;h&quot;</span>).limit(<span class=\"number\">30</span>).collect(Collectors.joining());</span><br></pre></td></tr></table></figure></li>\n<li><code>Stream.iterate(...)</code>, iterate接收的参数第一个是seed, 第二个其实是<code>Function&lt;T&gt;</code>, 如下例子, 生成斐波那契数列:<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// seed将会作为i的初始化值, 返回值y将作为参数再次会传递给该函数</span></span><br><span class=\"line\">Stream.iterate(<span class=\"number\">0</span>, (i) -&gt; &#123;<span class=\"keyword\">int</span> y = i + x; x = i; <span class=\"keyword\">return</span> y;&#125;).limit(<span class=\"number\">30</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>\n<li>使用建造者模式. 其实建造者模式类似于新建一个集合, 然后往里put元素.<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.Builder&lt;String&gt; builder = Stream.builder();</span><br><span class=\"line\">String res = builder.build().map(...).collect(Collector.joining(<span class=\"string\">&quot; &quot;</span>));</span><br></pre></td></tr></table></figure></li>\n<li><code>Arrays.stream()</code></li>\n</ol>\n<h1 id=\"Intermediate-Operations\"><a href=\"#Intermediate-Operations\" class=\"headerlink\" title=\"Intermediate Operations\"></a>Intermediate Operations</h1><ol>\n<li>.map(…)</li>\n<li>.peek(…), 使用peek()帮助调试</li>\n<li>.skip(…)</li>\n<li>.limit(…)</li>\n<li>.sorted(Comparator.reverseOrder())</li>\n<li>.filter(Predicate)</li>\n<li>.distinct()</li>\n<li>parallel(), 这个重点说一下, 这个是将流中计算机制换为并行计算, 所以最终输出元素的顺序是随机的. 要是再此基础上要得到有序的输出, 需要上如<code>forEachOrdered(...)</code>等的Terminal Operations</li>\n</ol>\n<h1 id=\"Terminal-Operations\"><a href=\"#Terminal-Operations\" class=\"headerlink\" title=\"Terminal Operations\"></a>Terminal Operations</h1><ol>\n<li>.collect(Collector.toList())</li>\n<li>.toArray()</li>\n<li>.forEach()</li>\n<li>.reduce(…), 最终输出的是一个元素. <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Reduce函数功能展示</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Random;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.Stream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntegerSupplier</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 生成一个100以内的随机数流(建造者模式)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> Stream&lt;Integer&gt; <span class=\"title\">supply</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tRandom rand = <span class=\"keyword\">new</span> Random(<span class=\"number\">15</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> BOUND = <span class=\"number\">100</span>;</span><br><span class=\"line\">\t\tStream.Builder&lt;Integer&gt; builder = Stream.builder();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">30</span>; i++) &#123;</span><br><span class=\"line\">\t\t\tbuilder.add(rand.nextInt(BOUND));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> builder.build();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Reduce</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// reduce(BinaryOperator), BinaryOperator这个函数式接口对应的函数只有两个参数</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 其中fr0既作为初始化的第一个值, 又作为每次的返回值传入, 在输出中可以看到</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 最终reduce返回的值, Integer被Optional包裹</span></span><br><span class=\"line\">\t\tIntegerSupplier.supply().reduce((fr0, fr1) -&gt; &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(fr0 + <span class=\"string\">&quot;--compare to--&quot;</span> + fr1);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> fr0 &lt; fr1 ? fr0 : fr1;</span><br><span class=\"line\">\t\t&#125;).ifPresent(System.out::println);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">/* 41--compare to--72</span></span><br><span class=\"line\"><span class=\"comment\"> * 72--compare to--38</span></span><br><span class=\"line\"><span class=\"comment\"> * 72--compare to--67</span></span><br><span class=\"line\"><span class=\"comment\"> * 72--compare to--85</span></span><br><span class=\"line\"><span class=\"comment\"> * 85--compare to--60</span></span><br><span class=\"line\"><span class=\"comment\"> * 85--compare to--59</span></span><br><span class=\"line\"><span class=\"comment\"> * Optional[85]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Optional类\"><a href=\"#Optional类\" class=\"headerlink\" title=\"Optional类\"></a>Optional类</h3><p>为了防止流执行的过程中, 出现”空流”而中断抛出异常, 所以引入了Optional类, 为空时将会返回<code>Optional.empty</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 空流, 等价于: Stream&lt;String&gt; s = Stream.empty();</span></span><br><span class=\"line\">Stream.&lt;String&gt;empty().findFirst()</span><br><span class=\"line\"><span class=\"comment\">// output: Optional.empty</span></span><br></pre></td></tr></table></figure>\n<p>原理是将返回值塞到了Optional对象中, Optional类提供了很多诸如<code>isPresent()</code>, <code>orElse</code>, <code>orElseGet</code>等方法, 在Python3.7以后引入类型系统后也有了Optional类型, 如果一个变量被标识为Optional, 那么这个对象可能为none.</p>\n"},{"title":"Maven Wrapper最佳实践","date":"2021-11-07T08:22:04.000Z","_content":"\n将一个maven项目所有信息都保留在项目根目录下, 包括maven本身\n\n\n## Maven Wrapper安装\n在项目根目录下\n```\nmvn -N io.takari:maven:0.7.7:wrapper\nmvn -N io.takari:maven:wrapper -Dmaven=3.6.3\n```\nThis creates two files (mvnw, mvnw.cmd) and a hidden directory (.mvn). mvnw can be used in Unix-like environments and mvnw.cmd can be used in Windows.\n这将会创建两个文件和一个目录. `mvnw`用来Unix-like环境, `mvnw.cmd`用在Windows环境.\n\nInstead of the usual mvn command, they would use mvnw. for example:\n```shell\n./mvnw clean install\n```\n\n## Maven Wrapper原理\nThe `.mvn/wrapper` directory has a jar file `maven-wrapper.jar` that downloads the required version of Maven if it’s not already present. It installs it in the `./m2/wrapper/dists` directory under the user’s home directory.\n\nWhere does it download Maven from? This information is present in the mvn/wrapper/maven-wrapper.properties file:\n```properties\ndistributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.5.2/apache-maven-3.5.2-bin.zip\nwrapperUrl=https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar\n```\n\n## Maven Wrapper贯彻的思想\nYears ago, I was on a team developing a desktop-based Java application. We wanted to share our artifact with a couple of business users in the field to get some feedback. It was unlikely they had Java installed. Asking them to download, install, and configure version 1.2 of Java (yes, this was that long ago!) to run our application would have been a hassle for them.\n\nLooking around trying to find how others had solved this problem, I came across this idea of **“bundling the JRE”**. The idea was to include within the artifact itself the Java Runtime Environment that our application depended on. Then users don’t need to have a particular version or even any version of Java pre-installed - a neat solution to a specific problem.\n\nOver the years I came across this idea in many places. Today when we containerize our application for cloud deployment, it’s the same general idea: encapsulate the dependent and its dependency into a single unit to hide some complexity.\nThe Maven Wrapper makes it easy to build our code on any machine, including CI/CD servers. We don’t have to worry about installing the right version of Maven on the CI servers anymore!\n\n\n## 结合IDEA的最佳实践\n收到这个\"捆绑思想\"的影响. 我希望我可以在开发时, 将项目中的依赖从本地仓库中分离. 一个项目一个依赖库, 就比如node_modules.\n1. 安装好maven wrapper\n2. 复制一个`settings.xml`到`$PROJECT_DIR$/.mvn/`下\n3. `$PROJECT_DIR$/.mvn/`新建文件夹`repository`\n4. IDEA中配置`Setting > Build, Execution, Deployment > Build Tools > Maven`\n - 修改`Maven Home Path`为`Use Maven wrapper`, 如果发现没有这个选项说明IDEA没有更新(至少要2021.2.3+的版本)\n - 修改`User settings file`为`$PROJECT_DIR$/.mvn/settings.xml`\n - 修改`Local repository`为`$PROJECT_DIR$/.mvn/repository`\n","source":"_posts/maven-wrapper.md","raw":"---\ntitle: Maven Wrapper最佳实践\ndate: 2021-11-07 16:22:04\ncategories:\n- Package Manager\ntags:\n- maven\n---\n\n将一个maven项目所有信息都保留在项目根目录下, 包括maven本身\n\n\n## Maven Wrapper安装\n在项目根目录下\n```\nmvn -N io.takari:maven:0.7.7:wrapper\nmvn -N io.takari:maven:wrapper -Dmaven=3.6.3\n```\nThis creates two files (mvnw, mvnw.cmd) and a hidden directory (.mvn). mvnw can be used in Unix-like environments and mvnw.cmd can be used in Windows.\n这将会创建两个文件和一个目录. `mvnw`用来Unix-like环境, `mvnw.cmd`用在Windows环境.\n\nInstead of the usual mvn command, they would use mvnw. for example:\n```shell\n./mvnw clean install\n```\n\n## Maven Wrapper原理\nThe `.mvn/wrapper` directory has a jar file `maven-wrapper.jar` that downloads the required version of Maven if it’s not already present. It installs it in the `./m2/wrapper/dists` directory under the user’s home directory.\n\nWhere does it download Maven from? This information is present in the mvn/wrapper/maven-wrapper.properties file:\n```properties\ndistributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.5.2/apache-maven-3.5.2-bin.zip\nwrapperUrl=https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar\n```\n\n## Maven Wrapper贯彻的思想\nYears ago, I was on a team developing a desktop-based Java application. We wanted to share our artifact with a couple of business users in the field to get some feedback. It was unlikely they had Java installed. Asking them to download, install, and configure version 1.2 of Java (yes, this was that long ago!) to run our application would have been a hassle for them.\n\nLooking around trying to find how others had solved this problem, I came across this idea of **“bundling the JRE”**. The idea was to include within the artifact itself the Java Runtime Environment that our application depended on. Then users don’t need to have a particular version or even any version of Java pre-installed - a neat solution to a specific problem.\n\nOver the years I came across this idea in many places. Today when we containerize our application for cloud deployment, it’s the same general idea: encapsulate the dependent and its dependency into a single unit to hide some complexity.\nThe Maven Wrapper makes it easy to build our code on any machine, including CI/CD servers. We don’t have to worry about installing the right version of Maven on the CI servers anymore!\n\n\n## 结合IDEA的最佳实践\n收到这个\"捆绑思想\"的影响. 我希望我可以在开发时, 将项目中的依赖从本地仓库中分离. 一个项目一个依赖库, 就比如node_modules.\n1. 安装好maven wrapper\n2. 复制一个`settings.xml`到`$PROJECT_DIR$/.mvn/`下\n3. `$PROJECT_DIR$/.mvn/`新建文件夹`repository`\n4. IDEA中配置`Setting > Build, Execution, Deployment > Build Tools > Maven`\n - 修改`Maven Home Path`为`Use Maven wrapper`, 如果发现没有这个选项说明IDEA没有更新(至少要2021.2.3+的版本)\n - 修改`User settings file`为`$PROJECT_DIR$/.mvn/settings.xml`\n - 修改`Local repository`为`$PROJECT_DIR$/.mvn/repository`\n","slug":"maven-wrapper","published":1,"updated":"2021-12-30T02:51:36.861Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxsdzpyv000vxotgg27783me","content":"<p>将一个maven项目所有信息都保留在项目根目录下, 包括maven本身</p>\n<h2 id=\"Maven-Wrapper安装\"><a href=\"#Maven-Wrapper安装\" class=\"headerlink\" title=\"Maven Wrapper安装\"></a>Maven Wrapper安装</h2><p>在项目根目录下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn -N io.takari:maven:0.7.7:wrapper</span><br><span class=\"line\">mvn -N io.takari:maven:wrapper -Dmaven=3.6.3</span><br></pre></td></tr></table></figure>\n<p>This creates two files (mvnw, mvnw.cmd) and a hidden directory (.mvn). mvnw can be used in Unix-like environments and mvnw.cmd can be used in Windows.<br>这将会创建两个文件和一个目录. <code>mvnw</code>用来Unix-like环境, <code>mvnw.cmd</code>用在Windows环境.</p>\n<p>Instead of the usual mvn command, they would use mvnw. for example:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./mvnw clean install</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Maven-Wrapper原理\"><a href=\"#Maven-Wrapper原理\" class=\"headerlink\" title=\"Maven Wrapper原理\"></a>Maven Wrapper原理</h2><p>The <code>.mvn/wrapper</code> directory has a jar file <code>maven-wrapper.jar</code> that downloads the required version of Maven if it’s not already present. It installs it in the <code>./m2/wrapper/dists</code> directory under the user’s home directory.</p>\n<p>Where does it download Maven from? This information is present in the mvn/wrapper/maven-wrapper.properties file:</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">distributionUrl</span>=<span class=\"string\">https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.5.2/apache-maven-3.5.2-bin.zip</span></span><br><span class=\"line\"><span class=\"attr\">wrapperUrl</span>=<span class=\"string\">https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Maven-Wrapper贯彻的思想\"><a href=\"#Maven-Wrapper贯彻的思想\" class=\"headerlink\" title=\"Maven Wrapper贯彻的思想\"></a>Maven Wrapper贯彻的思想</h2><p>Years ago, I was on a team developing a desktop-based Java application. We wanted to share our artifact with a couple of business users in the field to get some feedback. It was unlikely they had Java installed. Asking them to download, install, and configure version 1.2 of Java (yes, this was that long ago!) to run our application would have been a hassle for them.</p>\n<p>Looking around trying to find how others had solved this problem, I came across this idea of <strong>“bundling the JRE”</strong>. The idea was to include within the artifact itself the Java Runtime Environment that our application depended on. Then users don’t need to have a particular version or even any version of Java pre-installed - a neat solution to a specific problem.</p>\n<p>Over the years I came across this idea in many places. Today when we containerize our application for cloud deployment, it’s the same general idea: encapsulate the dependent and its dependency into a single unit to hide some complexity.<br>The Maven Wrapper makes it easy to build our code on any machine, including CI/CD servers. We don’t have to worry about installing the right version of Maven on the CI servers anymore!</p>\n<h2 id=\"结合IDEA的最佳实践\"><a href=\"#结合IDEA的最佳实践\" class=\"headerlink\" title=\"结合IDEA的最佳实践\"></a>结合IDEA的最佳实践</h2><p>收到这个”捆绑思想”的影响. 我希望我可以在开发时, 将项目中的依赖从本地仓库中分离. 一个项目一个依赖库, 就比如node_modules.</p>\n<ol>\n<li>安装好maven wrapper</li>\n<li>复制一个<code>settings.xml</code>到<code>$PROJECT_DIR$/.mvn/</code>下</li>\n<li><code>$PROJECT_DIR$/.mvn/</code>新建文件夹<code>repository</code></li>\n<li>IDEA中配置<code>Setting &gt; Build, Execution, Deployment &gt; Build Tools &gt; Maven</code></li>\n</ol>\n<ul>\n<li>修改<code>Maven Home Path</code>为<code>Use Maven wrapper</code>, 如果发现没有这个选项说明IDEA没有更新(至少要2021.2.3+的版本)</li>\n<li>修改<code>User settings file</code>为<code>$PROJECT_DIR$/.mvn/settings.xml</code></li>\n<li>修改<code>Local repository</code>为<code>$PROJECT_DIR$/.mvn/repository</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>将一个maven项目所有信息都保留在项目根目录下, 包括maven本身</p>\n<h2 id=\"Maven-Wrapper安装\"><a href=\"#Maven-Wrapper安装\" class=\"headerlink\" title=\"Maven Wrapper安装\"></a>Maven Wrapper安装</h2><p>在项目根目录下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn -N io.takari:maven:0.7.7:wrapper</span><br><span class=\"line\">mvn -N io.takari:maven:wrapper -Dmaven=3.6.3</span><br></pre></td></tr></table></figure>\n<p>This creates two files (mvnw, mvnw.cmd) and a hidden directory (.mvn). mvnw can be used in Unix-like environments and mvnw.cmd can be used in Windows.<br>这将会创建两个文件和一个目录. <code>mvnw</code>用来Unix-like环境, <code>mvnw.cmd</code>用在Windows环境.</p>\n<p>Instead of the usual mvn command, they would use mvnw. for example:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./mvnw clean install</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Maven-Wrapper原理\"><a href=\"#Maven-Wrapper原理\" class=\"headerlink\" title=\"Maven Wrapper原理\"></a>Maven Wrapper原理</h2><p>The <code>.mvn/wrapper</code> directory has a jar file <code>maven-wrapper.jar</code> that downloads the required version of Maven if it’s not already present. It installs it in the <code>./m2/wrapper/dists</code> directory under the user’s home directory.</p>\n<p>Where does it download Maven from? This information is present in the mvn/wrapper/maven-wrapper.properties file:</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">distributionUrl</span>=<span class=\"string\">https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.5.2/apache-maven-3.5.2-bin.zip</span></span><br><span class=\"line\"><span class=\"attr\">wrapperUrl</span>=<span class=\"string\">https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Maven-Wrapper贯彻的思想\"><a href=\"#Maven-Wrapper贯彻的思想\" class=\"headerlink\" title=\"Maven Wrapper贯彻的思想\"></a>Maven Wrapper贯彻的思想</h2><p>Years ago, I was on a team developing a desktop-based Java application. We wanted to share our artifact with a couple of business users in the field to get some feedback. It was unlikely they had Java installed. Asking them to download, install, and configure version 1.2 of Java (yes, this was that long ago!) to run our application would have been a hassle for them.</p>\n<p>Looking around trying to find how others had solved this problem, I came across this idea of <strong>“bundling the JRE”</strong>. The idea was to include within the artifact itself the Java Runtime Environment that our application depended on. Then users don’t need to have a particular version or even any version of Java pre-installed - a neat solution to a specific problem.</p>\n<p>Over the years I came across this idea in many places. Today when we containerize our application for cloud deployment, it’s the same general idea: encapsulate the dependent and its dependency into a single unit to hide some complexity.<br>The Maven Wrapper makes it easy to build our code on any machine, including CI/CD servers. We don’t have to worry about installing the right version of Maven on the CI servers anymore!</p>\n<h2 id=\"结合IDEA的最佳实践\"><a href=\"#结合IDEA的最佳实践\" class=\"headerlink\" title=\"结合IDEA的最佳实践\"></a>结合IDEA的最佳实践</h2><p>收到这个”捆绑思想”的影响. 我希望我可以在开发时, 将项目中的依赖从本地仓库中分离. 一个项目一个依赖库, 就比如node_modules.</p>\n<ol>\n<li>安装好maven wrapper</li>\n<li>复制一个<code>settings.xml</code>到<code>$PROJECT_DIR$/.mvn/</code>下</li>\n<li><code>$PROJECT_DIR$/.mvn/</code>新建文件夹<code>repository</code></li>\n<li>IDEA中配置<code>Setting &gt; Build, Execution, Deployment &gt; Build Tools &gt; Maven</code></li>\n</ol>\n<ul>\n<li>修改<code>Maven Home Path</code>为<code>Use Maven wrapper</code>, 如果发现没有这个选项说明IDEA没有更新(至少要2021.2.3+的版本)</li>\n<li>修改<code>User settings file</code>为<code>$PROJECT_DIR$/.mvn/settings.xml</code></li>\n<li>修改<code>Local repository</code>为<code>$PROJECT_DIR$/.mvn/repository</code></li>\n</ul>\n"},{"title":"professional-dictionary","date":"2021-10-05T01:32:58.000Z","_content":"> inference 推断 n.\n\nLambda expressions include a form of type inference in Java.\nLambda表达式包含一种类型推导.\n\n> assign 指派 v.\n\n`Shape s = new Circle();`  This creates a Circle object, and the resulting reference is immediately assigned to a Shape.\n这里翻译为\"指派\", `s`被指派(指定)了一个类型Shape.\n\n> oriented 导向的，定向的adj.\n\n> object-oriented [计]面向对象的adj.\n\n> Connector 端口，连接头n.\n\n> Configure 配置v.\n\n> Specified 指定的adj.\n\n> Deploy 部署v.\n\n> Undeploy 卸载v.\n\n> Expire 终止v.\n\n> Session 学期，一段时间n.\n\n> Dynamic 动态的adj.\n\n> Module 组件，单元，模块n.\n\n> Directory 路径n.\n\n> Descriptor 描述符n.\n\n> Install 安装v.\n\n> Synchronize 使同步v.\n\n> Meta 元，meta语言n.\n\n> Charset 字符集n.\n\n> Charater 字符n.\n\n> Flush 冲洗v.\n\n> Mapping 映射n.\n\n> Protocol 协议n.\n\n> Generic 普通的；一般的adj.\n\n> Initialize 初始化v.\n\n> Sequence 一系列, 列表n.\n\n> In addition to 除....之外\n\n> Thread 线n.\n\n> Timeout 超时，过期n.\n\n> Summary 摘要n.\n\n> Contain 容纳，限制v.\n\n> Subclass 子类n.\n\n> Declare 声明v.\n\n> Dispatch 派遣，发送v.\n\n> Additional 附加的，额外的adj.\n\n> Stream 流n.   \n\n> Input stream输入流\n\n> Encode 编码v.\n\n> URL 统一资源定位符\n\n> URI 统一资源标识符\n\n> Invalidate 使销毁，使作废v.\n\n> Layer 层n.\n\n> Prefix 前缀n.\n\n> Tag标签 n.\n\n> Wrapper 包装用品n.\n\n> Filter 过滤器n.\n\n> Chain 链条n.\n\n> Notation 记号；表示法；记法n.\n\n> Serialize　使连载v.\n\n> Plugins 插件n.\n\n> Validate 使生效v.\n\n> Panel 面板；仪表盘n.\n\n> Literal 字面上的；文字的adj.  \n\n> Constant 不变的adj. 常量，恒量；n.\n\n> Mutable 可变的adj.\n\n> Specified 指定的；规定的adj.\n\n> Collapsible 可折叠的，可收缩的adj.\n\n> Icon 图标[计]；象征；偶像adj.\n\n> Combo 组合物n.\n\n> Handler 处理器n.\n\n> Grid 格子，网格n.\n\n> Validate 使生效；证实v.\n\n> Required 必须的adj.\n\n> Parse 解析v.   从语法上分析n.\n\n> Separator 分隔符n.\n\n> Interrupt 中断n.\n\n> Runnable 可捕捉的，可猎取的 adj.\n\n> Daemon 守护神，[计]守护线程n.\n\n> Priority 优先级，优先权，优先顺序n.\n\n> Notify 通知，报告v.\n\n> Invoke引起v.\n\n> Split 分裂，分离v.\n\n> Deprecated 过时的adj.\n\n> Suppress禁止，压制v.\n\n> Retention 保持力，保存期限n.\n\n> Annotation 注解，注释n.\n\n> Nickname 昵称，绰号n.\n\n> Invocation [计]调用；（法律的）实施；祈祷n.\n\n> Template 样板，模板n.\n\n> Intersect 交叉，相交v.\n\n> Minus 减号，减去n.\n\n> Increment 增加v.\n\n> Validate 使..生效，确认；v.\n\n> Encapsulation 包装，封装n.\n\n> Polymorphism 多态性n.\n\n> Catalog 目录n.\n\n> Detached 游离的，分离的；adj.\n\n> Persistent 持久的；adj.\n\n> Transient 瞬时的；adj.\n\n> Dependency 从属n.\n\n> Injection 注射n.\n\n> Component 成分，组件n.\n\n> Schema [计]模式，范式n.\n\n> Scheme 计划n.\n\n> Suffix 后缀，下标n.\n\n> Mechanism 机制，原理n.\n\n> Facet 面，方面n.\n\n> Validation 确认，批准，生效n.\n\n> Duplicate 复制v.\n\n> Invalid 无效的adj.\n\n> Submission 投降，提交n.\n\n> Alias 别名n.\n\n> Argument 参数n.\n\n> Requirements 需求，要求n.\n\n> Neglect 疏忽，忽视vt.\n\n> Term 术语n.\n\n> Allocate 分配vt.\n\n> Validate 验证，确认（表现为一般的检查）vt.\n\n> Compile 编译vt.\n\n> Verify 核实，查证（表现为要付出一段程序化的核实过程）vt.\n\n> Repository 仓库，资源库，版本库n.\n\n> Plugins 插件，外挂n.\n\n> Procedure [计算机]过程 n.\n\n> Retain 保持vt.\n\n> Clause 从句 n.\n\n> Via 通过 n.f\n\n> Along with 连同，以及，和……一起\n\n> Excluding 除……之外，不包括 prep.\n\n> Standalone 单独的，独立的adj.\n\n> Cluster 集群，簇n.\n\n> Aggregation 集成，聚集n.\n\n> Excerpt 摘录，摘要n.\n\n> Integration 整合，集成n.\n\n> Expectation 期待，盼望n.\n\n> Composite 合成的adj. 使合成vt.\n\n> Interaction 相互作用，相互影响n.\n\n> Doubt 怀疑，不信n.vt.\n\n> Field 字段，域n.\n\n> Intermediate 起媒介作用vi. 中间的adj. 媒介n.\n\n> Authorization 授权，认可n.\n\n> Demarcation 界限，划分n.\n\n> Conscious 意识到的adj.\n\n> Retrieve 检索vt.\n\n> Traverse 穿过，横越；[计]遍历vt.\n\n> Breadth 宽度，广度n.\n\n> Breadth First广度优先n.\n\n> Evaluate 评价，评估vt.\n\n> Perform 执行，机器运转，表演vt.\n\n> Depth 深度n.\n\n> Instantiate 实例化vt.\n\n> Custom 习惯，惯例，风俗n.\n\n> In this case 在这种情况下，在这个案例中\n\n> Descent 下降n.\n\n> Descendant 子孙，下降\n\n> Mutable 可变的，不定的adj.\n\n> Immutable 不可变的adj.\n\n> Expand 扩张，使膨胀vt.\n\n> In term of 根据\n\n> Explanation 说明，解释n.\n\n> Regardless of 不管，不顾\n\n> Latter 后者n.\n\n> Prune 剪枝n.\n\n> Fluent 流动的adj.\n\n> Manual 手工的，手动的adj.\n\n> Notification 通知，通告n.\n\n> Entity 实体n.\n\n> Whereas 然而，反之n.\n\n> In case 万一\n\n> Persist 坚持，固执vi.\n\n> Snapshot 快照n.\n\n> Assert 断言n.\n\n> Quote 引号n.\n\n> Coroutine 协同程序n.\n\n> \n","source":"_posts/professional-dictionary.md","raw":"---\ntitle: professional-dictionary\ndate: 2021-10-05 09:32:58\ncategories:\n- 专业词汇\n---\n> inference 推断 n.\n\nLambda expressions include a form of type inference in Java.\nLambda表达式包含一种类型推导.\n\n> assign 指派 v.\n\n`Shape s = new Circle();`  This creates a Circle object, and the resulting reference is immediately assigned to a Shape.\n这里翻译为\"指派\", `s`被指派(指定)了一个类型Shape.\n\n> oriented 导向的，定向的adj.\n\n> object-oriented [计]面向对象的adj.\n\n> Connector 端口，连接头n.\n\n> Configure 配置v.\n\n> Specified 指定的adj.\n\n> Deploy 部署v.\n\n> Undeploy 卸载v.\n\n> Expire 终止v.\n\n> Session 学期，一段时间n.\n\n> Dynamic 动态的adj.\n\n> Module 组件，单元，模块n.\n\n> Directory 路径n.\n\n> Descriptor 描述符n.\n\n> Install 安装v.\n\n> Synchronize 使同步v.\n\n> Meta 元，meta语言n.\n\n> Charset 字符集n.\n\n> Charater 字符n.\n\n> Flush 冲洗v.\n\n> Mapping 映射n.\n\n> Protocol 协议n.\n\n> Generic 普通的；一般的adj.\n\n> Initialize 初始化v.\n\n> Sequence 一系列, 列表n.\n\n> In addition to 除....之外\n\n> Thread 线n.\n\n> Timeout 超时，过期n.\n\n> Summary 摘要n.\n\n> Contain 容纳，限制v.\n\n> Subclass 子类n.\n\n> Declare 声明v.\n\n> Dispatch 派遣，发送v.\n\n> Additional 附加的，额外的adj.\n\n> Stream 流n.   \n\n> Input stream输入流\n\n> Encode 编码v.\n\n> URL 统一资源定位符\n\n> URI 统一资源标识符\n\n> Invalidate 使销毁，使作废v.\n\n> Layer 层n.\n\n> Prefix 前缀n.\n\n> Tag标签 n.\n\n> Wrapper 包装用品n.\n\n> Filter 过滤器n.\n\n> Chain 链条n.\n\n> Notation 记号；表示法；记法n.\n\n> Serialize　使连载v.\n\n> Plugins 插件n.\n\n> Validate 使生效v.\n\n> Panel 面板；仪表盘n.\n\n> Literal 字面上的；文字的adj.  \n\n> Constant 不变的adj. 常量，恒量；n.\n\n> Mutable 可变的adj.\n\n> Specified 指定的；规定的adj.\n\n> Collapsible 可折叠的，可收缩的adj.\n\n> Icon 图标[计]；象征；偶像adj.\n\n> Combo 组合物n.\n\n> Handler 处理器n.\n\n> Grid 格子，网格n.\n\n> Validate 使生效；证实v.\n\n> Required 必须的adj.\n\n> Parse 解析v.   从语法上分析n.\n\n> Separator 分隔符n.\n\n> Interrupt 中断n.\n\n> Runnable 可捕捉的，可猎取的 adj.\n\n> Daemon 守护神，[计]守护线程n.\n\n> Priority 优先级，优先权，优先顺序n.\n\n> Notify 通知，报告v.\n\n> Invoke引起v.\n\n> Split 分裂，分离v.\n\n> Deprecated 过时的adj.\n\n> Suppress禁止，压制v.\n\n> Retention 保持力，保存期限n.\n\n> Annotation 注解，注释n.\n\n> Nickname 昵称，绰号n.\n\n> Invocation [计]调用；（法律的）实施；祈祷n.\n\n> Template 样板，模板n.\n\n> Intersect 交叉，相交v.\n\n> Minus 减号，减去n.\n\n> Increment 增加v.\n\n> Validate 使..生效，确认；v.\n\n> Encapsulation 包装，封装n.\n\n> Polymorphism 多态性n.\n\n> Catalog 目录n.\n\n> Detached 游离的，分离的；adj.\n\n> Persistent 持久的；adj.\n\n> Transient 瞬时的；adj.\n\n> Dependency 从属n.\n\n> Injection 注射n.\n\n> Component 成分，组件n.\n\n> Schema [计]模式，范式n.\n\n> Scheme 计划n.\n\n> Suffix 后缀，下标n.\n\n> Mechanism 机制，原理n.\n\n> Facet 面，方面n.\n\n> Validation 确认，批准，生效n.\n\n> Duplicate 复制v.\n\n> Invalid 无效的adj.\n\n> Submission 投降，提交n.\n\n> Alias 别名n.\n\n> Argument 参数n.\n\n> Requirements 需求，要求n.\n\n> Neglect 疏忽，忽视vt.\n\n> Term 术语n.\n\n> Allocate 分配vt.\n\n> Validate 验证，确认（表现为一般的检查）vt.\n\n> Compile 编译vt.\n\n> Verify 核实，查证（表现为要付出一段程序化的核实过程）vt.\n\n> Repository 仓库，资源库，版本库n.\n\n> Plugins 插件，外挂n.\n\n> Procedure [计算机]过程 n.\n\n> Retain 保持vt.\n\n> Clause 从句 n.\n\n> Via 通过 n.f\n\n> Along with 连同，以及，和……一起\n\n> Excluding 除……之外，不包括 prep.\n\n> Standalone 单独的，独立的adj.\n\n> Cluster 集群，簇n.\n\n> Aggregation 集成，聚集n.\n\n> Excerpt 摘录，摘要n.\n\n> Integration 整合，集成n.\n\n> Expectation 期待，盼望n.\n\n> Composite 合成的adj. 使合成vt.\n\n> Interaction 相互作用，相互影响n.\n\n> Doubt 怀疑，不信n.vt.\n\n> Field 字段，域n.\n\n> Intermediate 起媒介作用vi. 中间的adj. 媒介n.\n\n> Authorization 授权，认可n.\n\n> Demarcation 界限，划分n.\n\n> Conscious 意识到的adj.\n\n> Retrieve 检索vt.\n\n> Traverse 穿过，横越；[计]遍历vt.\n\n> Breadth 宽度，广度n.\n\n> Breadth First广度优先n.\n\n> Evaluate 评价，评估vt.\n\n> Perform 执行，机器运转，表演vt.\n\n> Depth 深度n.\n\n> Instantiate 实例化vt.\n\n> Custom 习惯，惯例，风俗n.\n\n> In this case 在这种情况下，在这个案例中\n\n> Descent 下降n.\n\n> Descendant 子孙，下降\n\n> Mutable 可变的，不定的adj.\n\n> Immutable 不可变的adj.\n\n> Expand 扩张，使膨胀vt.\n\n> In term of 根据\n\n> Explanation 说明，解释n.\n\n> Regardless of 不管，不顾\n\n> Latter 后者n.\n\n> Prune 剪枝n.\n\n> Fluent 流动的adj.\n\n> Manual 手工的，手动的adj.\n\n> Notification 通知，通告n.\n\n> Entity 实体n.\n\n> Whereas 然而，反之n.\n\n> In case 万一\n\n> Persist 坚持，固执vi.\n\n> Snapshot 快照n.\n\n> Assert 断言n.\n\n> Quote 引号n.\n\n> Coroutine 协同程序n.\n\n> \n","slug":"professional-dictionary","published":1,"updated":"2021-12-30T03:04:10.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxsdzpyx000yxotgbky136mi","content":"<blockquote>\n<p>inference 推断 n.</p>\n</blockquote>\n<p>Lambda expressions include a form of type inference in Java.<br>Lambda表达式包含一种类型推导.</p>\n<blockquote>\n<p>assign 指派 v.</p>\n</blockquote>\n<p><code>Shape s = new Circle();</code>  This creates a Circle object, and the resulting reference is immediately assigned to a Shape.<br>这里翻译为”指派”, <code>s</code>被指派(指定)了一个类型Shape.</p>\n<blockquote>\n<p>oriented 导向的，定向的adj.</p>\n</blockquote>\n<blockquote>\n<p>object-oriented [计]面向对象的adj.</p>\n</blockquote>\n<blockquote>\n<p>Connector 端口，连接头n.</p>\n</blockquote>\n<blockquote>\n<p>Configure 配置v.</p>\n</blockquote>\n<blockquote>\n<p>Specified 指定的adj.</p>\n</blockquote>\n<blockquote>\n<p>Deploy 部署v.</p>\n</blockquote>\n<blockquote>\n<p>Undeploy 卸载v.</p>\n</blockquote>\n<blockquote>\n<p>Expire 终止v.</p>\n</blockquote>\n<blockquote>\n<p>Session 学期，一段时间n.</p>\n</blockquote>\n<blockquote>\n<p>Dynamic 动态的adj.</p>\n</blockquote>\n<blockquote>\n<p>Module 组件，单元，模块n.</p>\n</blockquote>\n<blockquote>\n<p>Directory 路径n.</p>\n</blockquote>\n<blockquote>\n<p>Descriptor 描述符n.</p>\n</blockquote>\n<blockquote>\n<p>Install 安装v.</p>\n</blockquote>\n<blockquote>\n<p>Synchronize 使同步v.</p>\n</blockquote>\n<blockquote>\n<p>Meta 元，meta语言n.</p>\n</blockquote>\n<blockquote>\n<p>Charset 字符集n.</p>\n</blockquote>\n<blockquote>\n<p>Charater 字符n.</p>\n</blockquote>\n<blockquote>\n<p>Flush 冲洗v.</p>\n</blockquote>\n<blockquote>\n<p>Mapping 映射n.</p>\n</blockquote>\n<blockquote>\n<p>Protocol 协议n.</p>\n</blockquote>\n<blockquote>\n<p>Generic 普通的；一般的adj.</p>\n</blockquote>\n<blockquote>\n<p>Initialize 初始化v.</p>\n</blockquote>\n<blockquote>\n<p>Sequence 一系列, 列表n.</p>\n</blockquote>\n<blockquote>\n<p>In addition to 除….之外</p>\n</blockquote>\n<blockquote>\n<p>Thread 线n.</p>\n</blockquote>\n<blockquote>\n<p>Timeout 超时，过期n.</p>\n</blockquote>\n<blockquote>\n<p>Summary 摘要n.</p>\n</blockquote>\n<blockquote>\n<p>Contain 容纳，限制v.</p>\n</blockquote>\n<blockquote>\n<p>Subclass 子类n.</p>\n</blockquote>\n<blockquote>\n<p>Declare 声明v.</p>\n</blockquote>\n<blockquote>\n<p>Dispatch 派遣，发送v.</p>\n</blockquote>\n<blockquote>\n<p>Additional 附加的，额外的adj.</p>\n</blockquote>\n<blockquote>\n<p>Stream 流n.   </p>\n</blockquote>\n<blockquote>\n<p>Input stream输入流</p>\n</blockquote>\n<blockquote>\n<p>Encode 编码v.</p>\n</blockquote>\n<blockquote>\n<p>URL 统一资源定位符</p>\n</blockquote>\n<blockquote>\n<p>URI 统一资源标识符</p>\n</blockquote>\n<blockquote>\n<p>Invalidate 使销毁，使作废v.</p>\n</blockquote>\n<blockquote>\n<p>Layer 层n.</p>\n</blockquote>\n<blockquote>\n<p>Prefix 前缀n.</p>\n</blockquote>\n<blockquote>\n<p>Tag标签 n.</p>\n</blockquote>\n<blockquote>\n<p>Wrapper 包装用品n.</p>\n</blockquote>\n<blockquote>\n<p>Filter 过滤器n.</p>\n</blockquote>\n<blockquote>\n<p>Chain 链条n.</p>\n</blockquote>\n<blockquote>\n<p>Notation 记号；表示法；记法n.</p>\n</blockquote>\n<blockquote>\n<p>Serialize　使连载v.</p>\n</blockquote>\n<blockquote>\n<p>Plugins 插件n.</p>\n</blockquote>\n<blockquote>\n<p>Validate 使生效v.</p>\n</blockquote>\n<blockquote>\n<p>Panel 面板；仪表盘n.</p>\n</blockquote>\n<blockquote>\n<p>Literal 字面上的；文字的adj.  </p>\n</blockquote>\n<blockquote>\n<p>Constant 不变的adj. 常量，恒量；n.</p>\n</blockquote>\n<blockquote>\n<p>Mutable 可变的adj.</p>\n</blockquote>\n<blockquote>\n<p>Specified 指定的；规定的adj.</p>\n</blockquote>\n<blockquote>\n<p>Collapsible 可折叠的，可收缩的adj.</p>\n</blockquote>\n<blockquote>\n<p>Icon 图标[计]；象征；偶像adj.</p>\n</blockquote>\n<blockquote>\n<p>Combo 组合物n.</p>\n</blockquote>\n<blockquote>\n<p>Handler 处理器n.</p>\n</blockquote>\n<blockquote>\n<p>Grid 格子，网格n.</p>\n</blockquote>\n<blockquote>\n<p>Validate 使生效；证实v.</p>\n</blockquote>\n<blockquote>\n<p>Required 必须的adj.</p>\n</blockquote>\n<blockquote>\n<p>Parse 解析v.   从语法上分析n.</p>\n</blockquote>\n<blockquote>\n<p>Separator 分隔符n.</p>\n</blockquote>\n<blockquote>\n<p>Interrupt 中断n.</p>\n</blockquote>\n<blockquote>\n<p>Runnable 可捕捉的，可猎取的 adj.</p>\n</blockquote>\n<blockquote>\n<p>Daemon 守护神，[计]守护线程n.</p>\n</blockquote>\n<blockquote>\n<p>Priority 优先级，优先权，优先顺序n.</p>\n</blockquote>\n<blockquote>\n<p>Notify 通知，报告v.</p>\n</blockquote>\n<blockquote>\n<p>Invoke引起v.</p>\n</blockquote>\n<blockquote>\n<p>Split 分裂，分离v.</p>\n</blockquote>\n<blockquote>\n<p>Deprecated 过时的adj.</p>\n</blockquote>\n<blockquote>\n<p>Suppress禁止，压制v.</p>\n</blockquote>\n<blockquote>\n<p>Retention 保持力，保存期限n.</p>\n</blockquote>\n<blockquote>\n<p>Annotation 注解，注释n.</p>\n</blockquote>\n<blockquote>\n<p>Nickname 昵称，绰号n.</p>\n</blockquote>\n<blockquote>\n<p>Invocation [计]调用；（法律的）实施；祈祷n.</p>\n</blockquote>\n<blockquote>\n<p>Template 样板，模板n.</p>\n</blockquote>\n<blockquote>\n<p>Intersect 交叉，相交v.</p>\n</blockquote>\n<blockquote>\n<p>Minus 减号，减去n.</p>\n</blockquote>\n<blockquote>\n<p>Increment 增加v.</p>\n</blockquote>\n<blockquote>\n<p>Validate 使..生效，确认；v.</p>\n</blockquote>\n<blockquote>\n<p>Encapsulation 包装，封装n.</p>\n</blockquote>\n<blockquote>\n<p>Polymorphism 多态性n.</p>\n</blockquote>\n<blockquote>\n<p>Catalog 目录n.</p>\n</blockquote>\n<blockquote>\n<p>Detached 游离的，分离的；adj.</p>\n</blockquote>\n<blockquote>\n<p>Persistent 持久的；adj.</p>\n</blockquote>\n<blockquote>\n<p>Transient 瞬时的；adj.</p>\n</blockquote>\n<blockquote>\n<p>Dependency 从属n.</p>\n</blockquote>\n<blockquote>\n<p>Injection 注射n.</p>\n</blockquote>\n<blockquote>\n<p>Component 成分，组件n.</p>\n</blockquote>\n<blockquote>\n<p>Schema [计]模式，范式n.</p>\n</blockquote>\n<blockquote>\n<p>Scheme 计划n.</p>\n</blockquote>\n<blockquote>\n<p>Suffix 后缀，下标n.</p>\n</blockquote>\n<blockquote>\n<p>Mechanism 机制，原理n.</p>\n</blockquote>\n<blockquote>\n<p>Facet 面，方面n.</p>\n</blockquote>\n<blockquote>\n<p>Validation 确认，批准，生效n.</p>\n</blockquote>\n<blockquote>\n<p>Duplicate 复制v.</p>\n</blockquote>\n<blockquote>\n<p>Invalid 无效的adj.</p>\n</blockquote>\n<blockquote>\n<p>Submission 投降，提交n.</p>\n</blockquote>\n<blockquote>\n<p>Alias 别名n.</p>\n</blockquote>\n<blockquote>\n<p>Argument 参数n.</p>\n</blockquote>\n<blockquote>\n<p>Requirements 需求，要求n.</p>\n</blockquote>\n<blockquote>\n<p>Neglect 疏忽，忽视vt.</p>\n</blockquote>\n<blockquote>\n<p>Term 术语n.</p>\n</blockquote>\n<blockquote>\n<p>Allocate 分配vt.</p>\n</blockquote>\n<blockquote>\n<p>Validate 验证，确认（表现为一般的检查）vt.</p>\n</blockquote>\n<blockquote>\n<p>Compile 编译vt.</p>\n</blockquote>\n<blockquote>\n<p>Verify 核实，查证（表现为要付出一段程序化的核实过程）vt.</p>\n</blockquote>\n<blockquote>\n<p>Repository 仓库，资源库，版本库n.</p>\n</blockquote>\n<blockquote>\n<p>Plugins 插件，外挂n.</p>\n</blockquote>\n<blockquote>\n<p>Procedure [计算机]过程 n.</p>\n</blockquote>\n<blockquote>\n<p>Retain 保持vt.</p>\n</blockquote>\n<blockquote>\n<p>Clause 从句 n.</p>\n</blockquote>\n<blockquote>\n<p>Via 通过 n.f</p>\n</blockquote>\n<blockquote>\n<p>Along with 连同，以及，和……一起</p>\n</blockquote>\n<blockquote>\n<p>Excluding 除……之外，不包括 prep.</p>\n</blockquote>\n<blockquote>\n<p>Standalone 单独的，独立的adj.</p>\n</blockquote>\n<blockquote>\n<p>Cluster 集群，簇n.</p>\n</blockquote>\n<blockquote>\n<p>Aggregation 集成，聚集n.</p>\n</blockquote>\n<blockquote>\n<p>Excerpt 摘录，摘要n.</p>\n</blockquote>\n<blockquote>\n<p>Integration 整合，集成n.</p>\n</blockquote>\n<blockquote>\n<p>Expectation 期待，盼望n.</p>\n</blockquote>\n<blockquote>\n<p>Composite 合成的adj. 使合成vt.</p>\n</blockquote>\n<blockquote>\n<p>Interaction 相互作用，相互影响n.</p>\n</blockquote>\n<blockquote>\n<p>Doubt 怀疑，不信n.vt.</p>\n</blockquote>\n<blockquote>\n<p>Field 字段，域n.</p>\n</blockquote>\n<blockquote>\n<p>Intermediate 起媒介作用vi. 中间的adj. 媒介n.</p>\n</blockquote>\n<blockquote>\n<p>Authorization 授权，认可n.</p>\n</blockquote>\n<blockquote>\n<p>Demarcation 界限，划分n.</p>\n</blockquote>\n<blockquote>\n<p>Conscious 意识到的adj.</p>\n</blockquote>\n<blockquote>\n<p>Retrieve 检索vt.</p>\n</blockquote>\n<blockquote>\n<p>Traverse 穿过，横越；[计]遍历vt.</p>\n</blockquote>\n<blockquote>\n<p>Breadth 宽度，广度n.</p>\n</blockquote>\n<blockquote>\n<p>Breadth First广度优先n.</p>\n</blockquote>\n<blockquote>\n<p>Evaluate 评价，评估vt.</p>\n</blockquote>\n<blockquote>\n<p>Perform 执行，机器运转，表演vt.</p>\n</blockquote>\n<blockquote>\n<p>Depth 深度n.</p>\n</blockquote>\n<blockquote>\n<p>Instantiate 实例化vt.</p>\n</blockquote>\n<blockquote>\n<p>Custom 习惯，惯例，风俗n.</p>\n</blockquote>\n<blockquote>\n<p>In this case 在这种情况下，在这个案例中</p>\n</blockquote>\n<blockquote>\n<p>Descent 下降n.</p>\n</blockquote>\n<blockquote>\n<p>Descendant 子孙，下降</p>\n</blockquote>\n<blockquote>\n<p>Mutable 可变的，不定的adj.</p>\n</blockquote>\n<blockquote>\n<p>Immutable 不可变的adj.</p>\n</blockquote>\n<blockquote>\n<p>Expand 扩张，使膨胀vt.</p>\n</blockquote>\n<blockquote>\n<p>In term of 根据</p>\n</blockquote>\n<blockquote>\n<p>Explanation 说明，解释n.</p>\n</blockquote>\n<blockquote>\n<p>Regardless of 不管，不顾</p>\n</blockquote>\n<blockquote>\n<p>Latter 后者n.</p>\n</blockquote>\n<blockquote>\n<p>Prune 剪枝n.</p>\n</blockquote>\n<blockquote>\n<p>Fluent 流动的adj.</p>\n</blockquote>\n<blockquote>\n<p>Manual 手工的，手动的adj.</p>\n</blockquote>\n<blockquote>\n<p>Notification 通知，通告n.</p>\n</blockquote>\n<blockquote>\n<p>Entity 实体n.</p>\n</blockquote>\n<blockquote>\n<p>Whereas 然而，反之n.</p>\n</blockquote>\n<blockquote>\n<p>In case 万一</p>\n</blockquote>\n<blockquote>\n<p>Persist 坚持，固执vi.</p>\n</blockquote>\n<blockquote>\n<p>Snapshot 快照n.</p>\n</blockquote>\n<blockquote>\n<p>Assert 断言n.</p>\n</blockquote>\n<blockquote>\n<p>Quote 引号n.</p>\n</blockquote>\n<blockquote>\n<p>Coroutine 协同程序n.</p>\n</blockquote>\n<blockquote>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>inference 推断 n.</p>\n</blockquote>\n<p>Lambda expressions include a form of type inference in Java.<br>Lambda表达式包含一种类型推导.</p>\n<blockquote>\n<p>assign 指派 v.</p>\n</blockquote>\n<p><code>Shape s = new Circle();</code>  This creates a Circle object, and the resulting reference is immediately assigned to a Shape.<br>这里翻译为”指派”, <code>s</code>被指派(指定)了一个类型Shape.</p>\n<blockquote>\n<p>oriented 导向的，定向的adj.</p>\n</blockquote>\n<blockquote>\n<p>object-oriented [计]面向对象的adj.</p>\n</blockquote>\n<blockquote>\n<p>Connector 端口，连接头n.</p>\n</blockquote>\n<blockquote>\n<p>Configure 配置v.</p>\n</blockquote>\n<blockquote>\n<p>Specified 指定的adj.</p>\n</blockquote>\n<blockquote>\n<p>Deploy 部署v.</p>\n</blockquote>\n<blockquote>\n<p>Undeploy 卸载v.</p>\n</blockquote>\n<blockquote>\n<p>Expire 终止v.</p>\n</blockquote>\n<blockquote>\n<p>Session 学期，一段时间n.</p>\n</blockquote>\n<blockquote>\n<p>Dynamic 动态的adj.</p>\n</blockquote>\n<blockquote>\n<p>Module 组件，单元，模块n.</p>\n</blockquote>\n<blockquote>\n<p>Directory 路径n.</p>\n</blockquote>\n<blockquote>\n<p>Descriptor 描述符n.</p>\n</blockquote>\n<blockquote>\n<p>Install 安装v.</p>\n</blockquote>\n<blockquote>\n<p>Synchronize 使同步v.</p>\n</blockquote>\n<blockquote>\n<p>Meta 元，meta语言n.</p>\n</blockquote>\n<blockquote>\n<p>Charset 字符集n.</p>\n</blockquote>\n<blockquote>\n<p>Charater 字符n.</p>\n</blockquote>\n<blockquote>\n<p>Flush 冲洗v.</p>\n</blockquote>\n<blockquote>\n<p>Mapping 映射n.</p>\n</blockquote>\n<blockquote>\n<p>Protocol 协议n.</p>\n</blockquote>\n<blockquote>\n<p>Generic 普通的；一般的adj.</p>\n</blockquote>\n<blockquote>\n<p>Initialize 初始化v.</p>\n</blockquote>\n<blockquote>\n<p>Sequence 一系列, 列表n.</p>\n</blockquote>\n<blockquote>\n<p>In addition to 除….之外</p>\n</blockquote>\n<blockquote>\n<p>Thread 线n.</p>\n</blockquote>\n<blockquote>\n<p>Timeout 超时，过期n.</p>\n</blockquote>\n<blockquote>\n<p>Summary 摘要n.</p>\n</blockquote>\n<blockquote>\n<p>Contain 容纳，限制v.</p>\n</blockquote>\n<blockquote>\n<p>Subclass 子类n.</p>\n</blockquote>\n<blockquote>\n<p>Declare 声明v.</p>\n</blockquote>\n<blockquote>\n<p>Dispatch 派遣，发送v.</p>\n</blockquote>\n<blockquote>\n<p>Additional 附加的，额外的adj.</p>\n</blockquote>\n<blockquote>\n<p>Stream 流n.   </p>\n</blockquote>\n<blockquote>\n<p>Input stream输入流</p>\n</blockquote>\n<blockquote>\n<p>Encode 编码v.</p>\n</blockquote>\n<blockquote>\n<p>URL 统一资源定位符</p>\n</blockquote>\n<blockquote>\n<p>URI 统一资源标识符</p>\n</blockquote>\n<blockquote>\n<p>Invalidate 使销毁，使作废v.</p>\n</blockquote>\n<blockquote>\n<p>Layer 层n.</p>\n</blockquote>\n<blockquote>\n<p>Prefix 前缀n.</p>\n</blockquote>\n<blockquote>\n<p>Tag标签 n.</p>\n</blockquote>\n<blockquote>\n<p>Wrapper 包装用品n.</p>\n</blockquote>\n<blockquote>\n<p>Filter 过滤器n.</p>\n</blockquote>\n<blockquote>\n<p>Chain 链条n.</p>\n</blockquote>\n<blockquote>\n<p>Notation 记号；表示法；记法n.</p>\n</blockquote>\n<blockquote>\n<p>Serialize　使连载v.</p>\n</blockquote>\n<blockquote>\n<p>Plugins 插件n.</p>\n</blockquote>\n<blockquote>\n<p>Validate 使生效v.</p>\n</blockquote>\n<blockquote>\n<p>Panel 面板；仪表盘n.</p>\n</blockquote>\n<blockquote>\n<p>Literal 字面上的；文字的adj.  </p>\n</blockquote>\n<blockquote>\n<p>Constant 不变的adj. 常量，恒量；n.</p>\n</blockquote>\n<blockquote>\n<p>Mutable 可变的adj.</p>\n</blockquote>\n<blockquote>\n<p>Specified 指定的；规定的adj.</p>\n</blockquote>\n<blockquote>\n<p>Collapsible 可折叠的，可收缩的adj.</p>\n</blockquote>\n<blockquote>\n<p>Icon 图标[计]；象征；偶像adj.</p>\n</blockquote>\n<blockquote>\n<p>Combo 组合物n.</p>\n</blockquote>\n<blockquote>\n<p>Handler 处理器n.</p>\n</blockquote>\n<blockquote>\n<p>Grid 格子，网格n.</p>\n</blockquote>\n<blockquote>\n<p>Validate 使生效；证实v.</p>\n</blockquote>\n<blockquote>\n<p>Required 必须的adj.</p>\n</blockquote>\n<blockquote>\n<p>Parse 解析v.   从语法上分析n.</p>\n</blockquote>\n<blockquote>\n<p>Separator 分隔符n.</p>\n</blockquote>\n<blockquote>\n<p>Interrupt 中断n.</p>\n</blockquote>\n<blockquote>\n<p>Runnable 可捕捉的，可猎取的 adj.</p>\n</blockquote>\n<blockquote>\n<p>Daemon 守护神，[计]守护线程n.</p>\n</blockquote>\n<blockquote>\n<p>Priority 优先级，优先权，优先顺序n.</p>\n</blockquote>\n<blockquote>\n<p>Notify 通知，报告v.</p>\n</blockquote>\n<blockquote>\n<p>Invoke引起v.</p>\n</blockquote>\n<blockquote>\n<p>Split 分裂，分离v.</p>\n</blockquote>\n<blockquote>\n<p>Deprecated 过时的adj.</p>\n</blockquote>\n<blockquote>\n<p>Suppress禁止，压制v.</p>\n</blockquote>\n<blockquote>\n<p>Retention 保持力，保存期限n.</p>\n</blockquote>\n<blockquote>\n<p>Annotation 注解，注释n.</p>\n</blockquote>\n<blockquote>\n<p>Nickname 昵称，绰号n.</p>\n</blockquote>\n<blockquote>\n<p>Invocation [计]调用；（法律的）实施；祈祷n.</p>\n</blockquote>\n<blockquote>\n<p>Template 样板，模板n.</p>\n</blockquote>\n<blockquote>\n<p>Intersect 交叉，相交v.</p>\n</blockquote>\n<blockquote>\n<p>Minus 减号，减去n.</p>\n</blockquote>\n<blockquote>\n<p>Increment 增加v.</p>\n</blockquote>\n<blockquote>\n<p>Validate 使..生效，确认；v.</p>\n</blockquote>\n<blockquote>\n<p>Encapsulation 包装，封装n.</p>\n</blockquote>\n<blockquote>\n<p>Polymorphism 多态性n.</p>\n</blockquote>\n<blockquote>\n<p>Catalog 目录n.</p>\n</blockquote>\n<blockquote>\n<p>Detached 游离的，分离的；adj.</p>\n</blockquote>\n<blockquote>\n<p>Persistent 持久的；adj.</p>\n</blockquote>\n<blockquote>\n<p>Transient 瞬时的；adj.</p>\n</blockquote>\n<blockquote>\n<p>Dependency 从属n.</p>\n</blockquote>\n<blockquote>\n<p>Injection 注射n.</p>\n</blockquote>\n<blockquote>\n<p>Component 成分，组件n.</p>\n</blockquote>\n<blockquote>\n<p>Schema [计]模式，范式n.</p>\n</blockquote>\n<blockquote>\n<p>Scheme 计划n.</p>\n</blockquote>\n<blockquote>\n<p>Suffix 后缀，下标n.</p>\n</blockquote>\n<blockquote>\n<p>Mechanism 机制，原理n.</p>\n</blockquote>\n<blockquote>\n<p>Facet 面，方面n.</p>\n</blockquote>\n<blockquote>\n<p>Validation 确认，批准，生效n.</p>\n</blockquote>\n<blockquote>\n<p>Duplicate 复制v.</p>\n</blockquote>\n<blockquote>\n<p>Invalid 无效的adj.</p>\n</blockquote>\n<blockquote>\n<p>Submission 投降，提交n.</p>\n</blockquote>\n<blockquote>\n<p>Alias 别名n.</p>\n</blockquote>\n<blockquote>\n<p>Argument 参数n.</p>\n</blockquote>\n<blockquote>\n<p>Requirements 需求，要求n.</p>\n</blockquote>\n<blockquote>\n<p>Neglect 疏忽，忽视vt.</p>\n</blockquote>\n<blockquote>\n<p>Term 术语n.</p>\n</blockquote>\n<blockquote>\n<p>Allocate 分配vt.</p>\n</blockquote>\n<blockquote>\n<p>Validate 验证，确认（表现为一般的检查）vt.</p>\n</blockquote>\n<blockquote>\n<p>Compile 编译vt.</p>\n</blockquote>\n<blockquote>\n<p>Verify 核实，查证（表现为要付出一段程序化的核实过程）vt.</p>\n</blockquote>\n<blockquote>\n<p>Repository 仓库，资源库，版本库n.</p>\n</blockquote>\n<blockquote>\n<p>Plugins 插件，外挂n.</p>\n</blockquote>\n<blockquote>\n<p>Procedure [计算机]过程 n.</p>\n</blockquote>\n<blockquote>\n<p>Retain 保持vt.</p>\n</blockquote>\n<blockquote>\n<p>Clause 从句 n.</p>\n</blockquote>\n<blockquote>\n<p>Via 通过 n.f</p>\n</blockquote>\n<blockquote>\n<p>Along with 连同，以及，和……一起</p>\n</blockquote>\n<blockquote>\n<p>Excluding 除……之外，不包括 prep.</p>\n</blockquote>\n<blockquote>\n<p>Standalone 单独的，独立的adj.</p>\n</blockquote>\n<blockquote>\n<p>Cluster 集群，簇n.</p>\n</blockquote>\n<blockquote>\n<p>Aggregation 集成，聚集n.</p>\n</blockquote>\n<blockquote>\n<p>Excerpt 摘录，摘要n.</p>\n</blockquote>\n<blockquote>\n<p>Integration 整合，集成n.</p>\n</blockquote>\n<blockquote>\n<p>Expectation 期待，盼望n.</p>\n</blockquote>\n<blockquote>\n<p>Composite 合成的adj. 使合成vt.</p>\n</blockquote>\n<blockquote>\n<p>Interaction 相互作用，相互影响n.</p>\n</blockquote>\n<blockquote>\n<p>Doubt 怀疑，不信n.vt.</p>\n</blockquote>\n<blockquote>\n<p>Field 字段，域n.</p>\n</blockquote>\n<blockquote>\n<p>Intermediate 起媒介作用vi. 中间的adj. 媒介n.</p>\n</blockquote>\n<blockquote>\n<p>Authorization 授权，认可n.</p>\n</blockquote>\n<blockquote>\n<p>Demarcation 界限，划分n.</p>\n</blockquote>\n<blockquote>\n<p>Conscious 意识到的adj.</p>\n</blockquote>\n<blockquote>\n<p>Retrieve 检索vt.</p>\n</blockquote>\n<blockquote>\n<p>Traverse 穿过，横越；[计]遍历vt.</p>\n</blockquote>\n<blockquote>\n<p>Breadth 宽度，广度n.</p>\n</blockquote>\n<blockquote>\n<p>Breadth First广度优先n.</p>\n</blockquote>\n<blockquote>\n<p>Evaluate 评价，评估vt.</p>\n</blockquote>\n<blockquote>\n<p>Perform 执行，机器运转，表演vt.</p>\n</blockquote>\n<blockquote>\n<p>Depth 深度n.</p>\n</blockquote>\n<blockquote>\n<p>Instantiate 实例化vt.</p>\n</blockquote>\n<blockquote>\n<p>Custom 习惯，惯例，风俗n.</p>\n</blockquote>\n<blockquote>\n<p>In this case 在这种情况下，在这个案例中</p>\n</blockquote>\n<blockquote>\n<p>Descent 下降n.</p>\n</blockquote>\n<blockquote>\n<p>Descendant 子孙，下降</p>\n</blockquote>\n<blockquote>\n<p>Mutable 可变的，不定的adj.</p>\n</blockquote>\n<blockquote>\n<p>Immutable 不可变的adj.</p>\n</blockquote>\n<blockquote>\n<p>Expand 扩张，使膨胀vt.</p>\n</blockquote>\n<blockquote>\n<p>In term of 根据</p>\n</blockquote>\n<blockquote>\n<p>Explanation 说明，解释n.</p>\n</blockquote>\n<blockquote>\n<p>Regardless of 不管，不顾</p>\n</blockquote>\n<blockquote>\n<p>Latter 后者n.</p>\n</blockquote>\n<blockquote>\n<p>Prune 剪枝n.</p>\n</blockquote>\n<blockquote>\n<p>Fluent 流动的adj.</p>\n</blockquote>\n<blockquote>\n<p>Manual 手工的，手动的adj.</p>\n</blockquote>\n<blockquote>\n<p>Notification 通知，通告n.</p>\n</blockquote>\n<blockquote>\n<p>Entity 实体n.</p>\n</blockquote>\n<blockquote>\n<p>Whereas 然而，反之n.</p>\n</blockquote>\n<blockquote>\n<p>In case 万一</p>\n</blockquote>\n<blockquote>\n<p>Persist 坚持，固执vi.</p>\n</blockquote>\n<blockquote>\n<p>Snapshot 快照n.</p>\n</blockquote>\n<blockquote>\n<p>Assert 断言n.</p>\n</blockquote>\n<blockquote>\n<p>Quote 引号n.</p>\n</blockquote>\n<blockquote>\n<p>Coroutine 协同程序n.</p>\n</blockquote>\n<blockquote>\n</blockquote>\n"},{"title":"序列化和反序列化","date":"2021-11-22T08:22:51.000Z","_content":"序列化： 将数据结构或对象转换成二进制串的过程\n反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程\n\n# Java Serialization\nSerialization is the conversion of the state of an object into a byte stream; deserialization does the opposite. \nStated differently, serialization is the conversion of **a Java object into a static stream (sequence) of bytes** which can then be saved to a database or transferred over a network.\n\nif further, reference: \nhttps://snyk.io/blog/serialization-and-deserialization-in-java/\n","source":"_posts/serialization-deserialization.md","raw":"---\ntitle: 序列化和反序列化\ndate: 2021-11-22 16:22:51\ntags:\n- Serialization\n---\n序列化： 将数据结构或对象转换成二进制串的过程\n反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程\n\n# Java Serialization\nSerialization is the conversion of the state of an object into a byte stream; deserialization does the opposite. \nStated differently, serialization is the conversion of **a Java object into a static stream (sequence) of bytes** which can then be saved to a database or transferred over a network.\n\nif further, reference: \nhttps://snyk.io/blog/serialization-and-deserialization-in-java/\n","slug":"serialization-deserialization","published":1,"updated":"2021-12-30T02:54:18.957Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxsdzpyz0012xotg2tceetz9","content":"<p>序列化： 将数据结构或对象转换成二进制串的过程<br>反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程</p>\n<h1 id=\"Java-Serialization\"><a href=\"#Java-Serialization\" class=\"headerlink\" title=\"Java Serialization\"></a>Java Serialization</h1><p>Serialization is the conversion of the state of an object into a byte stream; deserialization does the opposite.<br>Stated differently, serialization is the conversion of <strong>a Java object into a static stream (sequence) of bytes</strong> which can then be saved to a database or transferred over a network.</p>\n<p>if further, reference:<br><a href=\"https://snyk.io/blog/serialization-and-deserialization-in-java/\">https://snyk.io/blog/serialization-and-deserialization-in-java/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>序列化： 将数据结构或对象转换成二进制串的过程<br>反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程</p>\n<h1 id=\"Java-Serialization\"><a href=\"#Java-Serialization\" class=\"headerlink\" title=\"Java Serialization\"></a>Java Serialization</h1><p>Serialization is the conversion of the state of an object into a byte stream; deserialization does the opposite.<br>Stated differently, serialization is the conversion of <strong>a Java object into a static stream (sequence) of bytes</strong> which can then be saved to a database or transferred over a network.</p>\n<p>if further, reference:<br><a href=\"https://snyk.io/blog/serialization-and-deserialization-in-java/\">https://snyk.io/blog/serialization-and-deserialization-in-java/</a></p>\n"},{"title":"Spring AOP原理","date":"2021-10-01T11:07:03.000Z","_content":"\n# AOP概念\n对于系统中普遍的业务关注点, OOP可以很好地对其进行分解并使之模块化, 但是却无法更好地避免类似于系统需求的实现在系统中各处散落这样的问题. 所以, 我们要寻求一种更好的办法在OOP的基础上更上一层楼. 我们可以推翻OOP的概念提出一套全新的思路, 但是也可以在此基础上提供一种补足方案. 后来我们找到了AOP.\n - 静态AOP, 第一代AOP, 以AspectJ为代表. 特点是, 相应的很切关注点以Aspect形式实现之后, 会通过特定的编译器, 将实现后的Aspect编译并织入到系统的静态类中. 比如, AspectJ会使用ajc编译器将各个Aspect以Java字节码的形式编译到Java类中, Java虚拟机可以像通常一样加载Java类运行.\n - 动态AOP, 第二代AOP, 通过Java语言的动态特性来实现Aspect织入到系统的过程, 比如Spring AOP.\n\n ### Joinpoint\n 首先我们需要知道在哪些执行点上进行织入操作, 这些将要在其之上进行织入操作的系统执行点, 称之为Joinpoint. 比如, 方法调用时, 执行时, 字段设置时, 异常处理时, 类初始化时等等.\n ### Pointcut\n 接下来需要知道在什么地方(Joinpoint)织入横切逻辑. 比如, 指定Joinpoint所在方法的名称, 或者利用正则表达式表述出所有符合条件的多组Joinpoint.\n ### Advice\n 逻辑载体, 即织入到Joinpoint的横切逻辑. 它分为几种形式:\n  - Before Advice, 在Joinpoint位置之前执行的Advice类型\n  - After Advice, 在Joinpoint位置之后, 包括After returning Advice, Afterthrowing Advice等\n  - Around Advice, 这里应该叫做拦截器比较好, Interceptor. 它也可以完成Before Advice和After Advice的功能.\n  - Introduction\n ### Aspect\n Aspect是对以上三者进行封装的AOP概念.\n\n# Spring AOP\nAOP是一种理论, Spring AOP是针对Spring框架落地的一种AOP实现. Spring的设计哲学是简单而强大, 用20%的AOP的支持来满足80%的场景.\n\n ## 动态代理与CGLIB(基于ASM)\n 动态代理, 这里不再赘述, 在博客里有专门剖析.\n 结合Spring AOP来说, 动态代理实现InvocationHandler的类是我们实现横切逻辑的地方, 它是横切逻辑的载体, 作用和Advice是一样的. 这就理解了Advice是什么了.\n 动态代理虽好, 但是不能满足所有需求. 因为动态代理机制只能对实现了相应Interface的类使用, 如果某个类没有实现任何Interface, 就无法使用动态代理机制为其生成相应的动态代理对象.\n\n 使用动态字节码生成技术扩展对象行为的原理是, 我们可以对目标对象进行继承扩展, 为其生成相应的子类, 而子类可以通过重写来扩展父类的行为, 只要将横切逻辑放的实现放到子类中, 然后让系统使用扩展后的目标对象的子类, 就可以达到相同的目的了. CGLIB可以对实现了某种接口的类, 或者没有实现任何接口的类都可以进行扩展.\n 通常我们会直接使用`net.sf.cglib.proxy.MethodInterceptor`接口(扩展了net.sf.cglib.proxy.Callback接口): \n ```java\n class Requestable {\n     public void request(){\n         System.out.println(\"OK\");\n     }\n }\n public class RequestCtrlInterceptor implements MethodInterceptor {\n     private static final Log logger = LogFactory.getLog(RequestCtrlInterceptor.class);\n     public Object intercept(Object object, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n         if(method.getName().equals(\"request\")) {\n            TimeOfDay startTime = new TiemOfDay(0, 0, 0);\n            TimeOfDay endTime = new TiemOfDay(5, 59, 59);\n            TiemOfDay currentTime = new TimeDay();\n            if(currentTime.isAfter(startTime) && currentTime.isBefore(endTime)) {\n                logger.warn(\"Service is not available now.\");\n                return null;\n            }\n            return proxy.invokeSuper(object, args);\n         }\n         return null;\n     }\n }\n ```\n 这样, RequestCtrlInterceptor就实现了对request()方法请求进行访问控制的逻辑. 现在我们要通过CGLIB的Enhance类为目标动态生成一个类, 并将RequestCtrlInterceptor中的横切逻辑附加到该子类中, 代码如下:\n ```Java\n Enhancer enhancer = new Enhancer();\n enhancer.setSuperclass(Requestable.class);\n enhancer.setCallback(new RequestCtrlInterceptor());\n \n Requestable proxy = (Requestable) enhancer.create();\n proxy.request();\n ```\n 这里是使用Enhancer来演示在对象中加入横切逻辑, 在后续的内容中我们将会使用经过封装的更高级的Spring AOP工具, Advisor\n\n# Spring AOP\n对于Joinpoint, Spring AOP仅支持方法级别的Joinpoint, 更确切的说, 仅支持方法执行(Method Execution)类型的Joinpoint, 原因有以下几点:\n - Spring AOP设计理念是简单而强大\n - 对于类属性Field级别的Joinpoint, 完全可以使用getter/setter方法的拦截来达到同样的目的\n - 如果要求十分特殊, 借助AspectJ即可(当然即使是AspectJ这样支持很多Joinpoint类型的AOP实现产品, 也无法保证能捕捉到程序流程中的任何一个点)\n\n对于Pointcut, Spring AOP提供了org.springframework.aop.Pointcut接口\n```java\npublic interface Pointcut {\n    ClassFilter getClassFilter;\n    MethodMatcher getMethodMatcher;\n    Pointcut TRUE = TruePointcut.INSTANCE;\n}\n```\n见名知意, 不是重点, 不再赘述\n\n对于Advice, Advice是实现了将织入到Pointcut规定的Joinpoint处的横切逻辑. Advice的几种类型, 重点介绍Around Advice.\nSrping中没有直接定义Around Advice的实现接口, 而是采用AOP Alliance的标准接口, 即: `org.aopalliance.intercept.MethodInterceptor`, 该接口定义如下: \n```java\npackage org.aopalliance.intercept;\n\n/**\n * Intercepts calls on an interface on its way to the target. These\n * are nested \"on top\" of the target.\n * ...\n */\n@FunctionalInterface\npublic interface MethodInterceptor extends Interceptor {\n\n\t/**\n\t * Implement this method to perform extra treatments before and\n\t * after the invocation. Polite implementations would certainly\n\t * like to invoke {@link Joinpoint#proceed()}.\n\t * @param invocation the method invocation joinpoint\n\t * @return the result of the call to {@link Joinpoint#proceed()};\n\t * might be intercepted by the interceptor\n\t * @throws Throwable if the interceptors or the target object\n\t * throws an exception\n\t */\n\tObject invoke(MethodInvocation invocation) throws Throwable;\n}\n```\n其他的Advice能做到的事情, 它都可以做, 或者说Around Advice可以应用的场景很多, 例如: 系统安全检查/系统各处性能检测/日志记录/系统附件行为的添加等.\n\n接下来是一个场景: 销售系统, 在商场优惠期间, 所有的商品一律8折, 那么我们在系统中所有取得商品价格的地方插入如下横切逻辑.\n```java\npublic class DiscountMethodInterceptor implements MethodInterceptor {\n    private static final Integer DEFAULT_DISCOUNT_RATIO = 80;\n\n    public Object invoke (MethodInvocation invocation) throws Throwable {\n        Object returnValue = invocation.proceed();\n        return ((Integer) returnValue) * DEFAULT_DISCOUNT_RATIO / 100;\n    }\n}\n```\n> 通过MethodInvocation的invoke方法的MethodInvocation参数, 我们可以控制相应的Joinpoint的拦截行为. 通过调用MethodInvocation的proceed()方法, 可以让程序执行继续沿着调用链传播, 这是我们所希望的行为. 如果我们在哪一个MethodInterceptor中没有调用proceed(),那么程序的执行将会在MethodInterceptor处\"短路\".\n\n我们使用了Spring框架, 并且这些Advice实现都是普通的POJO, 更多时候, 会直接将其集成到IoC容器中, 如下所示:\n```XML\n<bean id=\"discountInterceptor\" class=\"...DiscountMethodInterceptor\"></bean>\n```\n\n当我定义了多个MethodInterceptor时, 他们是如何执行呢?这就要用到**{% post_link java-chain-of-responsibility '责任链模式' %}**\n\n# SpringAOP的织入\nAspectJ使用ajc编译器作为它的织入器, 在SpringAOP中使用`org.springframework.aop.ProxyFactory`, 在Spring AOP中这是最基本的织入器.\n\n总的思路是: **Spring AIO是基于代理模式的AOP实现, 织入完成后, 会返回织入横切逻辑的代理对象**. 也就是说ProxyFactory返回织入了横切逻辑的代理对象.\n\n使用ProxyFactory需要两个基本的东西, 一个是传入进行织入的目标对象, 一个是将要应用到目标对象的Aspect(在Spring中叫做Advisor). 指定对应的Advisor, 就可以添加各种类型的Advice, 比如伪代码:\n```Java\nProxyFactory weaver = new ProxyFactory(new Executable());\nNameMatchMethodPointcutAdvisor advisor = new NameMathMethodPointcutAdvisor();\nadvisor.setMappedName(\"request\");\nadvisor.setAdvice(new RequestCtrlInterceptor());\nweaver.addAdvisor(advisor);\n\n// \nweaver.setProxyTargetClass(true);\n\nRequestable proxyObject = (Requestable) weaver.getProxy();\nproxyObject.request();\nSystem.out.println(proxyObject.getClass());\n\n// out\n// class ...Requestable$$EnhancerByCGLIB$$9e62fc83\n// 从输出中可以看出ProxyFactory底层还是使用了之前的Enhancer, 也可以看出通过CGLIB得到的类的命名方式与动态代理的方式不太一样, 动态代理是\"$Proxy0\"\n```\n\n我们知道Spring AOP在使用代理模式实现AOP的过程中采用了动态代理和CGLIB两种机制, 分别对实现了某些接口的目标类和没有实现任何接口的目标类进行代理. 当目标类没有实现任何接口时, 默认使用动态代理, 但是这里设置了`proxyTargetClass`的属性为`true`, 强制其采用基于类的代理, 即使目标类确实是基于接口的.\n\n## 探索ProxyFactory本质\n先来看一下类之间的关系\n{% plantuml %}\nAdvisedSupport <.. AopProxyFactory: according to\ninterface AopProxyFactory {\n    AopProxy createAopProxy(AdvisedSupport config)\n}\nAopProxyFactory <|.. DefaultAopProxyFactory\n\nAopFactory <.. AopProxyFactory: create\ninterface AopFactory {\n    Object getProxy()\n    Object getProxy(ClassLoader classLoader)\n}\n\nAopFactory <|.. JdkDynamicProxy\n\nJdkDynamicProxy ..|> InvocationHandler\ninterface InvocationHandler {}\n\nAopFactory <|.. Cglib2AopProxy\n\n{% endplantuml%}\n\n其中AopProxy有Cglib2AopProxy和JdkDynamicProxy两种实现. 因为动态代理需要通过InvocationHandler提供调用拦截, 所以JdkDynamicProxy同时也要实现InvocationHandler接口.\n\nAopProxy实例化代理对象的过程采用了抽象工厂模式进行封装, 即通过AopProxyFactory进行.\n```java\npublic interface AopProxyFactory {\n\n\t/**\n\t * Create an {@link AopProxy} for the given AOP configuration.\n\t * @param config the AOP configuration in the form of an\n\t * AdvisedSupport object\n\t * @return the corresponding AOP proxy\n\t * @throws AopConfigException if the configuration is invalid\n\t */\n\tAopProxy createAopProxy(AdvisedSupport config) throws AopConfigException;\n\n}\n\n```\nAopProxyFactory的实现类只有一个, 就是DefaultAopProxyFactory, 在DefaultAopProxyFactory会经过一个判断来决定使用Cglib还是动态代理\n```java\nif(config.isOptimize || config.isProxyTargetClass() || ...) {\n    // 创建Cglib2AopProxy实例, 返回\n} else {\n    // 创建JdkDynamicAopProxy实例, 返回\n}\n```\n以下内容定格在177页, 关于AOP的剩余内容以后在补充.\n\n\n一个类如果不声明, 默认的构造方法, 那么他到底有没有默认的构造方法? 没有\n一个类声明了默认的构造方法, 但是没有写访问控制符, 那么这个访问控制符是什么? \n一个类声明了默认的构造方法, 但是没有写访问控制符, 为什么通过Class.forName(...).getConstructor()会抛出NoSuchMethodException?\n\n\n\n\n","source":"_posts/spring-aop.md","raw":"---\ntitle: Spring AOP原理\ndate: 2021-09-31 19:07:03\ncategories:\n- Spring\ntags:\n- AOP\n- Spring\n---\n\n# AOP概念\n对于系统中普遍的业务关注点, OOP可以很好地对其进行分解并使之模块化, 但是却无法更好地避免类似于系统需求的实现在系统中各处散落这样的问题. 所以, 我们要寻求一种更好的办法在OOP的基础上更上一层楼. 我们可以推翻OOP的概念提出一套全新的思路, 但是也可以在此基础上提供一种补足方案. 后来我们找到了AOP.\n - 静态AOP, 第一代AOP, 以AspectJ为代表. 特点是, 相应的很切关注点以Aspect形式实现之后, 会通过特定的编译器, 将实现后的Aspect编译并织入到系统的静态类中. 比如, AspectJ会使用ajc编译器将各个Aspect以Java字节码的形式编译到Java类中, Java虚拟机可以像通常一样加载Java类运行.\n - 动态AOP, 第二代AOP, 通过Java语言的动态特性来实现Aspect织入到系统的过程, 比如Spring AOP.\n\n ### Joinpoint\n 首先我们需要知道在哪些执行点上进行织入操作, 这些将要在其之上进行织入操作的系统执行点, 称之为Joinpoint. 比如, 方法调用时, 执行时, 字段设置时, 异常处理时, 类初始化时等等.\n ### Pointcut\n 接下来需要知道在什么地方(Joinpoint)织入横切逻辑. 比如, 指定Joinpoint所在方法的名称, 或者利用正则表达式表述出所有符合条件的多组Joinpoint.\n ### Advice\n 逻辑载体, 即织入到Joinpoint的横切逻辑. 它分为几种形式:\n  - Before Advice, 在Joinpoint位置之前执行的Advice类型\n  - After Advice, 在Joinpoint位置之后, 包括After returning Advice, Afterthrowing Advice等\n  - Around Advice, 这里应该叫做拦截器比较好, Interceptor. 它也可以完成Before Advice和After Advice的功能.\n  - Introduction\n ### Aspect\n Aspect是对以上三者进行封装的AOP概念.\n\n# Spring AOP\nAOP是一种理论, Spring AOP是针对Spring框架落地的一种AOP实现. Spring的设计哲学是简单而强大, 用20%的AOP的支持来满足80%的场景.\n\n ## 动态代理与CGLIB(基于ASM)\n 动态代理, 这里不再赘述, 在博客里有专门剖析.\n 结合Spring AOP来说, 动态代理实现InvocationHandler的类是我们实现横切逻辑的地方, 它是横切逻辑的载体, 作用和Advice是一样的. 这就理解了Advice是什么了.\n 动态代理虽好, 但是不能满足所有需求. 因为动态代理机制只能对实现了相应Interface的类使用, 如果某个类没有实现任何Interface, 就无法使用动态代理机制为其生成相应的动态代理对象.\n\n 使用动态字节码生成技术扩展对象行为的原理是, 我们可以对目标对象进行继承扩展, 为其生成相应的子类, 而子类可以通过重写来扩展父类的行为, 只要将横切逻辑放的实现放到子类中, 然后让系统使用扩展后的目标对象的子类, 就可以达到相同的目的了. CGLIB可以对实现了某种接口的类, 或者没有实现任何接口的类都可以进行扩展.\n 通常我们会直接使用`net.sf.cglib.proxy.MethodInterceptor`接口(扩展了net.sf.cglib.proxy.Callback接口): \n ```java\n class Requestable {\n     public void request(){\n         System.out.println(\"OK\");\n     }\n }\n public class RequestCtrlInterceptor implements MethodInterceptor {\n     private static final Log logger = LogFactory.getLog(RequestCtrlInterceptor.class);\n     public Object intercept(Object object, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n         if(method.getName().equals(\"request\")) {\n            TimeOfDay startTime = new TiemOfDay(0, 0, 0);\n            TimeOfDay endTime = new TiemOfDay(5, 59, 59);\n            TiemOfDay currentTime = new TimeDay();\n            if(currentTime.isAfter(startTime) && currentTime.isBefore(endTime)) {\n                logger.warn(\"Service is not available now.\");\n                return null;\n            }\n            return proxy.invokeSuper(object, args);\n         }\n         return null;\n     }\n }\n ```\n 这样, RequestCtrlInterceptor就实现了对request()方法请求进行访问控制的逻辑. 现在我们要通过CGLIB的Enhance类为目标动态生成一个类, 并将RequestCtrlInterceptor中的横切逻辑附加到该子类中, 代码如下:\n ```Java\n Enhancer enhancer = new Enhancer();\n enhancer.setSuperclass(Requestable.class);\n enhancer.setCallback(new RequestCtrlInterceptor());\n \n Requestable proxy = (Requestable) enhancer.create();\n proxy.request();\n ```\n 这里是使用Enhancer来演示在对象中加入横切逻辑, 在后续的内容中我们将会使用经过封装的更高级的Spring AOP工具, Advisor\n\n# Spring AOP\n对于Joinpoint, Spring AOP仅支持方法级别的Joinpoint, 更确切的说, 仅支持方法执行(Method Execution)类型的Joinpoint, 原因有以下几点:\n - Spring AOP设计理念是简单而强大\n - 对于类属性Field级别的Joinpoint, 完全可以使用getter/setter方法的拦截来达到同样的目的\n - 如果要求十分特殊, 借助AspectJ即可(当然即使是AspectJ这样支持很多Joinpoint类型的AOP实现产品, 也无法保证能捕捉到程序流程中的任何一个点)\n\n对于Pointcut, Spring AOP提供了org.springframework.aop.Pointcut接口\n```java\npublic interface Pointcut {\n    ClassFilter getClassFilter;\n    MethodMatcher getMethodMatcher;\n    Pointcut TRUE = TruePointcut.INSTANCE;\n}\n```\n见名知意, 不是重点, 不再赘述\n\n对于Advice, Advice是实现了将织入到Pointcut规定的Joinpoint处的横切逻辑. Advice的几种类型, 重点介绍Around Advice.\nSrping中没有直接定义Around Advice的实现接口, 而是采用AOP Alliance的标准接口, 即: `org.aopalliance.intercept.MethodInterceptor`, 该接口定义如下: \n```java\npackage org.aopalliance.intercept;\n\n/**\n * Intercepts calls on an interface on its way to the target. These\n * are nested \"on top\" of the target.\n * ...\n */\n@FunctionalInterface\npublic interface MethodInterceptor extends Interceptor {\n\n\t/**\n\t * Implement this method to perform extra treatments before and\n\t * after the invocation. Polite implementations would certainly\n\t * like to invoke {@link Joinpoint#proceed()}.\n\t * @param invocation the method invocation joinpoint\n\t * @return the result of the call to {@link Joinpoint#proceed()};\n\t * might be intercepted by the interceptor\n\t * @throws Throwable if the interceptors or the target object\n\t * throws an exception\n\t */\n\tObject invoke(MethodInvocation invocation) throws Throwable;\n}\n```\n其他的Advice能做到的事情, 它都可以做, 或者说Around Advice可以应用的场景很多, 例如: 系统安全检查/系统各处性能检测/日志记录/系统附件行为的添加等.\n\n接下来是一个场景: 销售系统, 在商场优惠期间, 所有的商品一律8折, 那么我们在系统中所有取得商品价格的地方插入如下横切逻辑.\n```java\npublic class DiscountMethodInterceptor implements MethodInterceptor {\n    private static final Integer DEFAULT_DISCOUNT_RATIO = 80;\n\n    public Object invoke (MethodInvocation invocation) throws Throwable {\n        Object returnValue = invocation.proceed();\n        return ((Integer) returnValue) * DEFAULT_DISCOUNT_RATIO / 100;\n    }\n}\n```\n> 通过MethodInvocation的invoke方法的MethodInvocation参数, 我们可以控制相应的Joinpoint的拦截行为. 通过调用MethodInvocation的proceed()方法, 可以让程序执行继续沿着调用链传播, 这是我们所希望的行为. 如果我们在哪一个MethodInterceptor中没有调用proceed(),那么程序的执行将会在MethodInterceptor处\"短路\".\n\n我们使用了Spring框架, 并且这些Advice实现都是普通的POJO, 更多时候, 会直接将其集成到IoC容器中, 如下所示:\n```XML\n<bean id=\"discountInterceptor\" class=\"...DiscountMethodInterceptor\"></bean>\n```\n\n当我定义了多个MethodInterceptor时, 他们是如何执行呢?这就要用到**{% post_link java-chain-of-responsibility '责任链模式' %}**\n\n# SpringAOP的织入\nAspectJ使用ajc编译器作为它的织入器, 在SpringAOP中使用`org.springframework.aop.ProxyFactory`, 在Spring AOP中这是最基本的织入器.\n\n总的思路是: **Spring AIO是基于代理模式的AOP实现, 织入完成后, 会返回织入横切逻辑的代理对象**. 也就是说ProxyFactory返回织入了横切逻辑的代理对象.\n\n使用ProxyFactory需要两个基本的东西, 一个是传入进行织入的目标对象, 一个是将要应用到目标对象的Aspect(在Spring中叫做Advisor). 指定对应的Advisor, 就可以添加各种类型的Advice, 比如伪代码:\n```Java\nProxyFactory weaver = new ProxyFactory(new Executable());\nNameMatchMethodPointcutAdvisor advisor = new NameMathMethodPointcutAdvisor();\nadvisor.setMappedName(\"request\");\nadvisor.setAdvice(new RequestCtrlInterceptor());\nweaver.addAdvisor(advisor);\n\n// \nweaver.setProxyTargetClass(true);\n\nRequestable proxyObject = (Requestable) weaver.getProxy();\nproxyObject.request();\nSystem.out.println(proxyObject.getClass());\n\n// out\n// class ...Requestable$$EnhancerByCGLIB$$9e62fc83\n// 从输出中可以看出ProxyFactory底层还是使用了之前的Enhancer, 也可以看出通过CGLIB得到的类的命名方式与动态代理的方式不太一样, 动态代理是\"$Proxy0\"\n```\n\n我们知道Spring AOP在使用代理模式实现AOP的过程中采用了动态代理和CGLIB两种机制, 分别对实现了某些接口的目标类和没有实现任何接口的目标类进行代理. 当目标类没有实现任何接口时, 默认使用动态代理, 但是这里设置了`proxyTargetClass`的属性为`true`, 强制其采用基于类的代理, 即使目标类确实是基于接口的.\n\n## 探索ProxyFactory本质\n先来看一下类之间的关系\n{% plantuml %}\nAdvisedSupport <.. AopProxyFactory: according to\ninterface AopProxyFactory {\n    AopProxy createAopProxy(AdvisedSupport config)\n}\nAopProxyFactory <|.. DefaultAopProxyFactory\n\nAopFactory <.. AopProxyFactory: create\ninterface AopFactory {\n    Object getProxy()\n    Object getProxy(ClassLoader classLoader)\n}\n\nAopFactory <|.. JdkDynamicProxy\n\nJdkDynamicProxy ..|> InvocationHandler\ninterface InvocationHandler {}\n\nAopFactory <|.. Cglib2AopProxy\n\n{% endplantuml%}\n\n其中AopProxy有Cglib2AopProxy和JdkDynamicProxy两种实现. 因为动态代理需要通过InvocationHandler提供调用拦截, 所以JdkDynamicProxy同时也要实现InvocationHandler接口.\n\nAopProxy实例化代理对象的过程采用了抽象工厂模式进行封装, 即通过AopProxyFactory进行.\n```java\npublic interface AopProxyFactory {\n\n\t/**\n\t * Create an {@link AopProxy} for the given AOP configuration.\n\t * @param config the AOP configuration in the form of an\n\t * AdvisedSupport object\n\t * @return the corresponding AOP proxy\n\t * @throws AopConfigException if the configuration is invalid\n\t */\n\tAopProxy createAopProxy(AdvisedSupport config) throws AopConfigException;\n\n}\n\n```\nAopProxyFactory的实现类只有一个, 就是DefaultAopProxyFactory, 在DefaultAopProxyFactory会经过一个判断来决定使用Cglib还是动态代理\n```java\nif(config.isOptimize || config.isProxyTargetClass() || ...) {\n    // 创建Cglib2AopProxy实例, 返回\n} else {\n    // 创建JdkDynamicAopProxy实例, 返回\n}\n```\n以下内容定格在177页, 关于AOP的剩余内容以后在补充.\n\n\n一个类如果不声明, 默认的构造方法, 那么他到底有没有默认的构造方法? 没有\n一个类声明了默认的构造方法, 但是没有写访问控制符, 那么这个访问控制符是什么? \n一个类声明了默认的构造方法, 但是没有写访问控制符, 为什么通过Class.forName(...).getConstructor()会抛出NoSuchMethodException?\n\n\n\n\n","slug":"spring-aop","published":1,"updated":"2021-12-30T03:04:35.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxsdzpz10015xotgg4ppd5tt","content":"<h1 id=\"AOP概念\"><a href=\"#AOP概念\" class=\"headerlink\" title=\"AOP概念\"></a>AOP概念</h1><p>对于系统中普遍的业务关注点, OOP可以很好地对其进行分解并使之模块化, 但是却无法更好地避免类似于系统需求的实现在系统中各处散落这样的问题. 所以, 我们要寻求一种更好的办法在OOP的基础上更上一层楼. 我们可以推翻OOP的概念提出一套全新的思路, 但是也可以在此基础上提供一种补足方案. 后来我们找到了AOP.</p>\n<ul>\n<li>静态AOP, 第一代AOP, 以AspectJ为代表. 特点是, 相应的很切关注点以Aspect形式实现之后, 会通过特定的编译器, 将实现后的Aspect编译并织入到系统的静态类中. 比如, AspectJ会使用ajc编译器将各个Aspect以Java字节码的形式编译到Java类中, Java虚拟机可以像通常一样加载Java类运行.</li>\n<li>动态AOP, 第二代AOP, 通过Java语言的动态特性来实现Aspect织入到系统的过程, 比如Spring AOP.</li>\n</ul>\n<h3 id=\"Joinpoint\"><a href=\"#Joinpoint\" class=\"headerlink\" title=\"Joinpoint\"></a>Joinpoint</h3><p> 首先我们需要知道在哪些执行点上进行织入操作, 这些将要在其之上进行织入操作的系统执行点, 称之为Joinpoint. 比如, 方法调用时, 执行时, 字段设置时, 异常处理时, 类初始化时等等.</p>\n<h3 id=\"Pointcut\"><a href=\"#Pointcut\" class=\"headerlink\" title=\"Pointcut\"></a>Pointcut</h3><p> 接下来需要知道在什么地方(Joinpoint)织入横切逻辑. 比如, 指定Joinpoint所在方法的名称, 或者利用正则表达式表述出所有符合条件的多组Joinpoint.</p>\n<h3 id=\"Advice\"><a href=\"#Advice\" class=\"headerlink\" title=\"Advice\"></a>Advice</h3><p> 逻辑载体, 即织入到Joinpoint的横切逻辑. 它分为几种形式:</p>\n<ul>\n<li>Before Advice, 在Joinpoint位置之前执行的Advice类型</li>\n<li>After Advice, 在Joinpoint位置之后, 包括After returning Advice, Afterthrowing Advice等</li>\n<li>Around Advice, 这里应该叫做拦截器比较好, Interceptor. 它也可以完成Before Advice和After Advice的功能.</li>\n<li>Introduction<h3 id=\"Aspect\"><a href=\"#Aspect\" class=\"headerlink\" title=\"Aspect\"></a>Aspect</h3>Aspect是对以上三者进行封装的AOP概念.</li>\n</ul>\n<h1 id=\"Spring-AOP\"><a href=\"#Spring-AOP\" class=\"headerlink\" title=\"Spring AOP\"></a>Spring AOP</h1><p>AOP是一种理论, Spring AOP是针对Spring框架落地的一种AOP实现. Spring的设计哲学是简单而强大, 用20%的AOP的支持来满足80%的场景.</p>\n<h2 id=\"动态代理与CGLIB-基于ASM\"><a href=\"#动态代理与CGLIB-基于ASM\" class=\"headerlink\" title=\"动态代理与CGLIB(基于ASM)\"></a>动态代理与CGLIB(基于ASM)</h2><p> 动态代理, 这里不再赘述, 在博客里有专门剖析.<br> 结合Spring AOP来说, 动态代理实现InvocationHandler的类是我们实现横切逻辑的地方, 它是横切逻辑的载体, 作用和Advice是一样的. 这就理解了Advice是什么了.<br> 动态代理虽好, 但是不能满足所有需求. 因为动态代理机制只能对实现了相应Interface的类使用, 如果某个类没有实现任何Interface, 就无法使用动态代理机制为其生成相应的动态代理对象.</p>\n<p> 使用动态字节码生成技术扩展对象行为的原理是, 我们可以对目标对象进行继承扩展, 为其生成相应的子类, 而子类可以通过重写来扩展父类的行为, 只要将横切逻辑放的实现放到子类中, 然后让系统使用扩展后的目标对象的子类, 就可以达到相同的目的了. CGLIB可以对实现了某种接口的类, 或者没有实现任何接口的类都可以进行扩展.<br> 通常我们会直接使用<code>net.sf.cglib.proxy.MethodInterceptor</code>接口(扩展了net.sf.cglib.proxy.Callback接口):<br> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Requestable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;OK&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RequestCtrlInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">MethodInterceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Log logger = LogFactory.getLog(RequestCtrlInterceptor.class);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">intercept</span><span class=\"params\">(Object object, Method method, Object[] args, MethodProxy proxy)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(method.getName().equals(<span class=\"string\">&quot;request&quot;</span>)) &#123;</span><br><span class=\"line\">           TimeOfDay startTime = <span class=\"keyword\">new</span> TiemOfDay(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">           TimeOfDay endTime = <span class=\"keyword\">new</span> TiemOfDay(<span class=\"number\">5</span>, <span class=\"number\">59</span>, <span class=\"number\">59</span>);</span><br><span class=\"line\">           TiemOfDay currentTime = <span class=\"keyword\">new</span> TimeDay();</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(currentTime.isAfter(startTime) &amp;&amp; currentTime.isBefore(endTime)) &#123;</span><br><span class=\"line\">               logger.warn(<span class=\"string\">&quot;Service is not available now.&quot;</span>);</span><br><span class=\"line\">               <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> proxy.invokeSuper(object, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br> 这样, RequestCtrlInterceptor就实现了对request()方法请求进行访问控制的逻辑. 现在我们要通过CGLIB的Enhance类为目标动态生成一个类, 并将RequestCtrlInterceptor中的横切逻辑附加到该子类中, 代码如下:<br> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Enhancer enhancer = <span class=\"keyword\">new</span> Enhancer();</span><br><span class=\"line\">enhancer.setSuperclass(Requestable.class);</span><br><span class=\"line\">enhancer.setCallback(<span class=\"keyword\">new</span> RequestCtrlInterceptor());</span><br><span class=\"line\"></span><br><span class=\"line\">Requestable proxy = (Requestable) enhancer.create();</span><br><span class=\"line\">proxy.request();</span><br></pre></td></tr></table></figure><br> 这里是使用Enhancer来演示在对象中加入横切逻辑, 在后续的内容中我们将会使用经过封装的更高级的Spring AOP工具, Advisor</p>\n<h1 id=\"Spring-AOP-1\"><a href=\"#Spring-AOP-1\" class=\"headerlink\" title=\"Spring AOP\"></a>Spring AOP</h1><p>对于Joinpoint, Spring AOP仅支持方法级别的Joinpoint, 更确切的说, 仅支持方法执行(Method Execution)类型的Joinpoint, 原因有以下几点:</p>\n<ul>\n<li>Spring AOP设计理念是简单而强大</li>\n<li>对于类属性Field级别的Joinpoint, 完全可以使用getter/setter方法的拦截来达到同样的目的</li>\n<li>如果要求十分特殊, 借助AspectJ即可(当然即使是AspectJ这样支持很多Joinpoint类型的AOP实现产品, 也无法保证能捕捉到程序流程中的任何一个点)</li>\n</ul>\n<p>对于Pointcut, Spring AOP提供了org.springframework.aop.Pointcut接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Pointcut</span> </span>&#123;</span><br><span class=\"line\">    ClassFilter getClassFilter;</span><br><span class=\"line\">    MethodMatcher getMethodMatcher;</span><br><span class=\"line\">    Pointcut TRUE = TruePointcut.INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>见名知意, 不是重点, 不再赘述</p>\n<p>对于Advice, Advice是实现了将织入到Pointcut规定的Joinpoint处的横切逻辑. Advice的几种类型, 重点介绍Around Advice.<br>Srping中没有直接定义Around Advice的实现接口, 而是采用AOP Alliance的标准接口, 即: <code>org.aopalliance.intercept.MethodInterceptor</code>, 该接口定义如下: </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.aopalliance.intercept;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Intercepts calls on an interface on its way to the target. These</span></span><br><span class=\"line\"><span class=\"comment\"> * are nested &quot;on top&quot; of the target.</span></span><br><span class=\"line\"><span class=\"comment\"> * ...</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MethodInterceptor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Interceptor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Implement this method to perform extra treatments before and</span></span><br><span class=\"line\"><span class=\"comment\">\t * after the invocation. Polite implementations would certainly</span></span><br><span class=\"line\"><span class=\"comment\">\t * like to invoke &#123;<span class=\"doctag\">@link</span> Joinpoint#proceed()&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> invocation the method invocation joinpoint</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the result of the call to &#123;<span class=\"doctag\">@link</span> Joinpoint#proceed()&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">\t * might be intercepted by the interceptor</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@throws</span> Throwable if the interceptors or the target object</span></span><br><span class=\"line\"><span class=\"comment\">\t * throws an exception</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\">Object <span class=\"title\">invoke</span><span class=\"params\">(MethodInvocation invocation)</span> <span class=\"keyword\">throws</span> Throwable</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其他的Advice能做到的事情, 它都可以做, 或者说Around Advice可以应用的场景很多, 例如: 系统安全检查/系统各处性能检测/日志记录/系统附件行为的添加等.</p>\n<p>接下来是一个场景: 销售系统, 在商场优惠期间, 所有的商品一律8折, 那么我们在系统中所有取得商品价格的地方插入如下横切逻辑.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DiscountMethodInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">MethodInterceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Integer DEFAULT_DISCOUNT_RATIO = <span class=\"number\">80</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span> <span class=\"params\">(MethodInvocation invocation)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        Object returnValue = invocation.proceed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((Integer) returnValue) * DEFAULT_DISCOUNT_RATIO / <span class=\"number\">100</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>通过MethodInvocation的invoke方法的MethodInvocation参数, 我们可以控制相应的Joinpoint的拦截行为. 通过调用MethodInvocation的proceed()方法, 可以让程序执行继续沿着调用链传播, 这是我们所希望的行为. 如果我们在哪一个MethodInterceptor中没有调用proceed(),那么程序的执行将会在MethodInterceptor处”短路”.</p>\n</blockquote>\n<p>我们使用了Spring框架, 并且这些Advice实现都是普通的POJO, 更多时候, 会直接将其集成到IoC容器中, 如下所示:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;discountInterceptor&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;...DiscountMethodInterceptor&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>当我定义了多个MethodInterceptor时, 他们是如何执行呢?这就要用到**<a href=\"/2021/11/02/java-chain-of-responsibility/\" title=\"责任链模式\">责任链模式</a>**</p>\n<h1 id=\"SpringAOP的织入\"><a href=\"#SpringAOP的织入\" class=\"headerlink\" title=\"SpringAOP的织入\"></a>SpringAOP的织入</h1><p>AspectJ使用ajc编译器作为它的织入器, 在SpringAOP中使用<code>org.springframework.aop.ProxyFactory</code>, 在Spring AOP中这是最基本的织入器.</p>\n<p>总的思路是: <strong>Spring AIO是基于代理模式的AOP实现, 织入完成后, 会返回织入横切逻辑的代理对象</strong>. 也就是说ProxyFactory返回织入了横切逻辑的代理对象.</p>\n<p>使用ProxyFactory需要两个基本的东西, 一个是传入进行织入的目标对象, 一个是将要应用到目标对象的Aspect(在Spring中叫做Advisor). 指定对应的Advisor, 就可以添加各种类型的Advice, 比如伪代码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ProxyFactory weaver = <span class=\"keyword\">new</span> ProxyFactory(<span class=\"keyword\">new</span> Executable());</span><br><span class=\"line\">NameMatchMethodPointcutAdvisor advisor = <span class=\"keyword\">new</span> NameMathMethodPointcutAdvisor();</span><br><span class=\"line\">advisor.setMappedName(<span class=\"string\">&quot;request&quot;</span>);</span><br><span class=\"line\">advisor.setAdvice(<span class=\"keyword\">new</span> RequestCtrlInterceptor());</span><br><span class=\"line\">weaver.addAdvisor(advisor);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\">weaver.setProxyTargetClass(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Requestable proxyObject = (Requestable) weaver.getProxy();</span><br><span class=\"line\">proxyObject.request();</span><br><span class=\"line\">System.out.println(proxyObject.getClass());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// out</span></span><br><span class=\"line\"><span class=\"comment\">// class ...Requestable$$EnhancerByCGLIB$$9e62fc83</span></span><br><span class=\"line\"><span class=\"comment\">// 从输出中可以看出ProxyFactory底层还是使用了之前的Enhancer, 也可以看出通过CGLIB得到的类的命名方式与动态代理的方式不太一样, 动态代理是&quot;$Proxy0&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们知道Spring AOP在使用代理模式实现AOP的过程中采用了动态代理和CGLIB两种机制, 分别对实现了某些接口的目标类和没有实现任何接口的目标类进行代理. 当目标类没有实现任何接口时, 默认使用动态代理, 但是这里设置了<code>proxyTargetClass</code>的属性为<code>true</code>, 强制其采用基于类的代理, 即使目标类确实是基于接口的.</p>\n<h2 id=\"探索ProxyFactory本质\"><a href=\"#探索ProxyFactory本质\" class=\"headerlink\" title=\"探索ProxyFactory本质\"></a>探索ProxyFactory本质</h2><p>先来看一下类之间的关系</p>\n<img  src=http://www.plantuml.com/plantuml/svg/RO_12i8m44Jl-OezwgK7Zo92KKH5KF0BrissH6ksfAjOr7_NAbLRcrCoCzbv6zkpAzXkJtakGM4KHH1BlWboAMT8Ag4S0X99iCwde6ASLmu94hTpS3NmFBKA51YLwsSlRXQH-CIbVNCtxJ6ZsvDXoWcUCcrvfWf_Sbsexz8cP9DllTipAQIiRwv-fph9i2XMWfO3qFTUyJOOAjQbFKnBZqT7hx_6j0I8ejiO5luiXEh4pz7RZCCFv9y7ruwUIPgvtQ1UsJm0>\n\n<p>其中AopProxy有Cglib2AopProxy和JdkDynamicProxy两种实现. 因为动态代理需要通过InvocationHandler提供调用拦截, 所以JdkDynamicProxy同时也要实现InvocationHandler接口.</p>\n<p>AopProxy实例化代理对象的过程采用了抽象工厂模式进行封装, 即通过AopProxyFactory进行.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AopProxyFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Create an &#123;<span class=\"doctag\">@link</span> AopProxy&#125; for the given AOP configuration.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> config the AOP configuration in the form of an</span></span><br><span class=\"line\"><span class=\"comment\">\t * AdvisedSupport object</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the corresponding AOP proxy</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@throws</span> AopConfigException if the configuration is invalid</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\">AopProxy <span class=\"title\">createAopProxy</span><span class=\"params\">(AdvisedSupport config)</span> <span class=\"keyword\">throws</span> AopConfigException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>AopProxyFactory的实现类只有一个, 就是DefaultAopProxyFactory, 在DefaultAopProxyFactory会经过一个判断来决定使用Cglib还是动态代理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(config.isOptimize || config.isProxyTargetClass() || ...) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建Cglib2AopProxy实例, 返回</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建JdkDynamicAopProxy实例, 返回</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以下内容定格在177页, 关于AOP的剩余内容以后在补充.</p>\n<p>一个类如果不声明, 默认的构造方法, 那么他到底有没有默认的构造方法? 没有<br>一个类声明了默认的构造方法, 但是没有写访问控制符, 那么这个访问控制符是什么?<br>一个类声明了默认的构造方法, 但是没有写访问控制符, 为什么通过Class.forName(…).getConstructor()会抛出NoSuchMethodException?</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"AOP概念\"><a href=\"#AOP概念\" class=\"headerlink\" title=\"AOP概念\"></a>AOP概念</h1><p>对于系统中普遍的业务关注点, OOP可以很好地对其进行分解并使之模块化, 但是却无法更好地避免类似于系统需求的实现在系统中各处散落这样的问题. 所以, 我们要寻求一种更好的办法在OOP的基础上更上一层楼. 我们可以推翻OOP的概念提出一套全新的思路, 但是也可以在此基础上提供一种补足方案. 后来我们找到了AOP.</p>\n<ul>\n<li>静态AOP, 第一代AOP, 以AspectJ为代表. 特点是, 相应的很切关注点以Aspect形式实现之后, 会通过特定的编译器, 将实现后的Aspect编译并织入到系统的静态类中. 比如, AspectJ会使用ajc编译器将各个Aspect以Java字节码的形式编译到Java类中, Java虚拟机可以像通常一样加载Java类运行.</li>\n<li>动态AOP, 第二代AOP, 通过Java语言的动态特性来实现Aspect织入到系统的过程, 比如Spring AOP.</li>\n</ul>\n<h3 id=\"Joinpoint\"><a href=\"#Joinpoint\" class=\"headerlink\" title=\"Joinpoint\"></a>Joinpoint</h3><p> 首先我们需要知道在哪些执行点上进行织入操作, 这些将要在其之上进行织入操作的系统执行点, 称之为Joinpoint. 比如, 方法调用时, 执行时, 字段设置时, 异常处理时, 类初始化时等等.</p>\n<h3 id=\"Pointcut\"><a href=\"#Pointcut\" class=\"headerlink\" title=\"Pointcut\"></a>Pointcut</h3><p> 接下来需要知道在什么地方(Joinpoint)织入横切逻辑. 比如, 指定Joinpoint所在方法的名称, 或者利用正则表达式表述出所有符合条件的多组Joinpoint.</p>\n<h3 id=\"Advice\"><a href=\"#Advice\" class=\"headerlink\" title=\"Advice\"></a>Advice</h3><p> 逻辑载体, 即织入到Joinpoint的横切逻辑. 它分为几种形式:</p>\n<ul>\n<li>Before Advice, 在Joinpoint位置之前执行的Advice类型</li>\n<li>After Advice, 在Joinpoint位置之后, 包括After returning Advice, Afterthrowing Advice等</li>\n<li>Around Advice, 这里应该叫做拦截器比较好, Interceptor. 它也可以完成Before Advice和After Advice的功能.</li>\n<li>Introduction<h3 id=\"Aspect\"><a href=\"#Aspect\" class=\"headerlink\" title=\"Aspect\"></a>Aspect</h3>Aspect是对以上三者进行封装的AOP概念.</li>\n</ul>\n<h1 id=\"Spring-AOP\"><a href=\"#Spring-AOP\" class=\"headerlink\" title=\"Spring AOP\"></a>Spring AOP</h1><p>AOP是一种理论, Spring AOP是针对Spring框架落地的一种AOP实现. Spring的设计哲学是简单而强大, 用20%的AOP的支持来满足80%的场景.</p>\n<h2 id=\"动态代理与CGLIB-基于ASM\"><a href=\"#动态代理与CGLIB-基于ASM\" class=\"headerlink\" title=\"动态代理与CGLIB(基于ASM)\"></a>动态代理与CGLIB(基于ASM)</h2><p> 动态代理, 这里不再赘述, 在博客里有专门剖析.<br> 结合Spring AOP来说, 动态代理实现InvocationHandler的类是我们实现横切逻辑的地方, 它是横切逻辑的载体, 作用和Advice是一样的. 这就理解了Advice是什么了.<br> 动态代理虽好, 但是不能满足所有需求. 因为动态代理机制只能对实现了相应Interface的类使用, 如果某个类没有实现任何Interface, 就无法使用动态代理机制为其生成相应的动态代理对象.</p>\n<p> 使用动态字节码生成技术扩展对象行为的原理是, 我们可以对目标对象进行继承扩展, 为其生成相应的子类, 而子类可以通过重写来扩展父类的行为, 只要将横切逻辑放的实现放到子类中, 然后让系统使用扩展后的目标对象的子类, 就可以达到相同的目的了. CGLIB可以对实现了某种接口的类, 或者没有实现任何接口的类都可以进行扩展.<br> 通常我们会直接使用<code>net.sf.cglib.proxy.MethodInterceptor</code>接口(扩展了net.sf.cglib.proxy.Callback接口):<br> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Requestable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;OK&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RequestCtrlInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">MethodInterceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Log logger = LogFactory.getLog(RequestCtrlInterceptor.class);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">intercept</span><span class=\"params\">(Object object, Method method, Object[] args, MethodProxy proxy)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(method.getName().equals(<span class=\"string\">&quot;request&quot;</span>)) &#123;</span><br><span class=\"line\">           TimeOfDay startTime = <span class=\"keyword\">new</span> TiemOfDay(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">           TimeOfDay endTime = <span class=\"keyword\">new</span> TiemOfDay(<span class=\"number\">5</span>, <span class=\"number\">59</span>, <span class=\"number\">59</span>);</span><br><span class=\"line\">           TiemOfDay currentTime = <span class=\"keyword\">new</span> TimeDay();</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(currentTime.isAfter(startTime) &amp;&amp; currentTime.isBefore(endTime)) &#123;</span><br><span class=\"line\">               logger.warn(<span class=\"string\">&quot;Service is not available now.&quot;</span>);</span><br><span class=\"line\">               <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> proxy.invokeSuper(object, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br> 这样, RequestCtrlInterceptor就实现了对request()方法请求进行访问控制的逻辑. 现在我们要通过CGLIB的Enhance类为目标动态生成一个类, 并将RequestCtrlInterceptor中的横切逻辑附加到该子类中, 代码如下:<br> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Enhancer enhancer = <span class=\"keyword\">new</span> Enhancer();</span><br><span class=\"line\">enhancer.setSuperclass(Requestable.class);</span><br><span class=\"line\">enhancer.setCallback(<span class=\"keyword\">new</span> RequestCtrlInterceptor());</span><br><span class=\"line\"></span><br><span class=\"line\">Requestable proxy = (Requestable) enhancer.create();</span><br><span class=\"line\">proxy.request();</span><br></pre></td></tr></table></figure><br> 这里是使用Enhancer来演示在对象中加入横切逻辑, 在后续的内容中我们将会使用经过封装的更高级的Spring AOP工具, Advisor</p>\n<h1 id=\"Spring-AOP-1\"><a href=\"#Spring-AOP-1\" class=\"headerlink\" title=\"Spring AOP\"></a>Spring AOP</h1><p>对于Joinpoint, Spring AOP仅支持方法级别的Joinpoint, 更确切的说, 仅支持方法执行(Method Execution)类型的Joinpoint, 原因有以下几点:</p>\n<ul>\n<li>Spring AOP设计理念是简单而强大</li>\n<li>对于类属性Field级别的Joinpoint, 完全可以使用getter/setter方法的拦截来达到同样的目的</li>\n<li>如果要求十分特殊, 借助AspectJ即可(当然即使是AspectJ这样支持很多Joinpoint类型的AOP实现产品, 也无法保证能捕捉到程序流程中的任何一个点)</li>\n</ul>\n<p>对于Pointcut, Spring AOP提供了org.springframework.aop.Pointcut接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Pointcut</span> </span>&#123;</span><br><span class=\"line\">    ClassFilter getClassFilter;</span><br><span class=\"line\">    MethodMatcher getMethodMatcher;</span><br><span class=\"line\">    Pointcut TRUE = TruePointcut.INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>见名知意, 不是重点, 不再赘述</p>\n<p>对于Advice, Advice是实现了将织入到Pointcut规定的Joinpoint处的横切逻辑. Advice的几种类型, 重点介绍Around Advice.<br>Srping中没有直接定义Around Advice的实现接口, 而是采用AOP Alliance的标准接口, 即: <code>org.aopalliance.intercept.MethodInterceptor</code>, 该接口定义如下: </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.aopalliance.intercept;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Intercepts calls on an interface on its way to the target. These</span></span><br><span class=\"line\"><span class=\"comment\"> * are nested &quot;on top&quot; of the target.</span></span><br><span class=\"line\"><span class=\"comment\"> * ...</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MethodInterceptor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Interceptor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Implement this method to perform extra treatments before and</span></span><br><span class=\"line\"><span class=\"comment\">\t * after the invocation. Polite implementations would certainly</span></span><br><span class=\"line\"><span class=\"comment\">\t * like to invoke &#123;<span class=\"doctag\">@link</span> Joinpoint#proceed()&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> invocation the method invocation joinpoint</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the result of the call to &#123;<span class=\"doctag\">@link</span> Joinpoint#proceed()&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">\t * might be intercepted by the interceptor</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@throws</span> Throwable if the interceptors or the target object</span></span><br><span class=\"line\"><span class=\"comment\">\t * throws an exception</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\">Object <span class=\"title\">invoke</span><span class=\"params\">(MethodInvocation invocation)</span> <span class=\"keyword\">throws</span> Throwable</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其他的Advice能做到的事情, 它都可以做, 或者说Around Advice可以应用的场景很多, 例如: 系统安全检查/系统各处性能检测/日志记录/系统附件行为的添加等.</p>\n<p>接下来是一个场景: 销售系统, 在商场优惠期间, 所有的商品一律8折, 那么我们在系统中所有取得商品价格的地方插入如下横切逻辑.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DiscountMethodInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">MethodInterceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Integer DEFAULT_DISCOUNT_RATIO = <span class=\"number\">80</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span> <span class=\"params\">(MethodInvocation invocation)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        Object returnValue = invocation.proceed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((Integer) returnValue) * DEFAULT_DISCOUNT_RATIO / <span class=\"number\">100</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>通过MethodInvocation的invoke方法的MethodInvocation参数, 我们可以控制相应的Joinpoint的拦截行为. 通过调用MethodInvocation的proceed()方法, 可以让程序执行继续沿着调用链传播, 这是我们所希望的行为. 如果我们在哪一个MethodInterceptor中没有调用proceed(),那么程序的执行将会在MethodInterceptor处”短路”.</p>\n</blockquote>\n<p>我们使用了Spring框架, 并且这些Advice实现都是普通的POJO, 更多时候, 会直接将其集成到IoC容器中, 如下所示:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;discountInterceptor&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;...DiscountMethodInterceptor&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>当我定义了多个MethodInterceptor时, 他们是如何执行呢?这就要用到**<a href=\"/2021/11/02/java-chain-of-responsibility/\" title=\"责任链模式\">责任链模式</a>**</p>\n<h1 id=\"SpringAOP的织入\"><a href=\"#SpringAOP的织入\" class=\"headerlink\" title=\"SpringAOP的织入\"></a>SpringAOP的织入</h1><p>AspectJ使用ajc编译器作为它的织入器, 在SpringAOP中使用<code>org.springframework.aop.ProxyFactory</code>, 在Spring AOP中这是最基本的织入器.</p>\n<p>总的思路是: <strong>Spring AIO是基于代理模式的AOP实现, 织入完成后, 会返回织入横切逻辑的代理对象</strong>. 也就是说ProxyFactory返回织入了横切逻辑的代理对象.</p>\n<p>使用ProxyFactory需要两个基本的东西, 一个是传入进行织入的目标对象, 一个是将要应用到目标对象的Aspect(在Spring中叫做Advisor). 指定对应的Advisor, 就可以添加各种类型的Advice, 比如伪代码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ProxyFactory weaver = <span class=\"keyword\">new</span> ProxyFactory(<span class=\"keyword\">new</span> Executable());</span><br><span class=\"line\">NameMatchMethodPointcutAdvisor advisor = <span class=\"keyword\">new</span> NameMathMethodPointcutAdvisor();</span><br><span class=\"line\">advisor.setMappedName(<span class=\"string\">&quot;request&quot;</span>);</span><br><span class=\"line\">advisor.setAdvice(<span class=\"keyword\">new</span> RequestCtrlInterceptor());</span><br><span class=\"line\">weaver.addAdvisor(advisor);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\">weaver.setProxyTargetClass(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Requestable proxyObject = (Requestable) weaver.getProxy();</span><br><span class=\"line\">proxyObject.request();</span><br><span class=\"line\">System.out.println(proxyObject.getClass());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// out</span></span><br><span class=\"line\"><span class=\"comment\">// class ...Requestable$$EnhancerByCGLIB$$9e62fc83</span></span><br><span class=\"line\"><span class=\"comment\">// 从输出中可以看出ProxyFactory底层还是使用了之前的Enhancer, 也可以看出通过CGLIB得到的类的命名方式与动态代理的方式不太一样, 动态代理是&quot;$Proxy0&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们知道Spring AOP在使用代理模式实现AOP的过程中采用了动态代理和CGLIB两种机制, 分别对实现了某些接口的目标类和没有实现任何接口的目标类进行代理. 当目标类没有实现任何接口时, 默认使用动态代理, 但是这里设置了<code>proxyTargetClass</code>的属性为<code>true</code>, 强制其采用基于类的代理, 即使目标类确实是基于接口的.</p>\n<h2 id=\"探索ProxyFactory本质\"><a href=\"#探索ProxyFactory本质\" class=\"headerlink\" title=\"探索ProxyFactory本质\"></a>探索ProxyFactory本质</h2><p>先来看一下类之间的关系</p>\n<img  src=http://www.plantuml.com/plantuml/svg/RO_12i8m44Jl-OezwgK7Zo92KKH5KF0BrissH6ksfAjOr7_NAbLRcrCoCzbv6zkpAzXkJtakGM4KHH1BlWboAMT8Ag4S0X99iCwde6ASLmu94hTpS3NmFBKA51YLwsSlRXQH-CIbVNCtxJ6ZsvDXoWcUCcrvfWf_Sbsexz8cP9DllTipAQIiRwv-fph9i2XMWfO3qFTUyJOOAjQbFKnBZqT7hx_6j0I8ejiO5luiXEh4pz7RZCCFv9y7ruwUIPgvtQ1UsJm0>\n\n<p>其中AopProxy有Cglib2AopProxy和JdkDynamicProxy两种实现. 因为动态代理需要通过InvocationHandler提供调用拦截, 所以JdkDynamicProxy同时也要实现InvocationHandler接口.</p>\n<p>AopProxy实例化代理对象的过程采用了抽象工厂模式进行封装, 即通过AopProxyFactory进行.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AopProxyFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Create an &#123;<span class=\"doctag\">@link</span> AopProxy&#125; for the given AOP configuration.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> config the AOP configuration in the form of an</span></span><br><span class=\"line\"><span class=\"comment\">\t * AdvisedSupport object</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the corresponding AOP proxy</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@throws</span> AopConfigException if the configuration is invalid</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\">AopProxy <span class=\"title\">createAopProxy</span><span class=\"params\">(AdvisedSupport config)</span> <span class=\"keyword\">throws</span> AopConfigException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>AopProxyFactory的实现类只有一个, 就是DefaultAopProxyFactory, 在DefaultAopProxyFactory会经过一个判断来决定使用Cglib还是动态代理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(config.isOptimize || config.isProxyTargetClass() || ...) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建Cglib2AopProxy实例, 返回</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建JdkDynamicAopProxy实例, 返回</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以下内容定格在177页, 关于AOP的剩余内容以后在补充.</p>\n<p>一个类如果不声明, 默认的构造方法, 那么他到底有没有默认的构造方法? 没有<br>一个类声明了默认的构造方法, 但是没有写访问控制符, 那么这个访问控制符是什么?<br>一个类声明了默认的构造方法, 但是没有写访问控制符, 为什么通过Class.forName(…).getConstructor()会抛出NoSuchMethodException?</p>\n"},{"title":"Spring Boot自动装配原理","date":"2021-11-01T01:54:27.000Z","_content":"\nSpring Framework’s @Conditional annotation is the core of Autoconfigurations.\n事实上, 自动装配是基于标准的@Configuration类来实现的. @Conditional一系列注解用来限制自动装配的实施. 通常情况下, 自动装配的类使用@ConditionalOnClass和@ConditionalOnMissingBean注解. 这确保了自动装配类的实施, 是在当相关类被找到, 并且没有声明你自己的@Configuration的时候.\n\n# 自动装配出现的背景\n想象你在一个超级大公司里, 这个公司里有很多使用纯Spring Framework的项目, 大家的配置文件中有80%都是一样的. 这时, 你想到了是不是可以提取出一个共同的ApplicationContextConfiguration, 因为大家的有很多Bean是一样的.\n```java\n@Configuration\npublic class SharedContextConfiguration { // (1)\n\n    @Bean\n    public Driver neo4jDriver(Neo4jProperties properties, ...) {\n        return GraphDatabase.driver(...);\n    }\n\n}\n```\n\n你可以将此SharedConfiguration项目, 打包发布公司maven仓库的一个依赖. 其他项目可以在自己的@Configuration类上再加上一个注解@Import(...Configuration.class)\n```java\n@Configuration\n@Import(SharedConfiguration.class) // (1)\npublic class OtherProjectContextConfiguration {\n\n   // you would specify your project-specific beans here, as normal.\n}\n```\n\n以上方式看起来很好但是却存在一些问题:\n如果SharedConfiguration中配置了某些Bean, 比如Neo4jBean, 在其他项目中是不需要的, 那么我是否可以排除这些Bean呢?\n\n这就引出了@Conditional注解.\n\n# 自动装配核心注解@Conditional\n@Conditional\"系列注解\"可以用在@Bean Method, @Components或者其他@Configuration注解上. 它们的作用范围都是`@Target({ElementType.TYPE,ElementType.METHOD})`, 比如@ConditionalOnClass, @ConditionalOnBean, @ConditionalOnMissBean等.\n```java\n@Target({ ElementType.TYPE, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Conditional(OnClassCondition.class)\npublic @interface ConditionalOnClass {\n\n\t/**\n\t * The classes that must be present. Since this annotation is parsed by loading class\n\t * bytecode, it is safe to specify classes here that may ultimately not be on the\n\t * classpath, only if this annotation is directly on the affected component and\n\t * <b>not</b> if this annotation is used as a composed, meta-annotation. In order to\n\t * use this annotation as a meta-annotation, only use the {@link #name} attribute.\n\t * @return the classes that must be present\n\t */\n\tClass<?>[] value() default {};\n\n\t/**\n\t * The classes names that must be present.\n\t * @return the class names that must be present.\n\t */\n\tString[] name() default {};\n\n}\n```\n这些注解需要@Conditional的加持(注解不支持继承, 只能通过组合的方式), @Conditional有一个\"Condition\"类的参数, 这个类中必须有一个方法叫matches(继承父类SpringBootCondition得此方法), 并返回一个Boolean值\n - True: (Further Evaluate/Register) Create that @Bean, @Component or @Configuration\n - False: (Stop Evaluating/Registering) Don’t create that @Bean, @Component or @Configuration\n关系如下:\n{% plantuml %}\n    FilteringSpringBootCondition <|-- OnClassCondition\n    SpringBootCondition <|-- FilteringSpringBootCondition\n    Condition <|.. SpringBootCondition\n    interface Condition {\n        boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata);\n    }\n{% endplantuml %}\n\n附上Condition接口源码:\n```java\n\n/**\n * A single {@code condition} that must be {@linkplain #matches matched} in order\n * for a component to be registered.\n *\n * <p>Conditions are checked immediately before the bean-definition is due to be\n * registered and are free to veto registration based on any criteria that can\n * be determined at that point.\n *\n * <p>Conditions must follow the same restrictions as {@link BeanFactoryPostProcessor}\n * and take care to never interact with bean instances. For more fine-grained control\n * of conditions that interact with {@code @Configuration} beans consider implementing\n * the {@link ConfigurationCondition} interface.\n *\n * @author Phillip Webb\n * @since 4.0\n * @see ConfigurationCondition\n * @see Conditional\n * @see ConditionContext\n */\n@FunctionalInterface\npublic interface Condition {\n\n\t/**\n\t * Determine if the condition matches.\n\t * @param context the condition context\n\t * @param metadata the metadata of the {@link org.springframework.core.type.AnnotationMetadata class}\n\t * or {@link org.springframework.core.type.MethodMetadata method} being checked\n\t * @return {@code true} if the condition matches and the component can be registered,\n\t * or {@code false} to veto the annotated component's registration\n\t */\n\tboolean matches(ConditionContext context, AnnotatedTypeMetadata metadata);\n\n}\n```\n\n总结一下其中的逻辑:\n{% blockquote %}\nIn short: Even though an ApplicationContextConfiguration comes with certain @Bean definitions, you as the end-user can still somewhat influence if a bean gets created or not.\n{% endblockquote %}\n即使每个ApplicationContextConfiguration都是来自某个@Bean的定义, 但是你最为最终使用者依然拥有对Bean的创建与否的决定权.\n\n\n## 使用@Conditional再次改造\n制造出新的ApplicationContextConfiguration\n```java\n@Configuration\npublic class SharedConfiguration {\n    @Bean\n    @Conditional(IsRequiredNeo4jDatabaseCondition.class)\n    public Driver neo4jDriver(Neo4jProperties properties, ...) {\n        return GraphDatabase.driver(...);\n    }\n}\n```\n实现Condition接口:\n```java\nimport org.springframework.context.annotation.Condition;\nimport org.springframework.context.annotation.ConditionContext;\nimport org.springframework.core.type.AnnotatedTypeMetadata;\n\npublic class IsRequiredNeo4jDatabaseCondition implements Condition {\n    @Override\n    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata){\n        return neo4jDriverOnClassPath() && databaseUrlSet(context); // [1]\n    }\n    private boolean databaseUrlSet(ConditioContext context) {\n        return context.getEnvironment().containsPreperty(\"spring.data.neo4j.uri\");\n    }\n    private boolean neo4jDriverOnClassPath() {\n        try {\n            Class.forName(\"org.neo4j.driver.Driver\");\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n}\n```\n[1]这里构造了两个条件来实施判断, 一个是检测properties中是否拥有某个配置项, 一个是检测是否引入了neo4jDriver对应的依赖(通过在classpath找寻对应的类是否存在即可).\n> 注意: 真是情况下的Neo4j配置与以上做法略有不同.\n\n那么以上两种match方式对应着两个最重要的Condition:\n - create @Beans depending on specific **available properties**.\n - create @Beans depending on specific **libraries on your classpath**.\n\n至此, 我们会有这样的疑问,\n - Conditionals that create a DataSource for you, because you have set specific properties (think: spring.data.neo4j.uri)? \n - Or @Conditionals that boot up an embedded Tomcat server for you because you have the Tomcat libraries on your classpath?\nThe Answer is YES, that (and not much more) is exactly what Spring Boot is. \n\n# Spring Boot Autoconfigurations: Three Internal Core Features\n## 定位PropertySources\nSpring Boot获取配置参数有一个顺序, 这个顺序是特殊的:\n{% blockquote Spring Boot docs%}\n1. Default properties (specified by setting SpringApplication.setDefaultProperties).\n2. `@PropertySource` annotations on your @Configuration classes. Please note that such property sources are not added to the Environment until the application context is being refreshed. This is too late to configure certain properties such as logging.* and spring.main.* which are read before refresh begins.\n3. Config data (such as application.properties files)\n4. A RandomValuePropertySource that has properties only in random.*.\n5. OS environment variables.\n6. Java System properties (System.getProperties()).\n7. JNDI attributes from java:comp/env.\n8. ServletContext init parameters.\n9. ServletConfig init parameters.\n10. Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property).\n11. Command line arguments.\n12. properties attribute on your tests. Available on @SpringBootTest and the test annotations for testing a particular slice of your application.\n13. @TestPropertySource annotations on your tests.\n14. Devtools global settings properties in the $HOME/.config/spring-boot directory when devtools is active.\n{% endblockquote %}\n以上这些就是Spring Boot启动时, 默认读取Property的位置和顺序.\n\n其中, 注解`@PropertySource`需要注意, 通过注解`@PropertySource`来定位配置文件`.properties`\n```java\n@PropertySource(value = \"classpath:application.properties\", ignoreResourceNotFound = true)\n```\n当你运行SpringBoot启动类的main方法, SpringBoot将会自动按顺序读取这14个PropertySource(低版本的可能是17个, 当前版本是2.5.6), 为的是将这些配置注入到项目中.\n\n> 提示: Spring Boot将配置的值注入bean的属性有两种办法\n> 1. @Value\n> 2. @ConfigurationProperties\n\n\n## Read-in META-INF/spring.factories\n每个SpringBoot项目都有一个共同的依赖, 就是`org.springframework.boot:spring-boot-autoconfigure`, 这个jar包包含了所有自动配置的magic. 其核心就是`META-INF/spring.factories`文件.\n```\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\norg.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\\n// ...\n// 100+ more lines\n```\n截取其中一段如上所示, EnableAutoConfiguration的值, 有100多个. 这些类都是普通的@Configurations并且有些有@Conditionals, Spring Boot读取这些类并对其Condition进行评估执行.\n\n## Enhanced Conditional Support\n@Conditional是一个较底层的注解, 基于此注解, 组合出了很多\"增强型\"的注解, 比如:\n - @ConditionalOnClass(DataSource.class). The condition is true if the DataSource class is on the classpath.\n - @ConditionalOnMissingClass(DataSource.class). The condition is true if the DataSource class is not on the classpath.\n - @ConditionalOnMissingBean(DataSource.class). The condition is true if the user did not specify a DataSource @Bean in any @Configuration.\n - @ConditionalOnWebApplication. The condition is true if the application is a web application.\n - @ConditionalOnProperty(\"my.property\"). The condition is true if my.property is set.\n - @ConditionalOnResource(\"classpath:my.properties\"). The condition is true if my.properties exists.\n - // e.g.\n大多数情况下, 都是用增强型注解更为方便.\n\n@Conditional增强型的注解大概分为以下几种:\n - Class Conditions\n - Bean Conditions\n - Property Conditions\n - Resource Conditions\n - Web Application Conditions\n - SpEL Expression Conditions\n\n### Class Conditions\n@ConditionalOnClass或者@ConditionalOnMissingClass, 通过判断指定的class在或者不在classpath中来, 判断Bean的创建与否. \n> **The fact is that annotation metadata is parsed by using ASM.**\nConditional注解一般有两个参数, `value`和`name`, 你可以通过`value`传真实的class参数, 即使这个类并没有出现在application classpath中.\n\n### Bean Conditions\nConditional @Conditional that only matches when no beans meeting the specified\nrequirements are already contained in the `BeanFactory`.\n\nWhen placed on a `@Bean` method, the bean class defaults to the return type of\nthe factory method:\n```java\n@Configuration\npublic class MyAutoConfiguration {\n    @Bean\n    @ConditionalOnMissingBean\n    // @ConditionalOnMissingBean没有传参数, 默认是此method的返回值类型, 同: @ConditionalOnMissingBean(MyService.class)\n    public MyService myService() {\n        ...\n    }\n}\n```\nIn the sample above the condition will match if no bean of type {@code MyService} is\nalready contained in the {@link BeanFactory}.\n\n#### Property Conditions...等不再讨论\n\n\n## AutoConfiguration测试\n```java\npublic class MyService {\n\n  private String name;\n\n  public MyService(String name) {\n    this.name = name;\n  }\n\n  public MyService() {}\n\n  public String getName() {\n    return this.name;\n  }\n}\n```\n\n```java\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration(proxyBeanMethods = false)\npublic class MyServiceAutoConfiguration {\n\n  @Bean\n  @ConditionalOnMissingBean // equivalent to @ConditionalOnMissingBean(MyService.class)\n  public MyService myService() {\n    // When MyService(bean type) doesn't exist, this bean will create.\n    return new MyService(\"test123\");\n  }\n}\n```\n\n测试AutoConfiguration需要借助ApplicationContextRunner, ApplicationContextRunner is usually defined as field of the \"test class\" to gather the base, common configuration.\n```java\nimport com.example.multimodule.service.auto.MyService;\nimport com.example.multimodule.service.auto.MyServiceAutoConfiguration;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.autoconfigure.AutoConfigurations;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.boot.test.context.runner.ApplicationContextRunner;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@SpringBootTest\npublic class TestAutoConfiguration {\n  // load MyServiceAutoConfiguration.class\n  private final ApplicationContextRunner contextRunner =\n      new ApplicationContextRunner()\n          .withConfiguration(AutoConfigurations.of(MyServiceAutoConfiguration.class));\n\n  @Configuration(proxyBeanMethods = false)\n  static class UserConfiguration {\n    @Bean\n    MyService myCustomService() {\n      // This bean is always created.\n      return new MyService(\"mine\");\n    }\n  }\n\n  @Test\n  void conditionEffectedTest() {\n    // @ConditionalOnMissingBean effect\n    this.contextRunner.run(\n        (context) -> {\n          assertThat(context).getBean(\"myService\");\n          assertThat(context).hasSingleBean(MyService.class);\n          assertThat(context.getBean(MyService.class).getName()).isEqualTo(\"test123\");\n        });\n  }\n\n  @Test\n  void conditionNotEffectedTest() {\n    // @ConditionalOnMissingBean effect\n    this.contextRunner\n        .withUserConfiguration(UserConfiguration.class) // add UserConfiguration into context.\n        .run(\n            (context -> {\n              assertThat(context).hasSingleBean(MyService.class);\n              assertThat(context)\n                  .getBean(\"myCustomService\")\n                  .isSameAs(context.getBean(MyService.class));\n              assertThat(context.getBean(MyService.class).getName()).isEqualTo(\"mine\");\n            }));\n  }\n}\n```\n从以上例子中可以看出, 当仅仅ApplicationContext仅仅加载MyServiceAutoConfiguration类时, 注入的Bean是`myService`, 当MyServiceAutoConfiguration和UserConfiguration都加载是注入的Bean是`myCustomService`, 从中体现出了@ConditionalOnMissingBean的作用.\n\n更多关于Autoconfiguration相关Conditional注解的测试可以查看: https://www.baeldung.com/spring-boot-context-runner\n\n# 构建自己的starter\na custom starter can contain the following:\n\n - The autoconfigure module that contains the auto-configuration code for \"acme\".\n\n - The starter module that provides a dependency to the autoconfigure module as well as \"acme\" and any additional dependencies that are typically useful. In a nutshell, adding the starter should provide everything needed to start using that library.\n\n#### Naming\nYou should make sure to provide a proper namespace for your starter. Do not start your module names with spring-boot\n#### Configuration keys\nIf your starter provides configuration keys, use a unique namespace for them. In particular, do not include your keys in the namespaces that Spring Boot uses (such as server, management, spring, and so on). \n```java\nimport java.time.Duration;\n\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\n@ConfigurationProperties(\"acme\")\npublic class AcmeProperties {\n\n    /**\n     * Whether to check the location of acme resources.\n     */\n    private boolean checkLocation = true;\n\n    /**\n     * Timeout for establishing a connection to the acme server.\n     */\n    private Duration loginTimeout = Duration.ofSeconds(3);\n\n    public boolean isCheckLocation() {\n        return this.checkLocation;\n    }\n\n    public void setCheckLocation(boolean checkLocation) {\n        this.checkLocation = checkLocation;\n    }\n\n    public Duration getLoginTimeout() {\n        return this.loginTimeout;\n    }\n\n    public void setLoginTimeout(Duration loginTimeout) {\n        this.loginTimeout = loginTimeout;\n    }\n\n}\n```\nHere are some rules we follow internally to make sure descriptions are consistent:\n - Do not start the description by \"The\" or \"A\".\n - For boolean types, start the description with \"Whether\" or \"Enable\".\n - For collection-based types, start the description with \"Comma-separated list\"\n - Use java.time.Duration rather than long and describe the default unit if it differs from milliseconds, such as \"If a duration suffix is not specified, seconds will be used\".\n - Do not provide the default value in the description unless it has to be determined at runtime.\n\n> Make sure to trigger meta-data generation so that IDE assistance is available for your keys as well. You may want to review the generated metadata (META-INF/spring-configuration-metadata.json) to make sure your keys are properly documented. Using your own starter in a compatible IDE is also a good idea to validate that quality of the metadata.\n\n## The \"autoconfigure\" module\n The `autoconfigure` module contains everything that is necessary to get started with the library. It may also contain configuration key definitions (such as @ConfigurationProperties) and any callback interface that can be used to further customize how the components are initialized.\n\nSpring Boot uses an annotation processor to collect the conditions on auto-configurations in a metadata file (`META-INF/spring-autoconfigure-metadata.properties`). If that file is present, it is used to eagerly filter auto-configurations that do not match, which will improve startup time. It is recommended to add the following dependency in a module that contains auto-configurations:\n```gradle\ndependencies {\n    compileOnly \"org.springframework.boot:spring-boot-autoconfigure-processor\"\n}\n```\n\n## Starter module\nThe starter is really an empty jar. Its only purpose is to provide the necessary dependencies to work with the library. You can think of it as an opinionated view of what is required to get started.\n\nDo not make assumptions about the project in which your starter is added. If the library you are auto-configuring typically requires other starters, mention them as well. Providing a proper set of *default* dependencies may be hard if the number of optional dependencies is high, as you should avoid including dependencies that are unnecessary for a typical usage of the library. In other words, you should not include optional dependencies.\n\n> NOTE: Either way, your starter must reference the core Spring Boot starter (spring-boot-starter) directly or indirectly (there is no need to add it if your starter relies on another starter). If a project is created with only your custom starter, Spring Boot’s core features will be honoured by the presence of the core starter.\n\n至此, 创建自己的starter并没有完成, 以上只是记录一下spring boot相关的重要的话, 接下来将会在`E:\\SpringProjects\\PracticeProjects\\spring-boot-practice-auto-configuration`中先进行实战, 对照着`E:\\SpringProjects\\PracticeProjects\\spring-boot-master-auto-configuration`项目的git log一步一步来. 但是要替换`spring-boot-master-auto-configuration`中的`hornetq`为`redis`, 所以先进行redis的学习.\n","source":"_posts/spring-autoconfigurations.md","raw":"---\ntitle: Spring Boot自动装配原理\ndate: 2021-11-01 09:54:27\ncategories: \n- Spring\n---\n\nSpring Framework’s @Conditional annotation is the core of Autoconfigurations.\n事实上, 自动装配是基于标准的@Configuration类来实现的. @Conditional一系列注解用来限制自动装配的实施. 通常情况下, 自动装配的类使用@ConditionalOnClass和@ConditionalOnMissingBean注解. 这确保了自动装配类的实施, 是在当相关类被找到, 并且没有声明你自己的@Configuration的时候.\n\n# 自动装配出现的背景\n想象你在一个超级大公司里, 这个公司里有很多使用纯Spring Framework的项目, 大家的配置文件中有80%都是一样的. 这时, 你想到了是不是可以提取出一个共同的ApplicationContextConfiguration, 因为大家的有很多Bean是一样的.\n```java\n@Configuration\npublic class SharedContextConfiguration { // (1)\n\n    @Bean\n    public Driver neo4jDriver(Neo4jProperties properties, ...) {\n        return GraphDatabase.driver(...);\n    }\n\n}\n```\n\n你可以将此SharedConfiguration项目, 打包发布公司maven仓库的一个依赖. 其他项目可以在自己的@Configuration类上再加上一个注解@Import(...Configuration.class)\n```java\n@Configuration\n@Import(SharedConfiguration.class) // (1)\npublic class OtherProjectContextConfiguration {\n\n   // you would specify your project-specific beans here, as normal.\n}\n```\n\n以上方式看起来很好但是却存在一些问题:\n如果SharedConfiguration中配置了某些Bean, 比如Neo4jBean, 在其他项目中是不需要的, 那么我是否可以排除这些Bean呢?\n\n这就引出了@Conditional注解.\n\n# 自动装配核心注解@Conditional\n@Conditional\"系列注解\"可以用在@Bean Method, @Components或者其他@Configuration注解上. 它们的作用范围都是`@Target({ElementType.TYPE,ElementType.METHOD})`, 比如@ConditionalOnClass, @ConditionalOnBean, @ConditionalOnMissBean等.\n```java\n@Target({ ElementType.TYPE, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Conditional(OnClassCondition.class)\npublic @interface ConditionalOnClass {\n\n\t/**\n\t * The classes that must be present. Since this annotation is parsed by loading class\n\t * bytecode, it is safe to specify classes here that may ultimately not be on the\n\t * classpath, only if this annotation is directly on the affected component and\n\t * <b>not</b> if this annotation is used as a composed, meta-annotation. In order to\n\t * use this annotation as a meta-annotation, only use the {@link #name} attribute.\n\t * @return the classes that must be present\n\t */\n\tClass<?>[] value() default {};\n\n\t/**\n\t * The classes names that must be present.\n\t * @return the class names that must be present.\n\t */\n\tString[] name() default {};\n\n}\n```\n这些注解需要@Conditional的加持(注解不支持继承, 只能通过组合的方式), @Conditional有一个\"Condition\"类的参数, 这个类中必须有一个方法叫matches(继承父类SpringBootCondition得此方法), 并返回一个Boolean值\n - True: (Further Evaluate/Register) Create that @Bean, @Component or @Configuration\n - False: (Stop Evaluating/Registering) Don’t create that @Bean, @Component or @Configuration\n关系如下:\n{% plantuml %}\n    FilteringSpringBootCondition <|-- OnClassCondition\n    SpringBootCondition <|-- FilteringSpringBootCondition\n    Condition <|.. SpringBootCondition\n    interface Condition {\n        boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata);\n    }\n{% endplantuml %}\n\n附上Condition接口源码:\n```java\n\n/**\n * A single {@code condition} that must be {@linkplain #matches matched} in order\n * for a component to be registered.\n *\n * <p>Conditions are checked immediately before the bean-definition is due to be\n * registered and are free to veto registration based on any criteria that can\n * be determined at that point.\n *\n * <p>Conditions must follow the same restrictions as {@link BeanFactoryPostProcessor}\n * and take care to never interact with bean instances. For more fine-grained control\n * of conditions that interact with {@code @Configuration} beans consider implementing\n * the {@link ConfigurationCondition} interface.\n *\n * @author Phillip Webb\n * @since 4.0\n * @see ConfigurationCondition\n * @see Conditional\n * @see ConditionContext\n */\n@FunctionalInterface\npublic interface Condition {\n\n\t/**\n\t * Determine if the condition matches.\n\t * @param context the condition context\n\t * @param metadata the metadata of the {@link org.springframework.core.type.AnnotationMetadata class}\n\t * or {@link org.springframework.core.type.MethodMetadata method} being checked\n\t * @return {@code true} if the condition matches and the component can be registered,\n\t * or {@code false} to veto the annotated component's registration\n\t */\n\tboolean matches(ConditionContext context, AnnotatedTypeMetadata metadata);\n\n}\n```\n\n总结一下其中的逻辑:\n{% blockquote %}\nIn short: Even though an ApplicationContextConfiguration comes with certain @Bean definitions, you as the end-user can still somewhat influence if a bean gets created or not.\n{% endblockquote %}\n即使每个ApplicationContextConfiguration都是来自某个@Bean的定义, 但是你最为最终使用者依然拥有对Bean的创建与否的决定权.\n\n\n## 使用@Conditional再次改造\n制造出新的ApplicationContextConfiguration\n```java\n@Configuration\npublic class SharedConfiguration {\n    @Bean\n    @Conditional(IsRequiredNeo4jDatabaseCondition.class)\n    public Driver neo4jDriver(Neo4jProperties properties, ...) {\n        return GraphDatabase.driver(...);\n    }\n}\n```\n实现Condition接口:\n```java\nimport org.springframework.context.annotation.Condition;\nimport org.springframework.context.annotation.ConditionContext;\nimport org.springframework.core.type.AnnotatedTypeMetadata;\n\npublic class IsRequiredNeo4jDatabaseCondition implements Condition {\n    @Override\n    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata){\n        return neo4jDriverOnClassPath() && databaseUrlSet(context); // [1]\n    }\n    private boolean databaseUrlSet(ConditioContext context) {\n        return context.getEnvironment().containsPreperty(\"spring.data.neo4j.uri\");\n    }\n    private boolean neo4jDriverOnClassPath() {\n        try {\n            Class.forName(\"org.neo4j.driver.Driver\");\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n}\n```\n[1]这里构造了两个条件来实施判断, 一个是检测properties中是否拥有某个配置项, 一个是检测是否引入了neo4jDriver对应的依赖(通过在classpath找寻对应的类是否存在即可).\n> 注意: 真是情况下的Neo4j配置与以上做法略有不同.\n\n那么以上两种match方式对应着两个最重要的Condition:\n - create @Beans depending on specific **available properties**.\n - create @Beans depending on specific **libraries on your classpath**.\n\n至此, 我们会有这样的疑问,\n - Conditionals that create a DataSource for you, because you have set specific properties (think: spring.data.neo4j.uri)? \n - Or @Conditionals that boot up an embedded Tomcat server for you because you have the Tomcat libraries on your classpath?\nThe Answer is YES, that (and not much more) is exactly what Spring Boot is. \n\n# Spring Boot Autoconfigurations: Three Internal Core Features\n## 定位PropertySources\nSpring Boot获取配置参数有一个顺序, 这个顺序是特殊的:\n{% blockquote Spring Boot docs%}\n1. Default properties (specified by setting SpringApplication.setDefaultProperties).\n2. `@PropertySource` annotations on your @Configuration classes. Please note that such property sources are not added to the Environment until the application context is being refreshed. This is too late to configure certain properties such as logging.* and spring.main.* which are read before refresh begins.\n3. Config data (such as application.properties files)\n4. A RandomValuePropertySource that has properties only in random.*.\n5. OS environment variables.\n6. Java System properties (System.getProperties()).\n7. JNDI attributes from java:comp/env.\n8. ServletContext init parameters.\n9. ServletConfig init parameters.\n10. Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property).\n11. Command line arguments.\n12. properties attribute on your tests. Available on @SpringBootTest and the test annotations for testing a particular slice of your application.\n13. @TestPropertySource annotations on your tests.\n14. Devtools global settings properties in the $HOME/.config/spring-boot directory when devtools is active.\n{% endblockquote %}\n以上这些就是Spring Boot启动时, 默认读取Property的位置和顺序.\n\n其中, 注解`@PropertySource`需要注意, 通过注解`@PropertySource`来定位配置文件`.properties`\n```java\n@PropertySource(value = \"classpath:application.properties\", ignoreResourceNotFound = true)\n```\n当你运行SpringBoot启动类的main方法, SpringBoot将会自动按顺序读取这14个PropertySource(低版本的可能是17个, 当前版本是2.5.6), 为的是将这些配置注入到项目中.\n\n> 提示: Spring Boot将配置的值注入bean的属性有两种办法\n> 1. @Value\n> 2. @ConfigurationProperties\n\n\n## Read-in META-INF/spring.factories\n每个SpringBoot项目都有一个共同的依赖, 就是`org.springframework.boot:spring-boot-autoconfigure`, 这个jar包包含了所有自动配置的magic. 其核心就是`META-INF/spring.factories`文件.\n```\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\norg.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\\n// ...\n// 100+ more lines\n```\n截取其中一段如上所示, EnableAutoConfiguration的值, 有100多个. 这些类都是普通的@Configurations并且有些有@Conditionals, Spring Boot读取这些类并对其Condition进行评估执行.\n\n## Enhanced Conditional Support\n@Conditional是一个较底层的注解, 基于此注解, 组合出了很多\"增强型\"的注解, 比如:\n - @ConditionalOnClass(DataSource.class). The condition is true if the DataSource class is on the classpath.\n - @ConditionalOnMissingClass(DataSource.class). The condition is true if the DataSource class is not on the classpath.\n - @ConditionalOnMissingBean(DataSource.class). The condition is true if the user did not specify a DataSource @Bean in any @Configuration.\n - @ConditionalOnWebApplication. The condition is true if the application is a web application.\n - @ConditionalOnProperty(\"my.property\"). The condition is true if my.property is set.\n - @ConditionalOnResource(\"classpath:my.properties\"). The condition is true if my.properties exists.\n - // e.g.\n大多数情况下, 都是用增强型注解更为方便.\n\n@Conditional增强型的注解大概分为以下几种:\n - Class Conditions\n - Bean Conditions\n - Property Conditions\n - Resource Conditions\n - Web Application Conditions\n - SpEL Expression Conditions\n\n### Class Conditions\n@ConditionalOnClass或者@ConditionalOnMissingClass, 通过判断指定的class在或者不在classpath中来, 判断Bean的创建与否. \n> **The fact is that annotation metadata is parsed by using ASM.**\nConditional注解一般有两个参数, `value`和`name`, 你可以通过`value`传真实的class参数, 即使这个类并没有出现在application classpath中.\n\n### Bean Conditions\nConditional @Conditional that only matches when no beans meeting the specified\nrequirements are already contained in the `BeanFactory`.\n\nWhen placed on a `@Bean` method, the bean class defaults to the return type of\nthe factory method:\n```java\n@Configuration\npublic class MyAutoConfiguration {\n    @Bean\n    @ConditionalOnMissingBean\n    // @ConditionalOnMissingBean没有传参数, 默认是此method的返回值类型, 同: @ConditionalOnMissingBean(MyService.class)\n    public MyService myService() {\n        ...\n    }\n}\n```\nIn the sample above the condition will match if no bean of type {@code MyService} is\nalready contained in the {@link BeanFactory}.\n\n#### Property Conditions...等不再讨论\n\n\n## AutoConfiguration测试\n```java\npublic class MyService {\n\n  private String name;\n\n  public MyService(String name) {\n    this.name = name;\n  }\n\n  public MyService() {}\n\n  public String getName() {\n    return this.name;\n  }\n}\n```\n\n```java\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration(proxyBeanMethods = false)\npublic class MyServiceAutoConfiguration {\n\n  @Bean\n  @ConditionalOnMissingBean // equivalent to @ConditionalOnMissingBean(MyService.class)\n  public MyService myService() {\n    // When MyService(bean type) doesn't exist, this bean will create.\n    return new MyService(\"test123\");\n  }\n}\n```\n\n测试AutoConfiguration需要借助ApplicationContextRunner, ApplicationContextRunner is usually defined as field of the \"test class\" to gather the base, common configuration.\n```java\nimport com.example.multimodule.service.auto.MyService;\nimport com.example.multimodule.service.auto.MyServiceAutoConfiguration;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.autoconfigure.AutoConfigurations;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.boot.test.context.runner.ApplicationContextRunner;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@SpringBootTest\npublic class TestAutoConfiguration {\n  // load MyServiceAutoConfiguration.class\n  private final ApplicationContextRunner contextRunner =\n      new ApplicationContextRunner()\n          .withConfiguration(AutoConfigurations.of(MyServiceAutoConfiguration.class));\n\n  @Configuration(proxyBeanMethods = false)\n  static class UserConfiguration {\n    @Bean\n    MyService myCustomService() {\n      // This bean is always created.\n      return new MyService(\"mine\");\n    }\n  }\n\n  @Test\n  void conditionEffectedTest() {\n    // @ConditionalOnMissingBean effect\n    this.contextRunner.run(\n        (context) -> {\n          assertThat(context).getBean(\"myService\");\n          assertThat(context).hasSingleBean(MyService.class);\n          assertThat(context.getBean(MyService.class).getName()).isEqualTo(\"test123\");\n        });\n  }\n\n  @Test\n  void conditionNotEffectedTest() {\n    // @ConditionalOnMissingBean effect\n    this.contextRunner\n        .withUserConfiguration(UserConfiguration.class) // add UserConfiguration into context.\n        .run(\n            (context -> {\n              assertThat(context).hasSingleBean(MyService.class);\n              assertThat(context)\n                  .getBean(\"myCustomService\")\n                  .isSameAs(context.getBean(MyService.class));\n              assertThat(context.getBean(MyService.class).getName()).isEqualTo(\"mine\");\n            }));\n  }\n}\n```\n从以上例子中可以看出, 当仅仅ApplicationContext仅仅加载MyServiceAutoConfiguration类时, 注入的Bean是`myService`, 当MyServiceAutoConfiguration和UserConfiguration都加载是注入的Bean是`myCustomService`, 从中体现出了@ConditionalOnMissingBean的作用.\n\n更多关于Autoconfiguration相关Conditional注解的测试可以查看: https://www.baeldung.com/spring-boot-context-runner\n\n# 构建自己的starter\na custom starter can contain the following:\n\n - The autoconfigure module that contains the auto-configuration code for \"acme\".\n\n - The starter module that provides a dependency to the autoconfigure module as well as \"acme\" and any additional dependencies that are typically useful. In a nutshell, adding the starter should provide everything needed to start using that library.\n\n#### Naming\nYou should make sure to provide a proper namespace for your starter. Do not start your module names with spring-boot\n#### Configuration keys\nIf your starter provides configuration keys, use a unique namespace for them. In particular, do not include your keys in the namespaces that Spring Boot uses (such as server, management, spring, and so on). \n```java\nimport java.time.Duration;\n\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\n@ConfigurationProperties(\"acme\")\npublic class AcmeProperties {\n\n    /**\n     * Whether to check the location of acme resources.\n     */\n    private boolean checkLocation = true;\n\n    /**\n     * Timeout for establishing a connection to the acme server.\n     */\n    private Duration loginTimeout = Duration.ofSeconds(3);\n\n    public boolean isCheckLocation() {\n        return this.checkLocation;\n    }\n\n    public void setCheckLocation(boolean checkLocation) {\n        this.checkLocation = checkLocation;\n    }\n\n    public Duration getLoginTimeout() {\n        return this.loginTimeout;\n    }\n\n    public void setLoginTimeout(Duration loginTimeout) {\n        this.loginTimeout = loginTimeout;\n    }\n\n}\n```\nHere are some rules we follow internally to make sure descriptions are consistent:\n - Do not start the description by \"The\" or \"A\".\n - For boolean types, start the description with \"Whether\" or \"Enable\".\n - For collection-based types, start the description with \"Comma-separated list\"\n - Use java.time.Duration rather than long and describe the default unit if it differs from milliseconds, such as \"If a duration suffix is not specified, seconds will be used\".\n - Do not provide the default value in the description unless it has to be determined at runtime.\n\n> Make sure to trigger meta-data generation so that IDE assistance is available for your keys as well. You may want to review the generated metadata (META-INF/spring-configuration-metadata.json) to make sure your keys are properly documented. Using your own starter in a compatible IDE is also a good idea to validate that quality of the metadata.\n\n## The \"autoconfigure\" module\n The `autoconfigure` module contains everything that is necessary to get started with the library. It may also contain configuration key definitions (such as @ConfigurationProperties) and any callback interface that can be used to further customize how the components are initialized.\n\nSpring Boot uses an annotation processor to collect the conditions on auto-configurations in a metadata file (`META-INF/spring-autoconfigure-metadata.properties`). If that file is present, it is used to eagerly filter auto-configurations that do not match, which will improve startup time. It is recommended to add the following dependency in a module that contains auto-configurations:\n```gradle\ndependencies {\n    compileOnly \"org.springframework.boot:spring-boot-autoconfigure-processor\"\n}\n```\n\n## Starter module\nThe starter is really an empty jar. Its only purpose is to provide the necessary dependencies to work with the library. You can think of it as an opinionated view of what is required to get started.\n\nDo not make assumptions about the project in which your starter is added. If the library you are auto-configuring typically requires other starters, mention them as well. Providing a proper set of *default* dependencies may be hard if the number of optional dependencies is high, as you should avoid including dependencies that are unnecessary for a typical usage of the library. In other words, you should not include optional dependencies.\n\n> NOTE: Either way, your starter must reference the core Spring Boot starter (spring-boot-starter) directly or indirectly (there is no need to add it if your starter relies on another starter). If a project is created with only your custom starter, Spring Boot’s core features will be honoured by the presence of the core starter.\n\n至此, 创建自己的starter并没有完成, 以上只是记录一下spring boot相关的重要的话, 接下来将会在`E:\\SpringProjects\\PracticeProjects\\spring-boot-practice-auto-configuration`中先进行实战, 对照着`E:\\SpringProjects\\PracticeProjects\\spring-boot-master-auto-configuration`项目的git log一步一步来. 但是要替换`spring-boot-master-auto-configuration`中的`hornetq`为`redis`, 所以先进行redis的学习.\n","slug":"spring-autoconfigurations","published":1,"updated":"2021-12-30T03:04:50.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxsdzpz20018xotg9bmc867m","content":"<p>Spring Framework’s @Conditional annotation is the core of Autoconfigurations.<br>事实上, 自动装配是基于标准的@Configuration类来实现的. @Conditional一系列注解用来限制自动装配的实施. 通常情况下, 自动装配的类使用@ConditionalOnClass和@ConditionalOnMissingBean注解. 这确保了自动装配类的实施, 是在当相关类被找到, 并且没有声明你自己的@Configuration的时候.</p>\n<h1 id=\"自动装配出现的背景\"><a href=\"#自动装配出现的背景\" class=\"headerlink\" title=\"自动装配出现的背景\"></a>自动装配出现的背景</h1><p>想象你在一个超级大公司里, 这个公司里有很多使用纯Spring Framework的项目, 大家的配置文件中有80%都是一样的. 这时, 你想到了是不是可以提取出一个共同的ApplicationContextConfiguration, 因为大家的有很多Bean是一样的.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SharedContextConfiguration</span> </span>&#123; <span class=\"comment\">// (1)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Driver <span class=\"title\">neo4jDriver</span><span class=\"params\">(Neo4jProperties properties, ...)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> GraphDatabase.driver(...);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可以将此SharedConfiguration项目, 打包发布公司maven仓库的一个依赖. 其他项目可以在自己的@Configuration类上再加上一个注解@Import(…Configuration.class)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@Import(SharedConfiguration.class)</span> <span class=\"comment\">// (1)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OtherProjectContextConfiguration</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// you would specify your project-specific beans here, as normal.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上方式看起来很好但是却存在一些问题:<br>如果SharedConfiguration中配置了某些Bean, 比如Neo4jBean, 在其他项目中是不需要的, 那么我是否可以排除这些Bean呢?</p>\n<p>这就引出了@Conditional注解.</p>\n<h1 id=\"自动装配核心注解-Conditional\"><a href=\"#自动装配核心注解-Conditional\" class=\"headerlink\" title=\"自动装配核心注解@Conditional\"></a>自动装配核心注解@Conditional</h1><p>@Conditional”系列注解”可以用在@Bean Method, @Components或者其他@Configuration注解上. 它们的作用范围都是<code>@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</code>, 比如@ConditionalOnClass, @ConditionalOnBean, @ConditionalOnMissBean等.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Conditional(OnClassCondition.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> ConditionalOnClass &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * The classes that must be present. Since this annotation is parsed by loading class</span></span><br><span class=\"line\"><span class=\"comment\">\t * bytecode, it is safe to specify classes here that may ultimately not be on the</span></span><br><span class=\"line\"><span class=\"comment\">\t * classpath, only if this annotation is directly on the affected component and</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;b&gt;not&lt;/b&gt; if this annotation is used as a composed, meta-annotation. In order to</span></span><br><span class=\"line\"><span class=\"comment\">\t * use this annotation as a meta-annotation, only use the &#123;<span class=\"doctag\">@link</span> #name&#125; attribute.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the classes that must be present</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tClass&lt;?&gt;[] value() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * The classes names that must be present.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the class names that must be present.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tString[] name() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这些注解需要@Conditional的加持(注解不支持继承, 只能通过组合的方式), @Conditional有一个”Condition”类的参数, 这个类中必须有一个方法叫matches(继承父类SpringBootCondition得此方法), 并返回一个Boolean值</p>\n<ul>\n<li>True: (Further Evaluate/Register) Create that @Bean, @Component or @Configuration</li>\n<li>False: (Stop Evaluating/Registering) Don’t create that @Bean, @Component or @Configuration<br>关系如下:<img  src=http://www.plantuml.com/plantuml/svg/VOon3i8m34JtV8L7a6X_01Qer0qnm0-On42arAx83I3Wtma25GR0m_bqVhus9iWnwdxTFtHXXiOqH4HJcbshYbRQ9CvvIDrFiltJvJxPkgPlIDJolcClz8OlZifipPAmKiVm1ycZuLuCv0JoppsXkQg18M5pxcKfuC1WwbvcF7MtEm00></li>\n</ul>\n<p>附上Condition接口源码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A single &#123;<span class=\"doctag\">@code</span> condition&#125; that must be &#123;<span class=\"doctag\">@linkplain</span> #matches matched&#125; in order</span></span><br><span class=\"line\"><span class=\"comment\"> * for a component to be registered.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;Conditions are checked immediately before the bean-definition is due to be</span></span><br><span class=\"line\"><span class=\"comment\"> * registered and are free to veto registration based on any criteria that can</span></span><br><span class=\"line\"><span class=\"comment\"> * be determined at that point.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;Conditions must follow the same restrictions as &#123;<span class=\"doctag\">@link</span> BeanFactoryPostProcessor&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * and take care to never interact with bean instances. For more fine-grained control</span></span><br><span class=\"line\"><span class=\"comment\"> * of conditions that interact with &#123;<span class=\"doctag\">@code</span> <span class=\"doctag\">@Configuration</span>&#125; beans consider implementing</span></span><br><span class=\"line\"><span class=\"comment\"> * the &#123;<span class=\"doctag\">@link</span> ConfigurationCondition&#125; interface.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Phillip Webb</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 4.0</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> ConfigurationCondition</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> Conditional</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> ConditionContext</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Condition</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Determine if the condition matches.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> context the condition context</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> metadata the metadata of the &#123;<span class=\"doctag\">@link</span> org.springframework.core.type.AnnotationMetadata class&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t * or &#123;<span class=\"doctag\">@link</span> org.springframework.core.type.MethodMetadata method&#125; being checked</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> true&#125; if the condition matches and the component can be registered,</span></span><br><span class=\"line\"><span class=\"comment\">\t * or &#123;<span class=\"doctag\">@code</span> false&#125; to veto the annotated component&#x27;s registration</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结一下其中的逻辑:</p>\n<blockquote><p>In short: Even though an ApplicationContextConfiguration comes with certain @Bean definitions, you as the end-user can still somewhat influence if a bean gets created or not.</p>\n</blockquote>\n<p>即使每个ApplicationContextConfiguration都是来自某个@Bean的定义, 但是你最为最终使用者依然拥有对Bean的创建与否的决定权.</p>\n<h2 id=\"使用-Conditional再次改造\"><a href=\"#使用-Conditional再次改造\" class=\"headerlink\" title=\"使用@Conditional再次改造\"></a>使用@Conditional再次改造</h2><p>制造出新的ApplicationContextConfiguration</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SharedConfiguration</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Conditional(IsRequiredNeo4jDatabaseCondition.class)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Driver <span class=\"title\">neo4jDriver</span><span class=\"params\">(Neo4jProperties properties, ...)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> GraphDatabase.driver(...);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现Condition接口:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Condition;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ConditionContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IsRequiredNeo4jDatabaseCondition</span> <span class=\"keyword\">implements</span> <span class=\"title\">Condition</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> neo4jDriverOnClassPath() &amp;&amp; databaseUrlSet(context); <span class=\"comment\">// [1]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">databaseUrlSet</span><span class=\"params\">(ConditioContext context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> context.getEnvironment().containsPreperty(<span class=\"string\">&quot;spring.data.neo4j.uri&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">neo4jDriverOnClassPath</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Class.forName(<span class=\"string\">&quot;org.neo4j.driver.Driver&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>[1]这里构造了两个条件来实施判断, 一个是检测properties中是否拥有某个配置项, 一个是检测是否引入了neo4jDriver对应的依赖(通过在classpath找寻对应的类是否存在即可).</p>\n<blockquote>\n<p>注意: 真是情况下的Neo4j配置与以上做法略有不同.</p>\n</blockquote>\n<p>那么以上两种match方式对应着两个最重要的Condition:</p>\n<ul>\n<li>create @Beans depending on specific <strong>available properties</strong>.</li>\n<li>create @Beans depending on specific <strong>libraries on your classpath</strong>.</li>\n</ul>\n<p>至此, 我们会有这样的疑问,</p>\n<ul>\n<li>Conditionals that create a DataSource for you, because you have set specific properties (think: spring.data.neo4j.uri)? </li>\n<li>Or @Conditionals that boot up an embedded Tomcat server for you because you have the Tomcat libraries on your classpath?<br>The Answer is YES, that (and not much more) is exactly what Spring Boot is. </li>\n</ul>\n<h1 id=\"Spring-Boot-Autoconfigurations-Three-Internal-Core-Features\"><a href=\"#Spring-Boot-Autoconfigurations-Three-Internal-Core-Features\" class=\"headerlink\" title=\"Spring Boot Autoconfigurations: Three Internal Core Features\"></a>Spring Boot Autoconfigurations: Three Internal Core Features</h1><h2 id=\"定位PropertySources\"><a href=\"#定位PropertySources\" class=\"headerlink\" title=\"定位PropertySources\"></a>定位PropertySources</h2><p>Spring Boot获取配置参数有一个顺序, 这个顺序是特殊的:</p>\n<blockquote><ol>\n<li>Default properties (specified by setting SpringApplication.setDefaultProperties).</li>\n<li><code>@PropertySource</code> annotations on your @Configuration classes. Please note that such property sources are not added to the Environment until the application context is being refreshed. This is too late to configure certain properties such as logging.* and spring.main.* which are read before refresh begins.</li>\n<li>Config data (such as application.properties files)</li>\n<li>A RandomValuePropertySource that has properties only in random.*.</li>\n<li>OS environment variables.</li>\n<li>Java System properties (System.getProperties()).</li>\n<li>JNDI attributes from java:comp/env.</li>\n<li>ServletContext init parameters.</li>\n<li>ServletConfig init parameters.</li>\n<li>Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property).</li>\n<li>Command line arguments.</li>\n<li>properties attribute on your tests. Available on @SpringBootTest and the test annotations for testing a particular slice of your application.</li>\n<li>@TestPropertySource annotations on your tests.</li>\n<li>Devtools global settings properties in the $HOME/.config/spring-boot directory when devtools is active.</li>\n</ol>\n<footer><strong>Spring Boot docs</strong></footer></blockquote>\n<p>以上这些就是Spring Boot启动时, 默认读取Property的位置和顺序.</p>\n<p>其中, 注解<code>@PropertySource</code>需要注意, 通过注解<code>@PropertySource</code>来定位配置文件<code>.properties</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PropertySource(value = &quot;classpath:application.properties&quot;, ignoreResourceNotFound = true)</span></span><br></pre></td></tr></table></figure>\n<p>当你运行SpringBoot启动类的main方法, SpringBoot将会自动按顺序读取这14个PropertySource(低版本的可能是17个, 当前版本是2.5.6), 为的是将这些配置注入到项目中.</p>\n<blockquote>\n<p>提示: Spring Boot将配置的值注入bean的属性有两种办法</p>\n<ol>\n<li>@Value</li>\n<li>@ConfigurationProperties</li>\n</ol>\n</blockquote>\n<h2 id=\"Read-in-META-INF-spring-factories\"><a href=\"#Read-in-META-INF-spring-factories\" class=\"headerlink\" title=\"Read-in META-INF/spring.factories\"></a>Read-in META-INF/spring.factories</h2><p>每个SpringBoot项目都有一个共同的依赖, 就是<code>org.springframework.boot:spring-boot-autoconfigure</code>, 这个jar包包含了所有自动配置的magic. 其核心就是<code>META-INF/spring.factories</code>文件.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Auto Configure</span><br><span class=\"line\">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\</span><br><span class=\"line\">// ...</span><br><span class=\"line\">// 100+ more lines</span><br></pre></td></tr></table></figure>\n<p>截取其中一段如上所示, EnableAutoConfiguration的值, 有100多个. 这些类都是普通的@Configurations并且有些有@Conditionals, Spring Boot读取这些类并对其Condition进行评估执行.</p>\n<h2 id=\"Enhanced-Conditional-Support\"><a href=\"#Enhanced-Conditional-Support\" class=\"headerlink\" title=\"Enhanced Conditional Support\"></a>Enhanced Conditional Support</h2><p>@Conditional是一个较底层的注解, 基于此注解, 组合出了很多”增强型”的注解, 比如:</p>\n<ul>\n<li>@ConditionalOnClass(DataSource.class). The condition is true if the DataSource class is on the classpath.</li>\n<li>@ConditionalOnMissingClass(DataSource.class). The condition is true if the DataSource class is not on the classpath.</li>\n<li>@ConditionalOnMissingBean(DataSource.class). The condition is true if the user did not specify a DataSource @Bean in any @Configuration.</li>\n<li>@ConditionalOnWebApplication. The condition is true if the application is a web application.</li>\n<li>@ConditionalOnProperty(“my.property”). The condition is true if my.property is set.</li>\n<li>@ConditionalOnResource(“classpath:my.properties”). The condition is true if my.properties exists.</li>\n<li>// e.g.<br>大多数情况下, 都是用增强型注解更为方便.</li>\n</ul>\n<p>@Conditional增强型的注解大概分为以下几种:</p>\n<ul>\n<li>Class Conditions</li>\n<li>Bean Conditions</li>\n<li>Property Conditions</li>\n<li>Resource Conditions</li>\n<li>Web Application Conditions</li>\n<li>SpEL Expression Conditions</li>\n</ul>\n<h3 id=\"Class-Conditions\"><a href=\"#Class-Conditions\" class=\"headerlink\" title=\"Class Conditions\"></a>Class Conditions</h3><p>@ConditionalOnClass或者@ConditionalOnMissingClass, 通过判断指定的class在或者不在classpath中来, 判断Bean的创建与否. </p>\n<blockquote>\n<p><strong>The fact is that annotation metadata is parsed by using ASM.</strong><br>Conditional注解一般有两个参数, <code>value</code>和<code>name</code>, 你可以通过<code>value</code>传真实的class参数, 即使这个类并没有出现在application classpath中.</p>\n</blockquote>\n<h3 id=\"Bean-Conditions\"><a href=\"#Bean-Conditions\" class=\"headerlink\" title=\"Bean Conditions\"></a>Bean Conditions</h3><p>Conditional @Conditional that only matches when no beans meeting the specified<br>requirements are already contained in the <code>BeanFactory</code>.</p>\n<p>When placed on a <code>@Bean</code> method, the bean class defaults to the return type of<br>the factory method:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAutoConfiguration</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@ConditionalOnMissingBean</span></span><br><span class=\"line\">    <span class=\"comment\">// @ConditionalOnMissingBean没有传参数, 默认是此method的返回值类型, 同: @ConditionalOnMissingBean(MyService.class)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> MyService <span class=\"title\">myService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>In the sample above the condition will match if no bean of type {@code MyService} is<br>already contained in the {@link BeanFactory}.</p>\n<h4 id=\"Property-Conditions…等不再讨论\"><a href=\"#Property-Conditions…等不再讨论\" class=\"headerlink\" title=\"Property Conditions…等不再讨论\"></a>Property Conditions…等不再讨论</h4><h2 id=\"AutoConfiguration测试\"><a href=\"#AutoConfiguration测试\" class=\"headerlink\" title=\"AutoConfiguration测试\"></a>AutoConfiguration测试</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyService</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyService</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration(proxyBeanMethods = false)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyServiceAutoConfiguration</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"meta\">@ConditionalOnMissingBean</span> <span class=\"comment\">// equivalent to @ConditionalOnMissingBean(MyService.class)</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> MyService <span class=\"title\">myService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// When MyService(bean type) doesn&#x27;t exist, this bean will create.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyService(<span class=\"string\">&quot;test123&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试AutoConfiguration需要借助ApplicationContextRunner, ApplicationContextRunner is usually defined as field of the “test class” to gather the base, common configuration.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.example.multimodule.service.auto.MyService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.multimodule.service.auto.MyServiceAutoConfiguration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.jupiter.api.Test;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.AutoConfigurations;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.test.context.runner.ApplicationContextRunner;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.assertj.core.api.Assertions.assertThat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestAutoConfiguration</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// load MyServiceAutoConfiguration.class</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ApplicationContextRunner contextRunner =</span><br><span class=\"line\">      <span class=\"keyword\">new</span> ApplicationContextRunner()</span><br><span class=\"line\">          .withConfiguration(AutoConfigurations.of(MyServiceAutoConfiguration.class));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Configuration(proxyBeanMethods = false)</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserConfiguration</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\">MyService <span class=\"title\">myCustomService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// This bean is always created.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyService(<span class=\"string\">&quot;mine&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Test</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">conditionEffectedTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// @ConditionalOnMissingBean effect</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.contextRunner.run(</span><br><span class=\"line\">        (context) -&gt; &#123;</span><br><span class=\"line\">          assertThat(context).getBean(<span class=\"string\">&quot;myService&quot;</span>);</span><br><span class=\"line\">          assertThat(context).hasSingleBean(MyService.class);</span><br><span class=\"line\">          assertThat(context.getBean(MyService.class).getName()).isEqualTo(<span class=\"string\">&quot;test123&quot;</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Test</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">conditionNotEffectedTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// @ConditionalOnMissingBean effect</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.contextRunner</span><br><span class=\"line\">        .withUserConfiguration(UserConfiguration.class) <span class=\"comment\">// add UserConfiguration into context.</span></span><br><span class=\"line\">        .run(</span><br><span class=\"line\">            (context -&gt; &#123;</span><br><span class=\"line\">              assertThat(context).hasSingleBean(MyService.class);</span><br><span class=\"line\">              assertThat(context)</span><br><span class=\"line\">                  .getBean(<span class=\"string\">&quot;myCustomService&quot;</span>)</span><br><span class=\"line\">                  .isSameAs(context.getBean(MyService.class));</span><br><span class=\"line\">              assertThat(context.getBean(MyService.class).getName()).isEqualTo(<span class=\"string\">&quot;mine&quot;</span>);</span><br><span class=\"line\">            &#125;));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从以上例子中可以看出, 当仅仅ApplicationContext仅仅加载MyServiceAutoConfiguration类时, 注入的Bean是<code>myService</code>, 当MyServiceAutoConfiguration和UserConfiguration都加载是注入的Bean是<code>myCustomService</code>, 从中体现出了@ConditionalOnMissingBean的作用.</p>\n<p>更多关于Autoconfiguration相关Conditional注解的测试可以查看: <a href=\"https://www.baeldung.com/spring-boot-context-runner\">https://www.baeldung.com/spring-boot-context-runner</a></p>\n<h1 id=\"构建自己的starter\"><a href=\"#构建自己的starter\" class=\"headerlink\" title=\"构建自己的starter\"></a>构建自己的starter</h1><p>a custom starter can contain the following:</p>\n<ul>\n<li><p>The autoconfigure module that contains the auto-configuration code for “acme”.</p>\n</li>\n<li><p>The starter module that provides a dependency to the autoconfigure module as well as “acme” and any additional dependencies that are typically useful. In a nutshell, adding the starter should provide everything needed to start using that library.</p>\n</li>\n</ul>\n<h4 id=\"Naming\"><a href=\"#Naming\" class=\"headerlink\" title=\"Naming\"></a>Naming</h4><p>You should make sure to provide a proper namespace for your starter. Do not start your module names with spring-boot</p>\n<h4 id=\"Configuration-keys\"><a href=\"#Configuration-keys\" class=\"headerlink\" title=\"Configuration keys\"></a>Configuration keys</h4><p>If your starter provides configuration keys, use a unique namespace for them. In particular, do not include your keys in the namespaces that Spring Boot uses (such as server, management, spring, and so on). </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.time.Duration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ConfigurationProperties(&quot;acme&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AcmeProperties</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Whether to check the location of acme resources.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> checkLocation = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Timeout for establishing a connection to the acme server.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Duration loginTimeout = Duration.ofSeconds(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isCheckLocation</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.checkLocation;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCheckLocation</span><span class=\"params\">(<span class=\"keyword\">boolean</span> checkLocation)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.checkLocation = checkLocation;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Duration <span class=\"title\">getLoginTimeout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.loginTimeout;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setLoginTimeout</span><span class=\"params\">(Duration loginTimeout)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.loginTimeout = loginTimeout;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Here are some rules we follow internally to make sure descriptions are consistent:</p>\n<ul>\n<li>Do not start the description by “The” or “A”.</li>\n<li>For boolean types, start the description with “Whether” or “Enable”.</li>\n<li>For collection-based types, start the description with “Comma-separated list”</li>\n<li>Use java.time.Duration rather than long and describe the default unit if it differs from milliseconds, such as “If a duration suffix is not specified, seconds will be used”.</li>\n<li>Do not provide the default value in the description unless it has to be determined at runtime.</li>\n</ul>\n<blockquote>\n<p>Make sure to trigger meta-data generation so that IDE assistance is available for your keys as well. You may want to review the generated metadata (META-INF/spring-configuration-metadata.json) to make sure your keys are properly documented. Using your own starter in a compatible IDE is also a good idea to validate that quality of the metadata.</p>\n</blockquote>\n<h2 id=\"The-“autoconfigure”-module\"><a href=\"#The-“autoconfigure”-module\" class=\"headerlink\" title=\"The “autoconfigure” module\"></a>The “autoconfigure” module</h2><p> The <code>autoconfigure</code> module contains everything that is necessary to get started with the library. It may also contain configuration key definitions (such as @ConfigurationProperties) and any callback interface that can be used to further customize how the components are initialized.</p>\n<p>Spring Boot uses an annotation processor to collect the conditions on auto-configurations in a metadata file (<code>META-INF/spring-autoconfigure-metadata.properties</code>). If that file is present, it is used to eagerly filter auto-configurations that do not match, which will improve startup time. It is recommended to add the following dependency in a module that contains auto-configurations:</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    compileOnly <span class=\"string\">&quot;org.springframework.boot:spring-boot-autoconfigure-processor&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Starter-module\"><a href=\"#Starter-module\" class=\"headerlink\" title=\"Starter module\"></a>Starter module</h2><p>The starter is really an empty jar. Its only purpose is to provide the necessary dependencies to work with the library. You can think of it as an opinionated view of what is required to get started.</p>\n<p>Do not make assumptions about the project in which your starter is added. If the library you are auto-configuring typically requires other starters, mention them as well. Providing a proper set of <em>default</em> dependencies may be hard if the number of optional dependencies is high, as you should avoid including dependencies that are unnecessary for a typical usage of the library. In other words, you should not include optional dependencies.</p>\n<blockquote>\n<p>NOTE: Either way, your starter must reference the core Spring Boot starter (spring-boot-starter) directly or indirectly (there is no need to add it if your starter relies on another starter). If a project is created with only your custom starter, Spring Boot’s core features will be honoured by the presence of the core starter.</p>\n</blockquote>\n<p>至此, 创建自己的starter并没有完成, 以上只是记录一下spring boot相关的重要的话, 接下来将会在<code>E:\\SpringProjects\\PracticeProjects\\spring-boot-practice-auto-configuration</code>中先进行实战, 对照着<code>E:\\SpringProjects\\PracticeProjects\\spring-boot-master-auto-configuration</code>项目的git log一步一步来. 但是要替换<code>spring-boot-master-auto-configuration</code>中的<code>hornetq</code>为<code>redis</code>, 所以先进行redis的学习.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Spring Framework’s @Conditional annotation is the core of Autoconfigurations.<br>事实上, 自动装配是基于标准的@Configuration类来实现的. @Conditional一系列注解用来限制自动装配的实施. 通常情况下, 自动装配的类使用@ConditionalOnClass和@ConditionalOnMissingBean注解. 这确保了自动装配类的实施, 是在当相关类被找到, 并且没有声明你自己的@Configuration的时候.</p>\n<h1 id=\"自动装配出现的背景\"><a href=\"#自动装配出现的背景\" class=\"headerlink\" title=\"自动装配出现的背景\"></a>自动装配出现的背景</h1><p>想象你在一个超级大公司里, 这个公司里有很多使用纯Spring Framework的项目, 大家的配置文件中有80%都是一样的. 这时, 你想到了是不是可以提取出一个共同的ApplicationContextConfiguration, 因为大家的有很多Bean是一样的.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SharedContextConfiguration</span> </span>&#123; <span class=\"comment\">// (1)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Driver <span class=\"title\">neo4jDriver</span><span class=\"params\">(Neo4jProperties properties, ...)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> GraphDatabase.driver(...);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可以将此SharedConfiguration项目, 打包发布公司maven仓库的一个依赖. 其他项目可以在自己的@Configuration类上再加上一个注解@Import(…Configuration.class)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@Import(SharedConfiguration.class)</span> <span class=\"comment\">// (1)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OtherProjectContextConfiguration</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// you would specify your project-specific beans here, as normal.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上方式看起来很好但是却存在一些问题:<br>如果SharedConfiguration中配置了某些Bean, 比如Neo4jBean, 在其他项目中是不需要的, 那么我是否可以排除这些Bean呢?</p>\n<p>这就引出了@Conditional注解.</p>\n<h1 id=\"自动装配核心注解-Conditional\"><a href=\"#自动装配核心注解-Conditional\" class=\"headerlink\" title=\"自动装配核心注解@Conditional\"></a>自动装配核心注解@Conditional</h1><p>@Conditional”系列注解”可以用在@Bean Method, @Components或者其他@Configuration注解上. 它们的作用范围都是<code>@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</code>, 比如@ConditionalOnClass, @ConditionalOnBean, @ConditionalOnMissBean等.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Conditional(OnClassCondition.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> ConditionalOnClass &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * The classes that must be present. Since this annotation is parsed by loading class</span></span><br><span class=\"line\"><span class=\"comment\">\t * bytecode, it is safe to specify classes here that may ultimately not be on the</span></span><br><span class=\"line\"><span class=\"comment\">\t * classpath, only if this annotation is directly on the affected component and</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;b&gt;not&lt;/b&gt; if this annotation is used as a composed, meta-annotation. In order to</span></span><br><span class=\"line\"><span class=\"comment\">\t * use this annotation as a meta-annotation, only use the &#123;<span class=\"doctag\">@link</span> #name&#125; attribute.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the classes that must be present</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tClass&lt;?&gt;[] value() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * The classes names that must be present.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the class names that must be present.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tString[] name() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这些注解需要@Conditional的加持(注解不支持继承, 只能通过组合的方式), @Conditional有一个”Condition”类的参数, 这个类中必须有一个方法叫matches(继承父类SpringBootCondition得此方法), 并返回一个Boolean值</p>\n<ul>\n<li>True: (Further Evaluate/Register) Create that @Bean, @Component or @Configuration</li>\n<li>False: (Stop Evaluating/Registering) Don’t create that @Bean, @Component or @Configuration<br>关系如下:<img  src=http://www.plantuml.com/plantuml/svg/VOon3i8m34JtV8L7a6X_01Qer0qnm0-On42arAx83I3Wtma25GR0m_bqVhus9iWnwdxTFtHXXiOqH4HJcbshYbRQ9CvvIDrFiltJvJxPkgPlIDJolcClz8OlZifipPAmKiVm1ycZuLuCv0JoppsXkQg18M5pxcKfuC1WwbvcF7MtEm00></li>\n</ul>\n<p>附上Condition接口源码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A single &#123;<span class=\"doctag\">@code</span> condition&#125; that must be &#123;<span class=\"doctag\">@linkplain</span> #matches matched&#125; in order</span></span><br><span class=\"line\"><span class=\"comment\"> * for a component to be registered.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;Conditions are checked immediately before the bean-definition is due to be</span></span><br><span class=\"line\"><span class=\"comment\"> * registered and are free to veto registration based on any criteria that can</span></span><br><span class=\"line\"><span class=\"comment\"> * be determined at that point.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;Conditions must follow the same restrictions as &#123;<span class=\"doctag\">@link</span> BeanFactoryPostProcessor&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * and take care to never interact with bean instances. For more fine-grained control</span></span><br><span class=\"line\"><span class=\"comment\"> * of conditions that interact with &#123;<span class=\"doctag\">@code</span> <span class=\"doctag\">@Configuration</span>&#125; beans consider implementing</span></span><br><span class=\"line\"><span class=\"comment\"> * the &#123;<span class=\"doctag\">@link</span> ConfigurationCondition&#125; interface.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Phillip Webb</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 4.0</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> ConfigurationCondition</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> Conditional</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> ConditionContext</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Condition</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Determine if the condition matches.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> context the condition context</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> metadata the metadata of the &#123;<span class=\"doctag\">@link</span> org.springframework.core.type.AnnotationMetadata class&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t * or &#123;<span class=\"doctag\">@link</span> org.springframework.core.type.MethodMetadata method&#125; being checked</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> true&#125; if the condition matches and the component can be registered,</span></span><br><span class=\"line\"><span class=\"comment\">\t * or &#123;<span class=\"doctag\">@code</span> false&#125; to veto the annotated component&#x27;s registration</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结一下其中的逻辑:</p>\n<blockquote><p>In short: Even though an ApplicationContextConfiguration comes with certain @Bean definitions, you as the end-user can still somewhat influence if a bean gets created or not.</p>\n</blockquote>\n<p>即使每个ApplicationContextConfiguration都是来自某个@Bean的定义, 但是你最为最终使用者依然拥有对Bean的创建与否的决定权.</p>\n<h2 id=\"使用-Conditional再次改造\"><a href=\"#使用-Conditional再次改造\" class=\"headerlink\" title=\"使用@Conditional再次改造\"></a>使用@Conditional再次改造</h2><p>制造出新的ApplicationContextConfiguration</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SharedConfiguration</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Conditional(IsRequiredNeo4jDatabaseCondition.class)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Driver <span class=\"title\">neo4jDriver</span><span class=\"params\">(Neo4jProperties properties, ...)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> GraphDatabase.driver(...);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现Condition接口:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Condition;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ConditionContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IsRequiredNeo4jDatabaseCondition</span> <span class=\"keyword\">implements</span> <span class=\"title\">Condition</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> neo4jDriverOnClassPath() &amp;&amp; databaseUrlSet(context); <span class=\"comment\">// [1]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">databaseUrlSet</span><span class=\"params\">(ConditioContext context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> context.getEnvironment().containsPreperty(<span class=\"string\">&quot;spring.data.neo4j.uri&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">neo4jDriverOnClassPath</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Class.forName(<span class=\"string\">&quot;org.neo4j.driver.Driver&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>[1]这里构造了两个条件来实施判断, 一个是检测properties中是否拥有某个配置项, 一个是检测是否引入了neo4jDriver对应的依赖(通过在classpath找寻对应的类是否存在即可).</p>\n<blockquote>\n<p>注意: 真是情况下的Neo4j配置与以上做法略有不同.</p>\n</blockquote>\n<p>那么以上两种match方式对应着两个最重要的Condition:</p>\n<ul>\n<li>create @Beans depending on specific <strong>available properties</strong>.</li>\n<li>create @Beans depending on specific <strong>libraries on your classpath</strong>.</li>\n</ul>\n<p>至此, 我们会有这样的疑问,</p>\n<ul>\n<li>Conditionals that create a DataSource for you, because you have set specific properties (think: spring.data.neo4j.uri)? </li>\n<li>Or @Conditionals that boot up an embedded Tomcat server for you because you have the Tomcat libraries on your classpath?<br>The Answer is YES, that (and not much more) is exactly what Spring Boot is. </li>\n</ul>\n<h1 id=\"Spring-Boot-Autoconfigurations-Three-Internal-Core-Features\"><a href=\"#Spring-Boot-Autoconfigurations-Three-Internal-Core-Features\" class=\"headerlink\" title=\"Spring Boot Autoconfigurations: Three Internal Core Features\"></a>Spring Boot Autoconfigurations: Three Internal Core Features</h1><h2 id=\"定位PropertySources\"><a href=\"#定位PropertySources\" class=\"headerlink\" title=\"定位PropertySources\"></a>定位PropertySources</h2><p>Spring Boot获取配置参数有一个顺序, 这个顺序是特殊的:</p>\n<blockquote><ol>\n<li>Default properties (specified by setting SpringApplication.setDefaultProperties).</li>\n<li><code>@PropertySource</code> annotations on your @Configuration classes. Please note that such property sources are not added to the Environment until the application context is being refreshed. This is too late to configure certain properties such as logging.* and spring.main.* which are read before refresh begins.</li>\n<li>Config data (such as application.properties files)</li>\n<li>A RandomValuePropertySource that has properties only in random.*.</li>\n<li>OS environment variables.</li>\n<li>Java System properties (System.getProperties()).</li>\n<li>JNDI attributes from java:comp/env.</li>\n<li>ServletContext init parameters.</li>\n<li>ServletConfig init parameters.</li>\n<li>Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property).</li>\n<li>Command line arguments.</li>\n<li>properties attribute on your tests. Available on @SpringBootTest and the test annotations for testing a particular slice of your application.</li>\n<li>@TestPropertySource annotations on your tests.</li>\n<li>Devtools global settings properties in the $HOME/.config/spring-boot directory when devtools is active.</li>\n</ol>\n<footer><strong>Spring Boot docs</strong></footer></blockquote>\n<p>以上这些就是Spring Boot启动时, 默认读取Property的位置和顺序.</p>\n<p>其中, 注解<code>@PropertySource</code>需要注意, 通过注解<code>@PropertySource</code>来定位配置文件<code>.properties</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PropertySource(value = &quot;classpath:application.properties&quot;, ignoreResourceNotFound = true)</span></span><br></pre></td></tr></table></figure>\n<p>当你运行SpringBoot启动类的main方法, SpringBoot将会自动按顺序读取这14个PropertySource(低版本的可能是17个, 当前版本是2.5.6), 为的是将这些配置注入到项目中.</p>\n<blockquote>\n<p>提示: Spring Boot将配置的值注入bean的属性有两种办法</p>\n<ol>\n<li>@Value</li>\n<li>@ConfigurationProperties</li>\n</ol>\n</blockquote>\n<h2 id=\"Read-in-META-INF-spring-factories\"><a href=\"#Read-in-META-INF-spring-factories\" class=\"headerlink\" title=\"Read-in META-INF/spring.factories\"></a>Read-in META-INF/spring.factories</h2><p>每个SpringBoot项目都有一个共同的依赖, 就是<code>org.springframework.boot:spring-boot-autoconfigure</code>, 这个jar包包含了所有自动配置的magic. 其核心就是<code>META-INF/spring.factories</code>文件.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Auto Configure</span><br><span class=\"line\">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\</span><br><span class=\"line\">// ...</span><br><span class=\"line\">// 100+ more lines</span><br></pre></td></tr></table></figure>\n<p>截取其中一段如上所示, EnableAutoConfiguration的值, 有100多个. 这些类都是普通的@Configurations并且有些有@Conditionals, Spring Boot读取这些类并对其Condition进行评估执行.</p>\n<h2 id=\"Enhanced-Conditional-Support\"><a href=\"#Enhanced-Conditional-Support\" class=\"headerlink\" title=\"Enhanced Conditional Support\"></a>Enhanced Conditional Support</h2><p>@Conditional是一个较底层的注解, 基于此注解, 组合出了很多”增强型”的注解, 比如:</p>\n<ul>\n<li>@ConditionalOnClass(DataSource.class). The condition is true if the DataSource class is on the classpath.</li>\n<li>@ConditionalOnMissingClass(DataSource.class). The condition is true if the DataSource class is not on the classpath.</li>\n<li>@ConditionalOnMissingBean(DataSource.class). The condition is true if the user did not specify a DataSource @Bean in any @Configuration.</li>\n<li>@ConditionalOnWebApplication. The condition is true if the application is a web application.</li>\n<li>@ConditionalOnProperty(“my.property”). The condition is true if my.property is set.</li>\n<li>@ConditionalOnResource(“classpath:my.properties”). The condition is true if my.properties exists.</li>\n<li>// e.g.<br>大多数情况下, 都是用增强型注解更为方便.</li>\n</ul>\n<p>@Conditional增强型的注解大概分为以下几种:</p>\n<ul>\n<li>Class Conditions</li>\n<li>Bean Conditions</li>\n<li>Property Conditions</li>\n<li>Resource Conditions</li>\n<li>Web Application Conditions</li>\n<li>SpEL Expression Conditions</li>\n</ul>\n<h3 id=\"Class-Conditions\"><a href=\"#Class-Conditions\" class=\"headerlink\" title=\"Class Conditions\"></a>Class Conditions</h3><p>@ConditionalOnClass或者@ConditionalOnMissingClass, 通过判断指定的class在或者不在classpath中来, 判断Bean的创建与否. </p>\n<blockquote>\n<p><strong>The fact is that annotation metadata is parsed by using ASM.</strong><br>Conditional注解一般有两个参数, <code>value</code>和<code>name</code>, 你可以通过<code>value</code>传真实的class参数, 即使这个类并没有出现在application classpath中.</p>\n</blockquote>\n<h3 id=\"Bean-Conditions\"><a href=\"#Bean-Conditions\" class=\"headerlink\" title=\"Bean Conditions\"></a>Bean Conditions</h3><p>Conditional @Conditional that only matches when no beans meeting the specified<br>requirements are already contained in the <code>BeanFactory</code>.</p>\n<p>When placed on a <code>@Bean</code> method, the bean class defaults to the return type of<br>the factory method:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAutoConfiguration</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@ConditionalOnMissingBean</span></span><br><span class=\"line\">    <span class=\"comment\">// @ConditionalOnMissingBean没有传参数, 默认是此method的返回值类型, 同: @ConditionalOnMissingBean(MyService.class)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> MyService <span class=\"title\">myService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>In the sample above the condition will match if no bean of type {@code MyService} is<br>already contained in the {@link BeanFactory}.</p>\n<h4 id=\"Property-Conditions…等不再讨论\"><a href=\"#Property-Conditions…等不再讨论\" class=\"headerlink\" title=\"Property Conditions…等不再讨论\"></a>Property Conditions…等不再讨论</h4><h2 id=\"AutoConfiguration测试\"><a href=\"#AutoConfiguration测试\" class=\"headerlink\" title=\"AutoConfiguration测试\"></a>AutoConfiguration测试</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyService</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyService</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration(proxyBeanMethods = false)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyServiceAutoConfiguration</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"meta\">@ConditionalOnMissingBean</span> <span class=\"comment\">// equivalent to @ConditionalOnMissingBean(MyService.class)</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> MyService <span class=\"title\">myService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// When MyService(bean type) doesn&#x27;t exist, this bean will create.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyService(<span class=\"string\">&quot;test123&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试AutoConfiguration需要借助ApplicationContextRunner, ApplicationContextRunner is usually defined as field of the “test class” to gather the base, common configuration.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.example.multimodule.service.auto.MyService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.multimodule.service.auto.MyServiceAutoConfiguration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.jupiter.api.Test;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.AutoConfigurations;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.test.context.runner.ApplicationContextRunner;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.assertj.core.api.Assertions.assertThat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestAutoConfiguration</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// load MyServiceAutoConfiguration.class</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ApplicationContextRunner contextRunner =</span><br><span class=\"line\">      <span class=\"keyword\">new</span> ApplicationContextRunner()</span><br><span class=\"line\">          .withConfiguration(AutoConfigurations.of(MyServiceAutoConfiguration.class));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Configuration(proxyBeanMethods = false)</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserConfiguration</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\">MyService <span class=\"title\">myCustomService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// This bean is always created.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyService(<span class=\"string\">&quot;mine&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Test</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">conditionEffectedTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// @ConditionalOnMissingBean effect</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.contextRunner.run(</span><br><span class=\"line\">        (context) -&gt; &#123;</span><br><span class=\"line\">          assertThat(context).getBean(<span class=\"string\">&quot;myService&quot;</span>);</span><br><span class=\"line\">          assertThat(context).hasSingleBean(MyService.class);</span><br><span class=\"line\">          assertThat(context.getBean(MyService.class).getName()).isEqualTo(<span class=\"string\">&quot;test123&quot;</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Test</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">conditionNotEffectedTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// @ConditionalOnMissingBean effect</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.contextRunner</span><br><span class=\"line\">        .withUserConfiguration(UserConfiguration.class) <span class=\"comment\">// add UserConfiguration into context.</span></span><br><span class=\"line\">        .run(</span><br><span class=\"line\">            (context -&gt; &#123;</span><br><span class=\"line\">              assertThat(context).hasSingleBean(MyService.class);</span><br><span class=\"line\">              assertThat(context)</span><br><span class=\"line\">                  .getBean(<span class=\"string\">&quot;myCustomService&quot;</span>)</span><br><span class=\"line\">                  .isSameAs(context.getBean(MyService.class));</span><br><span class=\"line\">              assertThat(context.getBean(MyService.class).getName()).isEqualTo(<span class=\"string\">&quot;mine&quot;</span>);</span><br><span class=\"line\">            &#125;));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从以上例子中可以看出, 当仅仅ApplicationContext仅仅加载MyServiceAutoConfiguration类时, 注入的Bean是<code>myService</code>, 当MyServiceAutoConfiguration和UserConfiguration都加载是注入的Bean是<code>myCustomService</code>, 从中体现出了@ConditionalOnMissingBean的作用.</p>\n<p>更多关于Autoconfiguration相关Conditional注解的测试可以查看: <a href=\"https://www.baeldung.com/spring-boot-context-runner\">https://www.baeldung.com/spring-boot-context-runner</a></p>\n<h1 id=\"构建自己的starter\"><a href=\"#构建自己的starter\" class=\"headerlink\" title=\"构建自己的starter\"></a>构建自己的starter</h1><p>a custom starter can contain the following:</p>\n<ul>\n<li><p>The autoconfigure module that contains the auto-configuration code for “acme”.</p>\n</li>\n<li><p>The starter module that provides a dependency to the autoconfigure module as well as “acme” and any additional dependencies that are typically useful. In a nutshell, adding the starter should provide everything needed to start using that library.</p>\n</li>\n</ul>\n<h4 id=\"Naming\"><a href=\"#Naming\" class=\"headerlink\" title=\"Naming\"></a>Naming</h4><p>You should make sure to provide a proper namespace for your starter. Do not start your module names with spring-boot</p>\n<h4 id=\"Configuration-keys\"><a href=\"#Configuration-keys\" class=\"headerlink\" title=\"Configuration keys\"></a>Configuration keys</h4><p>If your starter provides configuration keys, use a unique namespace for them. In particular, do not include your keys in the namespaces that Spring Boot uses (such as server, management, spring, and so on). </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.time.Duration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ConfigurationProperties(&quot;acme&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AcmeProperties</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Whether to check the location of acme resources.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> checkLocation = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Timeout for establishing a connection to the acme server.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Duration loginTimeout = Duration.ofSeconds(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isCheckLocation</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.checkLocation;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCheckLocation</span><span class=\"params\">(<span class=\"keyword\">boolean</span> checkLocation)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.checkLocation = checkLocation;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Duration <span class=\"title\">getLoginTimeout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.loginTimeout;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setLoginTimeout</span><span class=\"params\">(Duration loginTimeout)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.loginTimeout = loginTimeout;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Here are some rules we follow internally to make sure descriptions are consistent:</p>\n<ul>\n<li>Do not start the description by “The” or “A”.</li>\n<li>For boolean types, start the description with “Whether” or “Enable”.</li>\n<li>For collection-based types, start the description with “Comma-separated list”</li>\n<li>Use java.time.Duration rather than long and describe the default unit if it differs from milliseconds, such as “If a duration suffix is not specified, seconds will be used”.</li>\n<li>Do not provide the default value in the description unless it has to be determined at runtime.</li>\n</ul>\n<blockquote>\n<p>Make sure to trigger meta-data generation so that IDE assistance is available for your keys as well. You may want to review the generated metadata (META-INF/spring-configuration-metadata.json) to make sure your keys are properly documented. Using your own starter in a compatible IDE is also a good idea to validate that quality of the metadata.</p>\n</blockquote>\n<h2 id=\"The-“autoconfigure”-module\"><a href=\"#The-“autoconfigure”-module\" class=\"headerlink\" title=\"The “autoconfigure” module\"></a>The “autoconfigure” module</h2><p> The <code>autoconfigure</code> module contains everything that is necessary to get started with the library. It may also contain configuration key definitions (such as @ConfigurationProperties) and any callback interface that can be used to further customize how the components are initialized.</p>\n<p>Spring Boot uses an annotation processor to collect the conditions on auto-configurations in a metadata file (<code>META-INF/spring-autoconfigure-metadata.properties</code>). If that file is present, it is used to eagerly filter auto-configurations that do not match, which will improve startup time. It is recommended to add the following dependency in a module that contains auto-configurations:</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    compileOnly <span class=\"string\">&quot;org.springframework.boot:spring-boot-autoconfigure-processor&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Starter-module\"><a href=\"#Starter-module\" class=\"headerlink\" title=\"Starter module\"></a>Starter module</h2><p>The starter is really an empty jar. Its only purpose is to provide the necessary dependencies to work with the library. You can think of it as an opinionated view of what is required to get started.</p>\n<p>Do not make assumptions about the project in which your starter is added. If the library you are auto-configuring typically requires other starters, mention them as well. Providing a proper set of <em>default</em> dependencies may be hard if the number of optional dependencies is high, as you should avoid including dependencies that are unnecessary for a typical usage of the library. In other words, you should not include optional dependencies.</p>\n<blockquote>\n<p>NOTE: Either way, your starter must reference the core Spring Boot starter (spring-boot-starter) directly or indirectly (there is no need to add it if your starter relies on another starter). If a project is created with only your custom starter, Spring Boot’s core features will be honoured by the presence of the core starter.</p>\n</blockquote>\n<p>至此, 创建自己的starter并没有完成, 以上只是记录一下spring boot相关的重要的话, 接下来将会在<code>E:\\SpringProjects\\PracticeProjects\\spring-boot-practice-auto-configuration</code>中先进行实战, 对照着<code>E:\\SpringProjects\\PracticeProjects\\spring-boot-master-auto-configuration</code>项目的git log一步一步来. 但是要替换<code>spring-boot-master-auto-configuration</code>中的<code>hornetq</code>为<code>redis</code>, 所以先进行redis的学习.</p>\n"},{"title":"Spring IoC基础","date":"2021-09-28T07:08:10.000Z","_content":"\n为了方便, 通篇的例子都采用这个模型, 订单, 订单产品, 订单地址的关系, 订单需要依赖订单地址和产品等信息. 一般需要在构造函数中构造Order\n```Java\npublic class Order {\n    private InterfaceItem orderItem;\n    private InterfaceAddress orderAddress;\n    // ...\n    Order (InterfaceItem orderItem, InterfaceAddress orderAddress, ...) {\n        this.orderItem = orderItem;\n        this.orderAddress = orderAddress;\n        // ...\n    }\n\n    public persistOrderData() {\n        this.save();\n    }\n}\npublic AmazonOrderItem implements InterfaceItem {\n    // ...\n}\npublic AmazonOrderAddress implements InterfaceItem {\n    // ...\n}\n```\n\n## IoC是如何诞生的\nIoC中文被翻译为\"控制反转\", 一直都让我一头雾水, 软件工程师取名总是带着一种\"我提出了一个改变世界的概念\"的感觉, 不实在. 老外取得名, 在翻译为中文, 更增加了神秘感.\n得到一个类的实例, 只有一个办法, 就是new YourClass(). 在只有没有Spring框架的时代, 随着业务逻辑的增加, 类中的属性越来越多,当我们要得到实例时, 发现要提前准备很多很多对象, 比如: new YourClass(obj_1, obj_2, obj_3, ...), 这些obj_n都是通过new得到的.\n当人们把很多项目放在一起比较发现, 这些\"new操作\", 其实是一种高级别的相似, 那么就可以\"抽出它们像的部分\", 让机器帮助我们干这些活.于是, 有人能够把我们需要的某个依赖对象\"主动\"送过来, 而不是我们自己去new, 所以就是\"控制反转\".\n达到的目的就是\"依赖注入\", 将依赖对象注入到被注入对象中.\n注入的方式有三种, 接口注入(废弃), 构造器注入, setter注入(推荐)\n\n\n## IoC Service Provider与BeanFactory支持的XML配置\n通常被大家称为IoC容器. IoC Service Provider职责只有两个, 业务对象的构建和业务对象之间的依赖绑定. 也就是记录依赖关系, 据此生成业务对象.\n\nSpring的IoC容器是一个IoC Service Provider, 提供了两种类型的支持: BeanFactory和ApplicationContext. 其中ApplicationContext基于BeanFactory, 提供了事件发布等功能.\n\nSpring提倡使用POJO, 每个业务对象看做是一个JavaBean. 只有纳入Spring管理的这些类才能看做是业务对象, 如何纳入Spring管理, 就是这些类上有`@Configuration`, `@Component`, `@Service`等注解. 要是定义了一个普通的类, 那么这并不能归IoC容器管辖.\n\n很久以前, 我们基本上都使用XML进行依赖关系的记录, 通过XML很好的给我们展现了, 依赖的树形关系, 先完成类的声明, 然后对应编写XML, 比如: \n```xml\n<bean id=\"order\" class=\"..Order\">\n    <property name=\"orderItem\">\n        <ref bean=\"amazonOrderItem\">\n    </property>\n    <property name=\"orderAddress\">\n        <ref bean=\"amazonOrderAddress\">\n    </property>\n</bean>\n<bean id=\"amazonOrderItem\" class=\"..impl.AmazonOrderItem\"></bean>\n<bean id=\"amazonOrderAddress\" class=\"..impl.AmazonOrderAddress\"></bean>\n```\n\n以下列举了BeanFactory接口源码(重载方法没有列出)\n```java\npackage org.springframework.beans.factory;\n/**\n * The root interface for accessing a Spring bean container.\n * This is the basic client view of a bean container;\n * \n */\npublic interface BeanFactory {\n\tString FACTORY_BEAN_PREFIX = \"&\";\n\n\t/**\n\t * Return an instance, which may be shared or independent, of the specified bean.\n\t */\n\tObject getBean(String name) throws BeansException;\n\t<T> ObjectProvider<T> getBeanProvider(Class<T> requiredType);\n\tboolean containsBean(String name);\n\tboolean isSingleton(String name) throws NoSuchBeanDefinitionException;\n\tboolean isPrototype(String name) throws NoSuchBeanDefinitionException;\n\tboolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;\n\t@Nullable\n\tClass<?> getType(String name) throws NoSuchBeanDefinitionException;\n\tString[] getAliases(String name);\n}\n\n/** \n  * 其中\"prototype\", \"singleton\"是bean的scope属性两种类型值\n  * 拥有prototype scope的bean定义, 容器在接到该类型对象的请求时, 会每次都重新生成一个新的对象实例给请求方\n  * 这有助于理解BeanFactory中两个方法的意义\n  **/\n```\n在拥有了BeanFactory之后, 我们将\"生产图纸\"交给BeanFactory, 让其为我们生产一个业务对象即可:\n```java\nBeanFactory container = new XmlBeanFacotry(new ClassPathResource(\"XML_PATH\"));\n/**\n * 或者使用ApplicationContext\n * ApplicationContext container = new ClassPathXmlApplication(\"XML_PATH\");\n**/\nOrder order = (Order)container.getBean(\"order\");\norder.persistOrderData();\n```\n\n综上, IoC容器, 或者具体点BeanFactory, 完成了, 注册/绑定->生产对象, 三个步骤. 这就是IoC的所有目的了.每个业务对象作为个体, 在Spring的XML配置文件中是</bean>元素一一对应的, 只要我们了解了单个业务对象是如何配置的, 那么剩下的就是\"依葫芦画瓢\".\n\n### 工厂方法\n这里额外介绍一下工厂方法. 在强调面向接口编程的同时, 有一点需要注意: **虽然对象可以通过声明接口来避免对特定接口实现类的过度耦合**, 但总归需要一种方式将声明依赖接口的对象与接口实现类关联起来,. 只依赖一个不做任何事情的接口是没有任何用处的.\n```java\npublic class Foo {\n    private BarInterface barInterface;\n    public Foo() {\n        // 我们应该避免这样做\n        // instance = new BarInterfaceImpl();\n    }\n}\n```\n如果以上类Foo是由我们自定义的, 我们可以在其上`@Component`或者`@Service`纳入Spring IoC容器管理, 让容器帮我们解除接口和实现类之间的耦合性. 但是, 如果BarInterface来自于第三方库, 接口与实现类的耦合性需要其他方式来避免. 这是我们可以写一个工厂方法(Factory Method), 提供一个工厂类来实例化具体接口实现类. Foo类只需要依赖于工厂类, 当实现类有变更的时候, 只是变更工厂类, Foo类代码不需要做出任何变动.\n```java\npublic class Foo {\n    private BarInterface barInterface;\n    public Foo() {\n        // 静态工厂\n        // barInterface = BarInterfaceFactory.getInterface()\n        // 或者, 非静态工厂\n        // barInterface = new BarInterfaceFactory().getInstance();\n    }\n}\n// 以上操作实际上是在BarInterface与实现类之间加了一层而已. 美其名曰: \"解除耦合\".\n```\n在XML中, 我们可以这样声明, 将这个工厂方法交给Spring容器管理\n```xml\n<bean id=\"foo\" class=\"...Foo\">\n    <property name=\"barInterface\">\n        <ref bean=\"bar\">\n    </property>\n</bean>\n<bean id=\"bar\" class=\"...StaticBarInterfaceFactory\" factory-method=\"getInstance\">\n```\nfactory-method指定工厂方法名, 然后容器调用静态方法getInstance. 也就是说, 为对象foo注入的bar对象实际是BarInterfaceImpl的实例.\n\n## 容器背后的秘密\nSpring IoC容器实现其功能, 基本上可以按照类似的流程分为两个阶段: 容器启动阶段和Bean实例化阶段\n> 容器启动阶段: 加载配置 > 分析配置信息 > 装备到BeanDefinition > 其他后处理 ...\n- 容器需要依赖BeanDefinitionReader对加载的Configuration MetaData就行解析和处理, 最后注册到BeanDefinitionRegistory\n> Bean实例化阶段: 实例化对象 > 装配依赖 > 生命周期回调 > 对象其他处理 > 注册回调接口 ...\n- 所有的Bean定义都通过BeanDefinition的方式注册到了BeanDefinitionRegistry中. 当某个请求通过容器getBean时, 就会触发第二阶段\n\n第一阶段是图纸装配, 第二阶段是使用装配好的生产线生产具体的产品.\n\n### 图纸装配\n\"图纸装配\"从一般的逻辑上来讲要经历, 这几个阶段: 读文件 -> 将文件中的占位符替换 -> 文件中的字符串进行类型装换\nSpring容器提供了一种叫做BeanFactoryProcessor接口, 一个容器可以有多个BeanFactoryPostProcessor. 比如: \n- PropertyPlaceholderConfigurer, 作用是将占位符替换为properties文件中声明的值.\n- CustomEditorConfigurer, 将XML格式文件中读取的字符串形式的值进行转换. 具体实现是通过Spring内部提供的JavaBean的PropertyEditor来帮助进行String类型到其他类型的转换, 比如: StringArrayPropertyEditor(将逗号分隔的字符串转为String[]), ClassEditor(根据String类型的class名称, 转换为相应的class对象, 相当于Class.forName(String))等等.\n\n> 插一句, 如果让我去组织这些Processor的话, 我会采用Django框架中middleware的做法, 首先按照顺序列好这些Processor, 然后一个一个执行, PropertyPlaceholderConfigurer > CustomEditorConfigurer > ...等等, 每个Processor完成一个步骤, 最后装配成功. 我想Spring框架也会采用这样的办法, 毕竟我们在将Bean注册到Spring容器的时候, 都是可以设置顺序的.\n\n### 生产产品\n容器启动之后, 并不会马上进行实例化Bean. 容器现在拥有对象的BeanDefinition来存储实例化必要信息. 当通过BeanFactory.getBean()方法来请求某个对象实例时, 才可能触发Bean实例化阶段的活动. \n\n#### Bean的实例化与BeanWrapper\n容器在内部实现的时候, 采用\"策略模式(Strategy Pattern)\"来决定使用何种方式初始化bean实例, 通常是通过反射或者CGLIB动态字节码来生成bean实例, 或者其子类. 默认情况下, 容器采用的是CglibSubclassingInstantiationStrategy.\n\n按照正常的逻辑, 容器只需要根据BeanDefintion取得实例化信息, 结合CglibInstantiationStrategy返回对象实例. 但是, 这里的做法不是直接返回构造完成的实例, 而是以BeanWrapper对构造完成的对象实例进行包裹, 返回相应的BeanWrapper实例. \n```java\nObject order = Class.forName(\"package.name.Order\").newInstance();\nObject orderItem = Class.forName(\"package.name.AmazonOrderItem\").newInstance();\nObject orderAddress = Class.forName(\"package.name.AmazonOrderAddress\").newInstace();\n\nBeanWrapper newOrder = new BeanWrapperImpl(order);\nnewOrder.setPropertyValue(\"newOrderItem\", orderItem);\nnewOrder.setPropertyValue(\"newOrderAddress\", orderAddress);\n\nassertTrue(newOrder.getWrappedInstance() instanceof Order);\nassertSame(order, newOrder.getWrappedInstance());\nassertSame(orderItem, newOrder.getPropertyValue(\"newOrderItem\"));\nassertSame(orderAddress, newOrder.getPropertyValue(\"newOrderAddress\"));\n```\n针对以上示例, 截一段源码, BeanWrapperImpl是实现类, 这里调用的都是父类AbstractNestablePropertyAccessor的方法.\n```java\npackage org.springframework.beans;\npublic class BeanWrapperImpl extends AbstractNestablePropertyAccessor implements BeanWrapper {\n    // ...\n    public BeanWrapperImpl(Object object) {\n\t\tsuper(object);\n\t}\n    // ...\n}\n// ...\npublic abstract class AbstractNestablePropertyAccessor extends AbstractPropertyAccessor {\n    @Nullable\n\tObject wrappedObject;\n    // ...\n    public final Object getWrappedInstance() {\n\t\tAssert.state(this.wrappedObject != null, \"No wrapped object\");\n\t\treturn this.wrappedObject;\n\t}\n    protected AbstractNestablePropertyAccessor(Object object) {\n\t\tregisterDefaultEditors();\n\t\tsetWrappedInstance(object);\n\t}\n    public void setWrappedInstance(Object object) {\n\t\tsetWrappedInstance(object, \"\", null);\n\t}\n    public void setWrappedInstance(Object object, @Nullable String nestedPath, @Nullable Object rootObject) {\n\t\tthis.wrappedObject = ObjectUtils.unwrapOptional(object);\n\t\t// ...\n\t}\n    @Override\n\tpublic void setPropertyValue(String propertyName, @Nullable Object value) throws BeansException {\n\t\t// ... 这里用了很多反射的方法.\n\t}\n    // ...\n}\n```\n如果粗略的看没有什么复杂的逻辑, 但是里边的细节很多, 要是让我去写Spring的架构, 最终要的是接口的设计, 层次的划分, 以及需求的抽象. \n\n#### 给实例注入依赖对象\n上一步我们已经将, 属性set到了bean实例上, 但是没有赋值. Spring容器会检查当前实例实现了哪个Aware命名结尾的接口, 然后将对应Aware接口中对顶的依赖注入进去.\n比如, BeanNameAware, 如果Spring容器检测到当前对象实例实现了该接口, 会将该对象实例的bean定义对应的beanName设置到当前实例. BeanClassLoaderAware, 会将当前bean的ClassLoader注入当前对象实例.\n\n#### 对实例进行前(后)置处理\n现在依赖注入已经完成, 那么接下来可以对实例进行后置处理(hook), Spring提供了侵入的办法, 就是BeanPostProcessor. \nBeanPostProcessor与BeanFactoryPostProcessor容器混淆. 只要记住BeanPostProcessor存在于对象实例化阶段, 而BeanFactoryPostProcessor存在于容器启动阶段. BeanPostProcessor会处理容器内所有符合条件的实例化后的对象实例. 该接口很简单, 从方法的命名上就可以看出其意义, 一个可以唤作前置处理, 一个唤作后置处理:\n```java\npackage org.springframework.beans.factory.config;\n\nimport org.springframework.beans.BeansException;\nimport org.springframework.lang.Nullable;\n\n/**\n * Factory hook that allows for custom modification of new bean instances,\n * e.g. checking for marker interfaces or wrapping them with proxies.\n *\n * <p>ApplicationContexts can autodetect BeanPostProcessor beans in their\n * bean definitions and apply them to any beans subsequently created.\n * Plain bean factories allow for programmatic registration of post-processors,\n * applying to all beans created through this factory.\n *\n * <p>Typically, post-processors that populate beans via marker interfaces\n * or the like will implement {@link #postProcessBeforeInitialization},\n * while post-processors that wrap beans with proxies will normally\n * implement {@link #postProcessAfterInitialization}.\n *\n * @author Juergen Hoeller\n * @since 10.10.2003\n * @see InstantiationAwareBeanPostProcessor\n * @see DestructionAwareBeanPostProcessor\n * @see ConfigurableBeanFactory#addBeanPostProcessor\n * @see BeanFactoryPostProcessor\n */\npublic interface BeanPostProcessor {\n\n\t/**\n\t * Apply this BeanPostProcessor to the given new bean instance <i>before</i> any bean\n\t * initialization callbacks (like InitializingBean's {@code afterPropertiesSet}\n\t * or a custom init-method). The bean will already be populated with property values.\n\t * The returned bean instance may be a wrapper around the original.\n\t * <p>The default implementation returns the given {@code bean} as-is.\n\t * @param bean the new bean instance\n\t * @param beanName the name of the bean\n\t * @return the bean instance to use, either the original or a wrapped one;\n\t * if {@code null}, no subsequent BeanPostProcessors will be invoked\n\t * @throws org.springframework.beans.BeansException in case of errors\n\t * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet\n\t */\n\t@Nullable\n\tdefault Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\treturn bean;\n\t}\n\n\t/**\n\t * Apply this BeanPostProcessor to the given new bean instance <i>after</i> any bean\n\t * initialization callbacks (like InitializingBean's {@code afterPropertiesSet}\n\t * or a custom init-method). The bean will already be populated with property values.\n\t * The returned bean instance may be a wrapper around the original.\n\t * <p>In case of a FactoryBean, this callback will be invoked for both the FactoryBean\n\t * instance and the objects created by the FactoryBean (as of Spring 2.0). The\n\t * post-processor can decide whether to apply to either the FactoryBean or created\n\t * objects or both through corresponding {@code bean instanceof FactoryBean} checks.\n\t * <p>This callback will also be invoked after a short-circuiting triggered by a\n\t * {@link InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation} method,\n\t * in contrast to all other BeanPostProcessor callbacks.\n\t * <p>The default implementation returns the given {@code bean} as-is.\n\t * @param bean the new bean instance\n\t * @param beanName the name of the bean\n\t * @return the bean instance to use, either the original or a wrapped one;\n\t * if {@code null}, no subsequent BeanPostProcessors will be invoked\n\t * @throws org.springframework.beans.BeansException in case of errors\n\t * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet\n\t * @see org.springframework.beans.factory.FactoryBean\n\t */\n\t@Nullable\n\tdefault Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t\treturn bean;\n\t}\n\n}\n```\n我们也可以自定义BeanPostProcessor, 定义一个类implements BeanPostProcessor, 来把自己的逻辑侵入到bean实例化的过程当中去.\n\n#### InitialzingBean和init-method\n```java\npackage org.springframework.beans.factory;\n\n/**\n * Interface to be implemented by beans that need to react once all their properties\n * have been set by a {@link BeanFactory}: e.g. to perform custom initialization,\n * or merely to check that all mandatory properties have been set.\n *\n * <p>An alternative to implementing {@code InitializingBean} is specifying a custom\n * init method, for example in an XML bean definition. For a list of all bean\n * lifecycle methods, see the {@link BeanFactory BeanFactory javadocs}.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @see DisposableBean\n * @see org.springframework.beans.factory.config.BeanDefinition#getPropertyValues()\n * @see org.springframework.beans.factory.support.AbstractBeanDefinition#getInitMethodName()\n */\npublic interface InitializingBean {\n\n\t/**\n\t * Invoked by the containing {@code BeanFactory} after it has set all bean properties\n\t * and satisfied {@link BeanFactoryAware}, {@code ApplicationContextAware} etc.\n\t * <p>This method allows the bean instance to perform validation of its overall\n\t * configuration and final initialization when all bean properties have been set.\n\t * @throws Exception in the event of misconfiguration (such as failure to set an\n\t * essential property) or if initialization fails for any other reason\n\t */\n\tvoid afterPropertiesSet() throws Exception;\n\n}\n```\nInitializingBean的作用在于, 对象实例化调用过\"BeanPostProcessor的前置处理\"方法之后, 会接着检测对象是否实现了InitializingBean接口, 如果是, 就会调用afterPropertiesSet()方法进一步调整对象实例的状态. \n但是, 以上操作显得Spring容器比较具有侵入性, 那么Spring还提供了另一种方式, 那就是在XML的`<bean>`标签中配置init-method, 可以认为在InitializingBean和init-method中任选其一帮助你完成类似的初始化工作.\n> 到这里我不仅感叹, 这篇博客是我对《Spring揭秘》的读书和实践的笔记, 可能大部分书籍的文字都来源于对Spring源码中注释的解读.\n\n#### DisposableBean与destroy-method\n同样地, 当所有的一切, 该设置的设置, 该注入的注入, 该调用的调用完成之后, 容器会检查singleton类型的bean实例, 是否实现了DisposableBean接口. 或者对应的bean在`<bean>`里定义了destory-method. 是的话, 就会为该实例注册一个用于对象销毁的回调(Callback), 以便这些singleton类型的对象实例销毁之前, 执行销毁逻辑.\n> 容器不会去管理, scope为prototype类型的bean实例.\n\n\n## 使用注解代替XML\n在XML配置成功的基础上, 引入了注解来减少冗余操作.\n`@Autowired`四基于注解的依赖注入的核心注解. 它们都是触发容器对相应对象给与依赖注入的标志. `@Autowired`是按照类型匹配进行依赖注入的. 现在, 容器的配置文件就只剩下一个个孤零零的bean定义了.\n\n有了注解必须得有Annotation Processor, 要不然注解和注释没什么区别, Spring提供了AutowiredAnnotationBeanPostProcessor来得到这一目的. 通过反射检查每个bean定义对应的类上的各种可能位置上的`@Autowired`. 存在, 就从当前容器管理的对象中获取符合条件的对象, 设置给`@Autowired`锁标注的属性或方法. 伪代码如下: \n```java\nObject[] beans = ...;\nfor (Objec bean: beans) {\n    if(autowiredExistsOnField(bean)){\n        Field f = getQulifiedField(bean);\n        setAccessiableIfNeccessary(f);\n        f.set(getBeanByTypeFromContainer());\n    }\n    if(autowiredExistsOnMethod(bean)) {\n        // ...\n    }\n    // ...\n}\n```\n\n如果当前的`@Autowired`标注的依赖在容器中找到了两个以上的实例的话, 就需要@Qualifier的配合, 出入自定义的name(String)条件作出进一步限定. `@Qualifier`实际上是byName自动绑定的注解版.\n\n#### classpath-scanning\n到目前为止, 我们已经通过注解将依赖关系xml定义转移到了源码中. 为了\"一套代码, 一处定义\"的理念, 要将革命进行彻底. classpath-scanning的诞生!\n使用相应的注解(`@Component`, `@Service`, `@Configuration`)进行标注之后, classpath-scanning功能从某一顶层包(base package)开始扫描, 当扫描到相应的注解之后, 就会提取该类的信息, 构建对应的BeanDefinition, 然后把构建完成的BeanDefinition注册到容器. \nclasspath-scanning由`<context:component-scan>`决定. `<context:component-scan>`默认扫描的注解时`@Component`. 其中, 在@Component语义的基础上细化后又有了`@Repository`, `@Service`/`@Controller`, 他们同样都会被扫描. `@Component`的语义更宽泛, 而`@Service`以及`@Repository`等更具体. 另外, 对于服务层类定义来说, 使用`@Service`标注它, 比`@Component`更加确切.\n\n\n学习Spring框架, 是不是要抓住Spring中几个大的接口来进行, 比如BeanFactory, BeanPostProcessor等, 毕竟是面向接口的编程. \n\n","source":"_posts/spring-ioc.md","raw":"---\ntitle: Spring IoC基础\ndate: 2021-09-28 15:08:10\ncategories: \n- Spring\n---\n\n为了方便, 通篇的例子都采用这个模型, 订单, 订单产品, 订单地址的关系, 订单需要依赖订单地址和产品等信息. 一般需要在构造函数中构造Order\n```Java\npublic class Order {\n    private InterfaceItem orderItem;\n    private InterfaceAddress orderAddress;\n    // ...\n    Order (InterfaceItem orderItem, InterfaceAddress orderAddress, ...) {\n        this.orderItem = orderItem;\n        this.orderAddress = orderAddress;\n        // ...\n    }\n\n    public persistOrderData() {\n        this.save();\n    }\n}\npublic AmazonOrderItem implements InterfaceItem {\n    // ...\n}\npublic AmazonOrderAddress implements InterfaceItem {\n    // ...\n}\n```\n\n## IoC是如何诞生的\nIoC中文被翻译为\"控制反转\", 一直都让我一头雾水, 软件工程师取名总是带着一种\"我提出了一个改变世界的概念\"的感觉, 不实在. 老外取得名, 在翻译为中文, 更增加了神秘感.\n得到一个类的实例, 只有一个办法, 就是new YourClass(). 在只有没有Spring框架的时代, 随着业务逻辑的增加, 类中的属性越来越多,当我们要得到实例时, 发现要提前准备很多很多对象, 比如: new YourClass(obj_1, obj_2, obj_3, ...), 这些obj_n都是通过new得到的.\n当人们把很多项目放在一起比较发现, 这些\"new操作\", 其实是一种高级别的相似, 那么就可以\"抽出它们像的部分\", 让机器帮助我们干这些活.于是, 有人能够把我们需要的某个依赖对象\"主动\"送过来, 而不是我们自己去new, 所以就是\"控制反转\".\n达到的目的就是\"依赖注入\", 将依赖对象注入到被注入对象中.\n注入的方式有三种, 接口注入(废弃), 构造器注入, setter注入(推荐)\n\n\n## IoC Service Provider与BeanFactory支持的XML配置\n通常被大家称为IoC容器. IoC Service Provider职责只有两个, 业务对象的构建和业务对象之间的依赖绑定. 也就是记录依赖关系, 据此生成业务对象.\n\nSpring的IoC容器是一个IoC Service Provider, 提供了两种类型的支持: BeanFactory和ApplicationContext. 其中ApplicationContext基于BeanFactory, 提供了事件发布等功能.\n\nSpring提倡使用POJO, 每个业务对象看做是一个JavaBean. 只有纳入Spring管理的这些类才能看做是业务对象, 如何纳入Spring管理, 就是这些类上有`@Configuration`, `@Component`, `@Service`等注解. 要是定义了一个普通的类, 那么这并不能归IoC容器管辖.\n\n很久以前, 我们基本上都使用XML进行依赖关系的记录, 通过XML很好的给我们展现了, 依赖的树形关系, 先完成类的声明, 然后对应编写XML, 比如: \n```xml\n<bean id=\"order\" class=\"..Order\">\n    <property name=\"orderItem\">\n        <ref bean=\"amazonOrderItem\">\n    </property>\n    <property name=\"orderAddress\">\n        <ref bean=\"amazonOrderAddress\">\n    </property>\n</bean>\n<bean id=\"amazonOrderItem\" class=\"..impl.AmazonOrderItem\"></bean>\n<bean id=\"amazonOrderAddress\" class=\"..impl.AmazonOrderAddress\"></bean>\n```\n\n以下列举了BeanFactory接口源码(重载方法没有列出)\n```java\npackage org.springframework.beans.factory;\n/**\n * The root interface for accessing a Spring bean container.\n * This is the basic client view of a bean container;\n * \n */\npublic interface BeanFactory {\n\tString FACTORY_BEAN_PREFIX = \"&\";\n\n\t/**\n\t * Return an instance, which may be shared or independent, of the specified bean.\n\t */\n\tObject getBean(String name) throws BeansException;\n\t<T> ObjectProvider<T> getBeanProvider(Class<T> requiredType);\n\tboolean containsBean(String name);\n\tboolean isSingleton(String name) throws NoSuchBeanDefinitionException;\n\tboolean isPrototype(String name) throws NoSuchBeanDefinitionException;\n\tboolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;\n\t@Nullable\n\tClass<?> getType(String name) throws NoSuchBeanDefinitionException;\n\tString[] getAliases(String name);\n}\n\n/** \n  * 其中\"prototype\", \"singleton\"是bean的scope属性两种类型值\n  * 拥有prototype scope的bean定义, 容器在接到该类型对象的请求时, 会每次都重新生成一个新的对象实例给请求方\n  * 这有助于理解BeanFactory中两个方法的意义\n  **/\n```\n在拥有了BeanFactory之后, 我们将\"生产图纸\"交给BeanFactory, 让其为我们生产一个业务对象即可:\n```java\nBeanFactory container = new XmlBeanFacotry(new ClassPathResource(\"XML_PATH\"));\n/**\n * 或者使用ApplicationContext\n * ApplicationContext container = new ClassPathXmlApplication(\"XML_PATH\");\n**/\nOrder order = (Order)container.getBean(\"order\");\norder.persistOrderData();\n```\n\n综上, IoC容器, 或者具体点BeanFactory, 完成了, 注册/绑定->生产对象, 三个步骤. 这就是IoC的所有目的了.每个业务对象作为个体, 在Spring的XML配置文件中是</bean>元素一一对应的, 只要我们了解了单个业务对象是如何配置的, 那么剩下的就是\"依葫芦画瓢\".\n\n### 工厂方法\n这里额外介绍一下工厂方法. 在强调面向接口编程的同时, 有一点需要注意: **虽然对象可以通过声明接口来避免对特定接口实现类的过度耦合**, 但总归需要一种方式将声明依赖接口的对象与接口实现类关联起来,. 只依赖一个不做任何事情的接口是没有任何用处的.\n```java\npublic class Foo {\n    private BarInterface barInterface;\n    public Foo() {\n        // 我们应该避免这样做\n        // instance = new BarInterfaceImpl();\n    }\n}\n```\n如果以上类Foo是由我们自定义的, 我们可以在其上`@Component`或者`@Service`纳入Spring IoC容器管理, 让容器帮我们解除接口和实现类之间的耦合性. 但是, 如果BarInterface来自于第三方库, 接口与实现类的耦合性需要其他方式来避免. 这是我们可以写一个工厂方法(Factory Method), 提供一个工厂类来实例化具体接口实现类. Foo类只需要依赖于工厂类, 当实现类有变更的时候, 只是变更工厂类, Foo类代码不需要做出任何变动.\n```java\npublic class Foo {\n    private BarInterface barInterface;\n    public Foo() {\n        // 静态工厂\n        // barInterface = BarInterfaceFactory.getInterface()\n        // 或者, 非静态工厂\n        // barInterface = new BarInterfaceFactory().getInstance();\n    }\n}\n// 以上操作实际上是在BarInterface与实现类之间加了一层而已. 美其名曰: \"解除耦合\".\n```\n在XML中, 我们可以这样声明, 将这个工厂方法交给Spring容器管理\n```xml\n<bean id=\"foo\" class=\"...Foo\">\n    <property name=\"barInterface\">\n        <ref bean=\"bar\">\n    </property>\n</bean>\n<bean id=\"bar\" class=\"...StaticBarInterfaceFactory\" factory-method=\"getInstance\">\n```\nfactory-method指定工厂方法名, 然后容器调用静态方法getInstance. 也就是说, 为对象foo注入的bar对象实际是BarInterfaceImpl的实例.\n\n## 容器背后的秘密\nSpring IoC容器实现其功能, 基本上可以按照类似的流程分为两个阶段: 容器启动阶段和Bean实例化阶段\n> 容器启动阶段: 加载配置 > 分析配置信息 > 装备到BeanDefinition > 其他后处理 ...\n- 容器需要依赖BeanDefinitionReader对加载的Configuration MetaData就行解析和处理, 最后注册到BeanDefinitionRegistory\n> Bean实例化阶段: 实例化对象 > 装配依赖 > 生命周期回调 > 对象其他处理 > 注册回调接口 ...\n- 所有的Bean定义都通过BeanDefinition的方式注册到了BeanDefinitionRegistry中. 当某个请求通过容器getBean时, 就会触发第二阶段\n\n第一阶段是图纸装配, 第二阶段是使用装配好的生产线生产具体的产品.\n\n### 图纸装配\n\"图纸装配\"从一般的逻辑上来讲要经历, 这几个阶段: 读文件 -> 将文件中的占位符替换 -> 文件中的字符串进行类型装换\nSpring容器提供了一种叫做BeanFactoryProcessor接口, 一个容器可以有多个BeanFactoryPostProcessor. 比如: \n- PropertyPlaceholderConfigurer, 作用是将占位符替换为properties文件中声明的值.\n- CustomEditorConfigurer, 将XML格式文件中读取的字符串形式的值进行转换. 具体实现是通过Spring内部提供的JavaBean的PropertyEditor来帮助进行String类型到其他类型的转换, 比如: StringArrayPropertyEditor(将逗号分隔的字符串转为String[]), ClassEditor(根据String类型的class名称, 转换为相应的class对象, 相当于Class.forName(String))等等.\n\n> 插一句, 如果让我去组织这些Processor的话, 我会采用Django框架中middleware的做法, 首先按照顺序列好这些Processor, 然后一个一个执行, PropertyPlaceholderConfigurer > CustomEditorConfigurer > ...等等, 每个Processor完成一个步骤, 最后装配成功. 我想Spring框架也会采用这样的办法, 毕竟我们在将Bean注册到Spring容器的时候, 都是可以设置顺序的.\n\n### 生产产品\n容器启动之后, 并不会马上进行实例化Bean. 容器现在拥有对象的BeanDefinition来存储实例化必要信息. 当通过BeanFactory.getBean()方法来请求某个对象实例时, 才可能触发Bean实例化阶段的活动. \n\n#### Bean的实例化与BeanWrapper\n容器在内部实现的时候, 采用\"策略模式(Strategy Pattern)\"来决定使用何种方式初始化bean实例, 通常是通过反射或者CGLIB动态字节码来生成bean实例, 或者其子类. 默认情况下, 容器采用的是CglibSubclassingInstantiationStrategy.\n\n按照正常的逻辑, 容器只需要根据BeanDefintion取得实例化信息, 结合CglibInstantiationStrategy返回对象实例. 但是, 这里的做法不是直接返回构造完成的实例, 而是以BeanWrapper对构造完成的对象实例进行包裹, 返回相应的BeanWrapper实例. \n```java\nObject order = Class.forName(\"package.name.Order\").newInstance();\nObject orderItem = Class.forName(\"package.name.AmazonOrderItem\").newInstance();\nObject orderAddress = Class.forName(\"package.name.AmazonOrderAddress\").newInstace();\n\nBeanWrapper newOrder = new BeanWrapperImpl(order);\nnewOrder.setPropertyValue(\"newOrderItem\", orderItem);\nnewOrder.setPropertyValue(\"newOrderAddress\", orderAddress);\n\nassertTrue(newOrder.getWrappedInstance() instanceof Order);\nassertSame(order, newOrder.getWrappedInstance());\nassertSame(orderItem, newOrder.getPropertyValue(\"newOrderItem\"));\nassertSame(orderAddress, newOrder.getPropertyValue(\"newOrderAddress\"));\n```\n针对以上示例, 截一段源码, BeanWrapperImpl是实现类, 这里调用的都是父类AbstractNestablePropertyAccessor的方法.\n```java\npackage org.springframework.beans;\npublic class BeanWrapperImpl extends AbstractNestablePropertyAccessor implements BeanWrapper {\n    // ...\n    public BeanWrapperImpl(Object object) {\n\t\tsuper(object);\n\t}\n    // ...\n}\n// ...\npublic abstract class AbstractNestablePropertyAccessor extends AbstractPropertyAccessor {\n    @Nullable\n\tObject wrappedObject;\n    // ...\n    public final Object getWrappedInstance() {\n\t\tAssert.state(this.wrappedObject != null, \"No wrapped object\");\n\t\treturn this.wrappedObject;\n\t}\n    protected AbstractNestablePropertyAccessor(Object object) {\n\t\tregisterDefaultEditors();\n\t\tsetWrappedInstance(object);\n\t}\n    public void setWrappedInstance(Object object) {\n\t\tsetWrappedInstance(object, \"\", null);\n\t}\n    public void setWrappedInstance(Object object, @Nullable String nestedPath, @Nullable Object rootObject) {\n\t\tthis.wrappedObject = ObjectUtils.unwrapOptional(object);\n\t\t// ...\n\t}\n    @Override\n\tpublic void setPropertyValue(String propertyName, @Nullable Object value) throws BeansException {\n\t\t// ... 这里用了很多反射的方法.\n\t}\n    // ...\n}\n```\n如果粗略的看没有什么复杂的逻辑, 但是里边的细节很多, 要是让我去写Spring的架构, 最终要的是接口的设计, 层次的划分, 以及需求的抽象. \n\n#### 给实例注入依赖对象\n上一步我们已经将, 属性set到了bean实例上, 但是没有赋值. Spring容器会检查当前实例实现了哪个Aware命名结尾的接口, 然后将对应Aware接口中对顶的依赖注入进去.\n比如, BeanNameAware, 如果Spring容器检测到当前对象实例实现了该接口, 会将该对象实例的bean定义对应的beanName设置到当前实例. BeanClassLoaderAware, 会将当前bean的ClassLoader注入当前对象实例.\n\n#### 对实例进行前(后)置处理\n现在依赖注入已经完成, 那么接下来可以对实例进行后置处理(hook), Spring提供了侵入的办法, 就是BeanPostProcessor. \nBeanPostProcessor与BeanFactoryPostProcessor容器混淆. 只要记住BeanPostProcessor存在于对象实例化阶段, 而BeanFactoryPostProcessor存在于容器启动阶段. BeanPostProcessor会处理容器内所有符合条件的实例化后的对象实例. 该接口很简单, 从方法的命名上就可以看出其意义, 一个可以唤作前置处理, 一个唤作后置处理:\n```java\npackage org.springframework.beans.factory.config;\n\nimport org.springframework.beans.BeansException;\nimport org.springframework.lang.Nullable;\n\n/**\n * Factory hook that allows for custom modification of new bean instances,\n * e.g. checking for marker interfaces or wrapping them with proxies.\n *\n * <p>ApplicationContexts can autodetect BeanPostProcessor beans in their\n * bean definitions and apply them to any beans subsequently created.\n * Plain bean factories allow for programmatic registration of post-processors,\n * applying to all beans created through this factory.\n *\n * <p>Typically, post-processors that populate beans via marker interfaces\n * or the like will implement {@link #postProcessBeforeInitialization},\n * while post-processors that wrap beans with proxies will normally\n * implement {@link #postProcessAfterInitialization}.\n *\n * @author Juergen Hoeller\n * @since 10.10.2003\n * @see InstantiationAwareBeanPostProcessor\n * @see DestructionAwareBeanPostProcessor\n * @see ConfigurableBeanFactory#addBeanPostProcessor\n * @see BeanFactoryPostProcessor\n */\npublic interface BeanPostProcessor {\n\n\t/**\n\t * Apply this BeanPostProcessor to the given new bean instance <i>before</i> any bean\n\t * initialization callbacks (like InitializingBean's {@code afterPropertiesSet}\n\t * or a custom init-method). The bean will already be populated with property values.\n\t * The returned bean instance may be a wrapper around the original.\n\t * <p>The default implementation returns the given {@code bean} as-is.\n\t * @param bean the new bean instance\n\t * @param beanName the name of the bean\n\t * @return the bean instance to use, either the original or a wrapped one;\n\t * if {@code null}, no subsequent BeanPostProcessors will be invoked\n\t * @throws org.springframework.beans.BeansException in case of errors\n\t * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet\n\t */\n\t@Nullable\n\tdefault Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t\treturn bean;\n\t}\n\n\t/**\n\t * Apply this BeanPostProcessor to the given new bean instance <i>after</i> any bean\n\t * initialization callbacks (like InitializingBean's {@code afterPropertiesSet}\n\t * or a custom init-method). The bean will already be populated with property values.\n\t * The returned bean instance may be a wrapper around the original.\n\t * <p>In case of a FactoryBean, this callback will be invoked for both the FactoryBean\n\t * instance and the objects created by the FactoryBean (as of Spring 2.0). The\n\t * post-processor can decide whether to apply to either the FactoryBean or created\n\t * objects or both through corresponding {@code bean instanceof FactoryBean} checks.\n\t * <p>This callback will also be invoked after a short-circuiting triggered by a\n\t * {@link InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation} method,\n\t * in contrast to all other BeanPostProcessor callbacks.\n\t * <p>The default implementation returns the given {@code bean} as-is.\n\t * @param bean the new bean instance\n\t * @param beanName the name of the bean\n\t * @return the bean instance to use, either the original or a wrapped one;\n\t * if {@code null}, no subsequent BeanPostProcessors will be invoked\n\t * @throws org.springframework.beans.BeansException in case of errors\n\t * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet\n\t * @see org.springframework.beans.factory.FactoryBean\n\t */\n\t@Nullable\n\tdefault Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t\treturn bean;\n\t}\n\n}\n```\n我们也可以自定义BeanPostProcessor, 定义一个类implements BeanPostProcessor, 来把自己的逻辑侵入到bean实例化的过程当中去.\n\n#### InitialzingBean和init-method\n```java\npackage org.springframework.beans.factory;\n\n/**\n * Interface to be implemented by beans that need to react once all their properties\n * have been set by a {@link BeanFactory}: e.g. to perform custom initialization,\n * or merely to check that all mandatory properties have been set.\n *\n * <p>An alternative to implementing {@code InitializingBean} is specifying a custom\n * init method, for example in an XML bean definition. For a list of all bean\n * lifecycle methods, see the {@link BeanFactory BeanFactory javadocs}.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @see DisposableBean\n * @see org.springframework.beans.factory.config.BeanDefinition#getPropertyValues()\n * @see org.springframework.beans.factory.support.AbstractBeanDefinition#getInitMethodName()\n */\npublic interface InitializingBean {\n\n\t/**\n\t * Invoked by the containing {@code BeanFactory} after it has set all bean properties\n\t * and satisfied {@link BeanFactoryAware}, {@code ApplicationContextAware} etc.\n\t * <p>This method allows the bean instance to perform validation of its overall\n\t * configuration and final initialization when all bean properties have been set.\n\t * @throws Exception in the event of misconfiguration (such as failure to set an\n\t * essential property) or if initialization fails for any other reason\n\t */\n\tvoid afterPropertiesSet() throws Exception;\n\n}\n```\nInitializingBean的作用在于, 对象实例化调用过\"BeanPostProcessor的前置处理\"方法之后, 会接着检测对象是否实现了InitializingBean接口, 如果是, 就会调用afterPropertiesSet()方法进一步调整对象实例的状态. \n但是, 以上操作显得Spring容器比较具有侵入性, 那么Spring还提供了另一种方式, 那就是在XML的`<bean>`标签中配置init-method, 可以认为在InitializingBean和init-method中任选其一帮助你完成类似的初始化工作.\n> 到这里我不仅感叹, 这篇博客是我对《Spring揭秘》的读书和实践的笔记, 可能大部分书籍的文字都来源于对Spring源码中注释的解读.\n\n#### DisposableBean与destroy-method\n同样地, 当所有的一切, 该设置的设置, 该注入的注入, 该调用的调用完成之后, 容器会检查singleton类型的bean实例, 是否实现了DisposableBean接口. 或者对应的bean在`<bean>`里定义了destory-method. 是的话, 就会为该实例注册一个用于对象销毁的回调(Callback), 以便这些singleton类型的对象实例销毁之前, 执行销毁逻辑.\n> 容器不会去管理, scope为prototype类型的bean实例.\n\n\n## 使用注解代替XML\n在XML配置成功的基础上, 引入了注解来减少冗余操作.\n`@Autowired`四基于注解的依赖注入的核心注解. 它们都是触发容器对相应对象给与依赖注入的标志. `@Autowired`是按照类型匹配进行依赖注入的. 现在, 容器的配置文件就只剩下一个个孤零零的bean定义了.\n\n有了注解必须得有Annotation Processor, 要不然注解和注释没什么区别, Spring提供了AutowiredAnnotationBeanPostProcessor来得到这一目的. 通过反射检查每个bean定义对应的类上的各种可能位置上的`@Autowired`. 存在, 就从当前容器管理的对象中获取符合条件的对象, 设置给`@Autowired`锁标注的属性或方法. 伪代码如下: \n```java\nObject[] beans = ...;\nfor (Objec bean: beans) {\n    if(autowiredExistsOnField(bean)){\n        Field f = getQulifiedField(bean);\n        setAccessiableIfNeccessary(f);\n        f.set(getBeanByTypeFromContainer());\n    }\n    if(autowiredExistsOnMethod(bean)) {\n        // ...\n    }\n    // ...\n}\n```\n\n如果当前的`@Autowired`标注的依赖在容器中找到了两个以上的实例的话, 就需要@Qualifier的配合, 出入自定义的name(String)条件作出进一步限定. `@Qualifier`实际上是byName自动绑定的注解版.\n\n#### classpath-scanning\n到目前为止, 我们已经通过注解将依赖关系xml定义转移到了源码中. 为了\"一套代码, 一处定义\"的理念, 要将革命进行彻底. classpath-scanning的诞生!\n使用相应的注解(`@Component`, `@Service`, `@Configuration`)进行标注之后, classpath-scanning功能从某一顶层包(base package)开始扫描, 当扫描到相应的注解之后, 就会提取该类的信息, 构建对应的BeanDefinition, 然后把构建完成的BeanDefinition注册到容器. \nclasspath-scanning由`<context:component-scan>`决定. `<context:component-scan>`默认扫描的注解时`@Component`. 其中, 在@Component语义的基础上细化后又有了`@Repository`, `@Service`/`@Controller`, 他们同样都会被扫描. `@Component`的语义更宽泛, 而`@Service`以及`@Repository`等更具体. 另外, 对于服务层类定义来说, 使用`@Service`标注它, 比`@Component`更加确切.\n\n\n学习Spring框架, 是不是要抓住Spring中几个大的接口来进行, 比如BeanFactory, BeanPostProcessor等, 毕竟是面向接口的编程. \n\n","slug":"spring-ioc","published":1,"updated":"2021-12-30T03:04:59.355Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxsdzpz4001cxotg4oyh0xr2","content":"<p>为了方便, 通篇的例子都采用这个模型, 订单, 订单产品, 订单地址的关系, 订单需要依赖订单地址和产品等信息. 一般需要在构造函数中构造Order</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Order</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> InterfaceItem orderItem;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> InterfaceAddress orderAddress;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    Order (InterfaceItem orderItem, InterfaceAddress orderAddress, ...) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.orderItem = orderItem;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.orderAddress = orderAddress;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">persistOrderData</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.save();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> AmazonOrderItem implements InterfaceItem &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> AmazonOrderAddress implements InterfaceItem &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"IoC是如何诞生的\"><a href=\"#IoC是如何诞生的\" class=\"headerlink\" title=\"IoC是如何诞生的\"></a>IoC是如何诞生的</h2><p>IoC中文被翻译为”控制反转”, 一直都让我一头雾水, 软件工程师取名总是带着一种”我提出了一个改变世界的概念”的感觉, 不实在. 老外取得名, 在翻译为中文, 更增加了神秘感.<br>得到一个类的实例, 只有一个办法, 就是new YourClass(). 在只有没有Spring框架的时代, 随着业务逻辑的增加, 类中的属性越来越多,当我们要得到实例时, 发现要提前准备很多很多对象, 比如: new YourClass(obj_1, obj_2, obj_3, …), 这些obj_n都是通过new得到的.<br>当人们把很多项目放在一起比较发现, 这些”new操作”, 其实是一种高级别的相似, 那么就可以”抽出它们像的部分”, 让机器帮助我们干这些活.于是, 有人能够把我们需要的某个依赖对象”主动”送过来, 而不是我们自己去new, 所以就是”控制反转”.<br>达到的目的就是”依赖注入”, 将依赖对象注入到被注入对象中.<br>注入的方式有三种, 接口注入(废弃), 构造器注入, setter注入(推荐)</p>\n<h2 id=\"IoC-Service-Provider与BeanFactory支持的XML配置\"><a href=\"#IoC-Service-Provider与BeanFactory支持的XML配置\" class=\"headerlink\" title=\"IoC Service Provider与BeanFactory支持的XML配置\"></a>IoC Service Provider与BeanFactory支持的XML配置</h2><p>通常被大家称为IoC容器. IoC Service Provider职责只有两个, 业务对象的构建和业务对象之间的依赖绑定. 也就是记录依赖关系, 据此生成业务对象.</p>\n<p>Spring的IoC容器是一个IoC Service Provider, 提供了两种类型的支持: BeanFactory和ApplicationContext. 其中ApplicationContext基于BeanFactory, 提供了事件发布等功能.</p>\n<p>Spring提倡使用POJO, 每个业务对象看做是一个JavaBean. 只有纳入Spring管理的这些类才能看做是业务对象, 如何纳入Spring管理, 就是这些类上有<code>@Configuration</code>, <code>@Component</code>, <code>@Service</code>等注解. 要是定义了一个普通的类, 那么这并不能归IoC容器管辖.</p>\n<p>很久以前, 我们基本上都使用XML进行依赖关系的记录, 通过XML很好的给我们展现了, 依赖的树形关系, 先完成类的声明, 然后对应编写XML, 比如: </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;order&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;..Order&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;orderItem&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">&quot;amazonOrderItem&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;orderAddress&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">&quot;amazonOrderAddress&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;amazonOrderItem&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;..impl.AmazonOrderItem&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;amazonOrderAddress&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;..impl.AmazonOrderAddress&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>以下列举了BeanFactory接口源码(重载方法没有列出)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.springframework.beans.factory;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The root interface for accessing a Spring bean container.</span></span><br><span class=\"line\"><span class=\"comment\"> * This is the basic client view of a bean container;</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BeanFactory</span> </span>&#123;</span><br><span class=\"line\">\tString FACTORY_BEAN_PREFIX = <span class=\"string\">&quot;&amp;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\">Object <span class=\"title\">getBean</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">\t&lt;T&gt; <span class=\"function\">ObjectProvider&lt;T&gt; <span class=\"title\">getBeanProvider</span><span class=\"params\">(Class&lt;T&gt; requiredType)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">containsBean</span><span class=\"params\">(String name)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isSingleton</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isPrototype</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isTypeMatch</span><span class=\"params\">(String name, ResolvableType typeToMatch)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class=\"line\">\t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\tClass&lt;?&gt; getType(String name) <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException;</span><br><span class=\"line\">\tString[] getAliases(String name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">  * 其中&quot;prototype&quot;, &quot;singleton&quot;是bean的scope属性两种类型值</span></span><br><span class=\"line\"><span class=\"comment\">  * 拥有prototype scope的bean定义, 容器在接到该类型对象的请求时, 会每次都重新生成一个新的对象实例给请求方</span></span><br><span class=\"line\"><span class=\"comment\">  * 这有助于理解BeanFactory中两个方法的意义</span></span><br><span class=\"line\"><span class=\"comment\">  **/</span></span><br></pre></td></tr></table></figure>\n<p>在拥有了BeanFactory之后, 我们将”生产图纸”交给BeanFactory, 让其为我们生产一个业务对象即可:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BeanFactory container = <span class=\"keyword\">new</span> XmlBeanFacotry(<span class=\"keyword\">new</span> ClassPathResource(<span class=\"string\">&quot;XML_PATH&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 或者使用ApplicationContext</span></span><br><span class=\"line\"><span class=\"comment\"> * ApplicationContext container = new ClassPathXmlApplication(&quot;XML_PATH&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\">Order order = (Order)container.getBean(<span class=\"string\">&quot;order&quot;</span>);</span><br><span class=\"line\">order.persistOrderData();</span><br></pre></td></tr></table></figure>\n\n<p>综上, IoC容器, 或者具体点BeanFactory, 完成了, 注册/绑定-&gt;生产对象, 三个步骤. 这就是IoC的所有目的了.每个业务对象作为个体, 在Spring的XML配置文件中是</bean>元素一一对应的, 只要我们了解了单个业务对象是如何配置的, 那么剩下的就是”依葫芦画瓢”.</p>\n<h3 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h3><p>这里额外介绍一下工厂方法. 在强调面向接口编程的同时, 有一点需要注意: <strong>虽然对象可以通过声明接口来避免对特定接口实现类的过度耦合</strong>, 但总归需要一种方式将声明依赖接口的对象与接口实现类关联起来,. 只依赖一个不做任何事情的接口是没有任何用处的.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> BarInterface barInterface;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 我们应该避免这样做</span></span><br><span class=\"line\">        <span class=\"comment\">// instance = new BarInterfaceImpl();</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果以上类Foo是由我们自定义的, 我们可以在其上<code>@Component</code>或者<code>@Service</code>纳入Spring IoC容器管理, 让容器帮我们解除接口和实现类之间的耦合性. 但是, 如果BarInterface来自于第三方库, 接口与实现类的耦合性需要其他方式来避免. 这是我们可以写一个工厂方法(Factory Method), 提供一个工厂类来实例化具体接口实现类. Foo类只需要依赖于工厂类, 当实现类有变更的时候, 只是变更工厂类, Foo类代码不需要做出任何变动.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> BarInterface barInterface;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 静态工厂</span></span><br><span class=\"line\">        <span class=\"comment\">// barInterface = BarInterfaceFactory.getInterface()</span></span><br><span class=\"line\">        <span class=\"comment\">// 或者, 非静态工厂</span></span><br><span class=\"line\">        <span class=\"comment\">// barInterface = new BarInterfaceFactory().getInstance();</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 以上操作实际上是在BarInterface与实现类之间加了一层而已. 美其名曰: &quot;解除耦合&quot;.</span></span><br></pre></td></tr></table></figure>\n<p>在XML中, 我们可以这样声明, 将这个工厂方法交给Spring容器管理</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;foo&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;...Foo&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;barInterface&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">&quot;bar&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;bar&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;...StaticBarInterfaceFactory&quot;</span> <span class=\"attr\">factory-method</span>=<span class=\"string\">&quot;getInstance&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>factory-method指定工厂方法名, 然后容器调用静态方法getInstance. 也就是说, 为对象foo注入的bar对象实际是BarInterfaceImpl的实例.</p>\n<h2 id=\"容器背后的秘密\"><a href=\"#容器背后的秘密\" class=\"headerlink\" title=\"容器背后的秘密\"></a>容器背后的秘密</h2><p>Spring IoC容器实现其功能, 基本上可以按照类似的流程分为两个阶段: 容器启动阶段和Bean实例化阶段</p>\n<blockquote>\n<p>容器启动阶段: 加载配置 &gt; 分析配置信息 &gt; 装备到BeanDefinition &gt; 其他后处理 …</p>\n</blockquote>\n<ul>\n<li>容器需要依赖BeanDefinitionReader对加载的Configuration MetaData就行解析和处理, 最后注册到BeanDefinitionRegistory<blockquote>\n<p>Bean实例化阶段: 实例化对象 &gt; 装配依赖 &gt; 生命周期回调 &gt; 对象其他处理 &gt; 注册回调接口 …</p>\n</blockquote>\n</li>\n<li>所有的Bean定义都通过BeanDefinition的方式注册到了BeanDefinitionRegistry中. 当某个请求通过容器getBean时, 就会触发第二阶段</li>\n</ul>\n<p>第一阶段是图纸装配, 第二阶段是使用装配好的生产线生产具体的产品.</p>\n<h3 id=\"图纸装配\"><a href=\"#图纸装配\" class=\"headerlink\" title=\"图纸装配\"></a>图纸装配</h3><p>“图纸装配”从一般的逻辑上来讲要经历, 这几个阶段: 读文件 -&gt; 将文件中的占位符替换 -&gt; 文件中的字符串进行类型装换<br>Spring容器提供了一种叫做BeanFactoryProcessor接口, 一个容器可以有多个BeanFactoryPostProcessor. 比如: </p>\n<ul>\n<li>PropertyPlaceholderConfigurer, 作用是将占位符替换为properties文件中声明的值.</li>\n<li>CustomEditorConfigurer, 将XML格式文件中读取的字符串形式的值进行转换. 具体实现是通过Spring内部提供的JavaBean的PropertyEditor来帮助进行String类型到其他类型的转换, 比如: StringArrayPropertyEditor(将逗号分隔的字符串转为String[]), ClassEditor(根据String类型的class名称, 转换为相应的class对象, 相当于Class.forName(String))等等.</li>\n</ul>\n<blockquote>\n<p>插一句, 如果让我去组织这些Processor的话, 我会采用Django框架中middleware的做法, 首先按照顺序列好这些Processor, 然后一个一个执行, PropertyPlaceholderConfigurer &gt; CustomEditorConfigurer &gt; …等等, 每个Processor完成一个步骤, 最后装配成功. 我想Spring框架也会采用这样的办法, 毕竟我们在将Bean注册到Spring容器的时候, 都是可以设置顺序的.</p>\n</blockquote>\n<h3 id=\"生产产品\"><a href=\"#生产产品\" class=\"headerlink\" title=\"生产产品\"></a>生产产品</h3><p>容器启动之后, 并不会马上进行实例化Bean. 容器现在拥有对象的BeanDefinition来存储实例化必要信息. 当通过BeanFactory.getBean()方法来请求某个对象实例时, 才可能触发Bean实例化阶段的活动. </p>\n<h4 id=\"Bean的实例化与BeanWrapper\"><a href=\"#Bean的实例化与BeanWrapper\" class=\"headerlink\" title=\"Bean的实例化与BeanWrapper\"></a>Bean的实例化与BeanWrapper</h4><p>容器在内部实现的时候, 采用”策略模式(Strategy Pattern)”来决定使用何种方式初始化bean实例, 通常是通过反射或者CGLIB动态字节码来生成bean实例, 或者其子类. 默认情况下, 容器采用的是CglibSubclassingInstantiationStrategy.</p>\n<p>按照正常的逻辑, 容器只需要根据BeanDefintion取得实例化信息, 结合CglibInstantiationStrategy返回对象实例. 但是, 这里的做法不是直接返回构造完成的实例, 而是以BeanWrapper对构造完成的对象实例进行包裹, 返回相应的BeanWrapper实例. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object order = Class.forName(<span class=\"string\">&quot;package.name.Order&quot;</span>).newInstance();</span><br><span class=\"line\">Object orderItem = Class.forName(<span class=\"string\">&quot;package.name.AmazonOrderItem&quot;</span>).newInstance();</span><br><span class=\"line\">Object orderAddress = Class.forName(<span class=\"string\">&quot;package.name.AmazonOrderAddress&quot;</span>).newInstace();</span><br><span class=\"line\"></span><br><span class=\"line\">BeanWrapper newOrder = <span class=\"keyword\">new</span> BeanWrapperImpl(order);</span><br><span class=\"line\">newOrder.setPropertyValue(<span class=\"string\">&quot;newOrderItem&quot;</span>, orderItem);</span><br><span class=\"line\">newOrder.setPropertyValue(<span class=\"string\">&quot;newOrderAddress&quot;</span>, orderAddress);</span><br><span class=\"line\"></span><br><span class=\"line\">assertTrue(newOrder.getWrappedInstance() <span class=\"keyword\">instanceof</span> Order);</span><br><span class=\"line\">assertSame(order, newOrder.getWrappedInstance());</span><br><span class=\"line\">assertSame(orderItem, newOrder.getPropertyValue(<span class=\"string\">&quot;newOrderItem&quot;</span>));</span><br><span class=\"line\">assertSame(orderAddress, newOrder.getPropertyValue(<span class=\"string\">&quot;newOrderAddress&quot;</span>));</span><br></pre></td></tr></table></figure>\n<p>针对以上示例, 截一段源码, BeanWrapperImpl是实现类, 这里调用的都是父类AbstractNestablePropertyAccessor的方法.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.springframework.beans;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanWrapperImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractNestablePropertyAccessor</span> <span class=\"keyword\">implements</span> <span class=\"title\">BeanWrapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BeanWrapperImpl</span><span class=\"params\">(Object object)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>(object);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractNestablePropertyAccessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractPropertyAccessor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\tObject wrappedObject;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Object <span class=\"title\">getWrappedInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tAssert.state(<span class=\"keyword\">this</span>.wrappedObject != <span class=\"keyword\">null</span>, <span class=\"string\">&quot;No wrapped object&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.wrappedObject;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">AbstractNestablePropertyAccessor</span><span class=\"params\">(Object object)</span> </span>&#123;</span><br><span class=\"line\">\t\tregisterDefaultEditors();</span><br><span class=\"line\">\t\tsetWrappedInstance(object);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWrappedInstance</span><span class=\"params\">(Object object)</span> </span>&#123;</span><br><span class=\"line\">\t\tsetWrappedInstance(object, <span class=\"string\">&quot;&quot;</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWrappedInstance</span><span class=\"params\">(Object object, <span class=\"meta\">@Nullable</span> String nestedPath, <span class=\"meta\">@Nullable</span> Object rootObject)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.wrappedObject = ObjectUtils.unwrapOptional(object);</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPropertyValue</span><span class=\"params\">(String propertyName, <span class=\"meta\">@Nullable</span> Object value)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ... 这里用了很多反射的方法.</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果粗略的看没有什么复杂的逻辑, 但是里边的细节很多, 要是让我去写Spring的架构, 最终要的是接口的设计, 层次的划分, 以及需求的抽象. </p>\n<h4 id=\"给实例注入依赖对象\"><a href=\"#给实例注入依赖对象\" class=\"headerlink\" title=\"给实例注入依赖对象\"></a>给实例注入依赖对象</h4><p>上一步我们已经将, 属性set到了bean实例上, 但是没有赋值. Spring容器会检查当前实例实现了哪个Aware命名结尾的接口, 然后将对应Aware接口中对顶的依赖注入进去.<br>比如, BeanNameAware, 如果Spring容器检测到当前对象实例实现了该接口, 会将该对象实例的bean定义对应的beanName设置到当前实例. BeanClassLoaderAware, 会将当前bean的ClassLoader注入当前对象实例.</p>\n<h4 id=\"对实例进行前-后-置处理\"><a href=\"#对实例进行前-后-置处理\" class=\"headerlink\" title=\"对实例进行前(后)置处理\"></a>对实例进行前(后)置处理</h4><p>现在依赖注入已经完成, 那么接下来可以对实例进行后置处理(hook), Spring提供了侵入的办法, 就是BeanPostProcessor.<br>BeanPostProcessor与BeanFactoryPostProcessor容器混淆. 只要记住BeanPostProcessor存在于对象实例化阶段, 而BeanFactoryPostProcessor存在于容器启动阶段. BeanPostProcessor会处理容器内所有符合条件的实例化后的对象实例. 该接口很简单, 从方法的命名上就可以看出其意义, 一个可以唤作前置处理, 一个唤作后置处理:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.springframework.beans.factory.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.BeansException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.lang.Nullable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Factory hook that allows for custom modification of new bean instances,</span></span><br><span class=\"line\"><span class=\"comment\"> * e.g. checking for marker interfaces or wrapping them with proxies.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;ApplicationContexts can autodetect BeanPostProcessor beans in their</span></span><br><span class=\"line\"><span class=\"comment\"> * bean definitions and apply them to any beans subsequently created.</span></span><br><span class=\"line\"><span class=\"comment\"> * Plain bean factories allow for programmatic registration of post-processors,</span></span><br><span class=\"line\"><span class=\"comment\"> * applying to all beans created through this factory.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;Typically, post-processors that populate beans via marker interfaces</span></span><br><span class=\"line\"><span class=\"comment\"> * or the like will implement &#123;<span class=\"doctag\">@link</span> #postProcessBeforeInitialization&#125;,</span></span><br><span class=\"line\"><span class=\"comment\"> * while post-processors that wrap beans with proxies will normally</span></span><br><span class=\"line\"><span class=\"comment\"> * implement &#123;<span class=\"doctag\">@link</span> #postProcessAfterInitialization&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Juergen Hoeller</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 10.10.2003</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> InstantiationAwareBeanPostProcessor</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> DestructionAwareBeanPostProcessor</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> ConfigurableBeanFactory#addBeanPostProcessor</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> BeanFactoryPostProcessor</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BeanPostProcessor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;before&lt;/i&gt; any bean</span></span><br><span class=\"line\"><span class=\"comment\">\t * initialization callbacks (like InitializingBean&#x27;s &#123;<span class=\"doctag\">@code</span> afterPropertiesSet&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t * or a custom init-method). The bean will already be populated with property values.</span></span><br><span class=\"line\"><span class=\"comment\">\t * The returned bean instance may be a wrapper around the original.</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;The default implementation returns the given &#123;<span class=\"doctag\">@code</span> bean&#125; as-is.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> bean the new bean instance</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> beanName the name of the bean</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the bean instance to use, either the original or a wrapped one;</span></span><br><span class=\"line\"><span class=\"comment\">\t * if &#123;<span class=\"doctag\">@code</span> null&#125;, no subsequent BeanPostProcessors will be invoked</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@see</span> org.springframework.beans.factory.InitializingBean#afterPropertiesSet</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">default</span> Object <span class=\"title\">postProcessBeforeInitialization</span><span class=\"params\">(Object bean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;after&lt;/i&gt; any bean</span></span><br><span class=\"line\"><span class=\"comment\">\t * initialization callbacks (like InitializingBean&#x27;s &#123;<span class=\"doctag\">@code</span> afterPropertiesSet&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t * or a custom init-method). The bean will already be populated with property values.</span></span><br><span class=\"line\"><span class=\"comment\">\t * The returned bean instance may be a wrapper around the original.</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;In case of a FactoryBean, this callback will be invoked for both the FactoryBean</span></span><br><span class=\"line\"><span class=\"comment\">\t * instance and the objects created by the FactoryBean (as of Spring 2.0). The</span></span><br><span class=\"line\"><span class=\"comment\">\t * post-processor can decide whether to apply to either the FactoryBean or created</span></span><br><span class=\"line\"><span class=\"comment\">\t * objects or both through corresponding &#123;<span class=\"doctag\">@code</span> bean instanceof FactoryBean&#125; checks.</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;This callback will also be invoked after a short-circuiting triggered by a</span></span><br><span class=\"line\"><span class=\"comment\">\t * &#123;<span class=\"doctag\">@link</span> InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation&#125; method,</span></span><br><span class=\"line\"><span class=\"comment\">\t * in contrast to all other BeanPostProcessor callbacks.</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;The default implementation returns the given &#123;<span class=\"doctag\">@code</span> bean&#125; as-is.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> bean the new bean instance</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> beanName the name of the bean</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the bean instance to use, either the original or a wrapped one;</span></span><br><span class=\"line\"><span class=\"comment\">\t * if &#123;<span class=\"doctag\">@code</span> null&#125;, no subsequent BeanPostProcessors will be invoked</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@see</span> org.springframework.beans.factory.InitializingBean#afterPropertiesSet</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@see</span> org.springframework.beans.factory.FactoryBean</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">default</span> Object <span class=\"title\">postProcessAfterInitialization</span><span class=\"params\">(Object bean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们也可以自定义BeanPostProcessor, 定义一个类implements BeanPostProcessor, 来把自己的逻辑侵入到bean实例化的过程当中去.</p>\n<h4 id=\"InitialzingBean和init-method\"><a href=\"#InitialzingBean和init-method\" class=\"headerlink\" title=\"InitialzingBean和init-method\"></a>InitialzingBean和init-method</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.springframework.beans.factory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Interface to be implemented by beans that need to react once all their properties</span></span><br><span class=\"line\"><span class=\"comment\"> * have been set by a &#123;<span class=\"doctag\">@link</span> BeanFactory&#125;: e.g. to perform custom initialization,</span></span><br><span class=\"line\"><span class=\"comment\"> * or merely to check that all mandatory properties have been set.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;An alternative to implementing &#123;<span class=\"doctag\">@code</span> InitializingBean&#125; is specifying a custom</span></span><br><span class=\"line\"><span class=\"comment\"> * init method, for example in an XML bean definition. For a list of all bean</span></span><br><span class=\"line\"><span class=\"comment\"> * lifecycle methods, see the &#123;<span class=\"doctag\">@link</span> BeanFactory BeanFactory javadocs&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Rod Johnson</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Juergen Hoeller</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> DisposableBean</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> org.springframework.beans.factory.config.BeanDefinition#getPropertyValues()</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> org.springframework.beans.factory.support.AbstractBeanDefinition#getInitMethodName()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">InitializingBean</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Invoked by the containing &#123;<span class=\"doctag\">@code</span> BeanFactory&#125; after it has set all bean properties</span></span><br><span class=\"line\"><span class=\"comment\">\t * and satisfied &#123;<span class=\"doctag\">@link</span> BeanFactoryAware&#125;, &#123;<span class=\"doctag\">@code</span> ApplicationContextAware&#125; etc.</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;This method allows the bean instance to perform validation of its overall</span></span><br><span class=\"line\"><span class=\"comment\">\t * configuration and final initialization when all bean properties have been set.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@throws</span> Exception in the event of misconfiguration (such as failure to set an</span></span><br><span class=\"line\"><span class=\"comment\">\t * essential property) or if initialization fails for any other reason</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>InitializingBean的作用在于, 对象实例化调用过”BeanPostProcessor的前置处理”方法之后, 会接着检测对象是否实现了InitializingBean接口, 如果是, 就会调用afterPropertiesSet()方法进一步调整对象实例的状态.<br>但是, 以上操作显得Spring容器比较具有侵入性, 那么Spring还提供了另一种方式, 那就是在XML的<code>&lt;bean&gt;</code>标签中配置init-method, 可以认为在InitializingBean和init-method中任选其一帮助你完成类似的初始化工作.</p>\n<blockquote>\n<p>到这里我不仅感叹, 这篇博客是我对《Spring揭秘》的读书和实践的笔记, 可能大部分书籍的文字都来源于对Spring源码中注释的解读.</p>\n</blockquote>\n<h4 id=\"DisposableBean与destroy-method\"><a href=\"#DisposableBean与destroy-method\" class=\"headerlink\" title=\"DisposableBean与destroy-method\"></a>DisposableBean与destroy-method</h4><p>同样地, 当所有的一切, 该设置的设置, 该注入的注入, 该调用的调用完成之后, 容器会检查singleton类型的bean实例, 是否实现了DisposableBean接口. 或者对应的bean在<code>&lt;bean&gt;</code>里定义了destory-method. 是的话, 就会为该实例注册一个用于对象销毁的回调(Callback), 以便这些singleton类型的对象实例销毁之前, 执行销毁逻辑.</p>\n<blockquote>\n<p>容器不会去管理, scope为prototype类型的bean实例.</p>\n</blockquote>\n<h2 id=\"使用注解代替XML\"><a href=\"#使用注解代替XML\" class=\"headerlink\" title=\"使用注解代替XML\"></a>使用注解代替XML</h2><p>在XML配置成功的基础上, 引入了注解来减少冗余操作.<br><code>@Autowired</code>四基于注解的依赖注入的核心注解. 它们都是触发容器对相应对象给与依赖注入的标志. <code>@Autowired</code>是按照类型匹配进行依赖注入的. 现在, 容器的配置文件就只剩下一个个孤零零的bean定义了.</p>\n<p>有了注解必须得有Annotation Processor, 要不然注解和注释没什么区别, Spring提供了AutowiredAnnotationBeanPostProcessor来得到这一目的. 通过反射检查每个bean定义对应的类上的各种可能位置上的<code>@Autowired</code>. 存在, 就从当前容器管理的对象中获取符合条件的对象, 设置给<code>@Autowired</code>锁标注的属性或方法. 伪代码如下: </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object[] beans = ...;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Objec bean: beans) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(autowiredExistsOnField(bean))&#123;</span><br><span class=\"line\">        Field f = getQulifiedField(bean);</span><br><span class=\"line\">        setAccessiableIfNeccessary(f);</span><br><span class=\"line\">        f.set(getBeanByTypeFromContainer());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(autowiredExistsOnMethod(bean)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果当前的<code>@Autowired</code>标注的依赖在容器中找到了两个以上的实例的话, 就需要@Qualifier的配合, 出入自定义的name(String)条件作出进一步限定. <code>@Qualifier</code>实际上是byName自动绑定的注解版.</p>\n<h4 id=\"classpath-scanning\"><a href=\"#classpath-scanning\" class=\"headerlink\" title=\"classpath-scanning\"></a>classpath-scanning</h4><p>到目前为止, 我们已经通过注解将依赖关系xml定义转移到了源码中. 为了”一套代码, 一处定义”的理念, 要将革命进行彻底. classpath-scanning的诞生!<br>使用相应的注解(<code>@Component</code>, <code>@Service</code>, <code>@Configuration</code>)进行标注之后, classpath-scanning功能从某一顶层包(base package)开始扫描, 当扫描到相应的注解之后, 就会提取该类的信息, 构建对应的BeanDefinition, 然后把构建完成的BeanDefinition注册到容器.<br>classpath-scanning由<code>&lt;context:component-scan&gt;</code>决定. <code>&lt;context:component-scan&gt;</code>默认扫描的注解时<code>@Component</code>. 其中, 在@Component语义的基础上细化后又有了<code>@Repository</code>, <code>@Service</code>/<code>@Controller</code>, 他们同样都会被扫描. <code>@Component</code>的语义更宽泛, 而<code>@Service</code>以及<code>@Repository</code>等更具体. 另外, 对于服务层类定义来说, 使用<code>@Service</code>标注它, 比<code>@Component</code>更加确切.</p>\n<p>学习Spring框架, 是不是要抓住Spring中几个大的接口来进行, 比如BeanFactory, BeanPostProcessor等, 毕竟是面向接口的编程. </p>\n","site":{"data":{}},"excerpt":"","more":"<p>为了方便, 通篇的例子都采用这个模型, 订单, 订单产品, 订单地址的关系, 订单需要依赖订单地址和产品等信息. 一般需要在构造函数中构造Order</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Order</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> InterfaceItem orderItem;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> InterfaceAddress orderAddress;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    Order (InterfaceItem orderItem, InterfaceAddress orderAddress, ...) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.orderItem = orderItem;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.orderAddress = orderAddress;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">persistOrderData</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.save();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> AmazonOrderItem implements InterfaceItem &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> AmazonOrderAddress implements InterfaceItem &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"IoC是如何诞生的\"><a href=\"#IoC是如何诞生的\" class=\"headerlink\" title=\"IoC是如何诞生的\"></a>IoC是如何诞生的</h2><p>IoC中文被翻译为”控制反转”, 一直都让我一头雾水, 软件工程师取名总是带着一种”我提出了一个改变世界的概念”的感觉, 不实在. 老外取得名, 在翻译为中文, 更增加了神秘感.<br>得到一个类的实例, 只有一个办法, 就是new YourClass(). 在只有没有Spring框架的时代, 随着业务逻辑的增加, 类中的属性越来越多,当我们要得到实例时, 发现要提前准备很多很多对象, 比如: new YourClass(obj_1, obj_2, obj_3, …), 这些obj_n都是通过new得到的.<br>当人们把很多项目放在一起比较发现, 这些”new操作”, 其实是一种高级别的相似, 那么就可以”抽出它们像的部分”, 让机器帮助我们干这些活.于是, 有人能够把我们需要的某个依赖对象”主动”送过来, 而不是我们自己去new, 所以就是”控制反转”.<br>达到的目的就是”依赖注入”, 将依赖对象注入到被注入对象中.<br>注入的方式有三种, 接口注入(废弃), 构造器注入, setter注入(推荐)</p>\n<h2 id=\"IoC-Service-Provider与BeanFactory支持的XML配置\"><a href=\"#IoC-Service-Provider与BeanFactory支持的XML配置\" class=\"headerlink\" title=\"IoC Service Provider与BeanFactory支持的XML配置\"></a>IoC Service Provider与BeanFactory支持的XML配置</h2><p>通常被大家称为IoC容器. IoC Service Provider职责只有两个, 业务对象的构建和业务对象之间的依赖绑定. 也就是记录依赖关系, 据此生成业务对象.</p>\n<p>Spring的IoC容器是一个IoC Service Provider, 提供了两种类型的支持: BeanFactory和ApplicationContext. 其中ApplicationContext基于BeanFactory, 提供了事件发布等功能.</p>\n<p>Spring提倡使用POJO, 每个业务对象看做是一个JavaBean. 只有纳入Spring管理的这些类才能看做是业务对象, 如何纳入Spring管理, 就是这些类上有<code>@Configuration</code>, <code>@Component</code>, <code>@Service</code>等注解. 要是定义了一个普通的类, 那么这并不能归IoC容器管辖.</p>\n<p>很久以前, 我们基本上都使用XML进行依赖关系的记录, 通过XML很好的给我们展现了, 依赖的树形关系, 先完成类的声明, 然后对应编写XML, 比如: </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;order&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;..Order&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;orderItem&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">&quot;amazonOrderItem&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;orderAddress&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">&quot;amazonOrderAddress&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;amazonOrderItem&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;..impl.AmazonOrderItem&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;amazonOrderAddress&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;..impl.AmazonOrderAddress&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>以下列举了BeanFactory接口源码(重载方法没有列出)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.springframework.beans.factory;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The root interface for accessing a Spring bean container.</span></span><br><span class=\"line\"><span class=\"comment\"> * This is the basic client view of a bean container;</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BeanFactory</span> </span>&#123;</span><br><span class=\"line\">\tString FACTORY_BEAN_PREFIX = <span class=\"string\">&quot;&amp;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\">Object <span class=\"title\">getBean</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">\t&lt;T&gt; <span class=\"function\">ObjectProvider&lt;T&gt; <span class=\"title\">getBeanProvider</span><span class=\"params\">(Class&lt;T&gt; requiredType)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">containsBean</span><span class=\"params\">(String name)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isSingleton</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isPrototype</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isTypeMatch</span><span class=\"params\">(String name, ResolvableType typeToMatch)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class=\"line\">\t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\tClass&lt;?&gt; getType(String name) <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException;</span><br><span class=\"line\">\tString[] getAliases(String name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">  * 其中&quot;prototype&quot;, &quot;singleton&quot;是bean的scope属性两种类型值</span></span><br><span class=\"line\"><span class=\"comment\">  * 拥有prototype scope的bean定义, 容器在接到该类型对象的请求时, 会每次都重新生成一个新的对象实例给请求方</span></span><br><span class=\"line\"><span class=\"comment\">  * 这有助于理解BeanFactory中两个方法的意义</span></span><br><span class=\"line\"><span class=\"comment\">  **/</span></span><br></pre></td></tr></table></figure>\n<p>在拥有了BeanFactory之后, 我们将”生产图纸”交给BeanFactory, 让其为我们生产一个业务对象即可:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BeanFactory container = <span class=\"keyword\">new</span> XmlBeanFacotry(<span class=\"keyword\">new</span> ClassPathResource(<span class=\"string\">&quot;XML_PATH&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 或者使用ApplicationContext</span></span><br><span class=\"line\"><span class=\"comment\"> * ApplicationContext container = new ClassPathXmlApplication(&quot;XML_PATH&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\">Order order = (Order)container.getBean(<span class=\"string\">&quot;order&quot;</span>);</span><br><span class=\"line\">order.persistOrderData();</span><br></pre></td></tr></table></figure>\n\n<p>综上, IoC容器, 或者具体点BeanFactory, 完成了, 注册/绑定-&gt;生产对象, 三个步骤. 这就是IoC的所有目的了.每个业务对象作为个体, 在Spring的XML配置文件中是</bean>元素一一对应的, 只要我们了解了单个业务对象是如何配置的, 那么剩下的就是”依葫芦画瓢”.</p>\n<h3 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h3><p>这里额外介绍一下工厂方法. 在强调面向接口编程的同时, 有一点需要注意: <strong>虽然对象可以通过声明接口来避免对特定接口实现类的过度耦合</strong>, 但总归需要一种方式将声明依赖接口的对象与接口实现类关联起来,. 只依赖一个不做任何事情的接口是没有任何用处的.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> BarInterface barInterface;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 我们应该避免这样做</span></span><br><span class=\"line\">        <span class=\"comment\">// instance = new BarInterfaceImpl();</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果以上类Foo是由我们自定义的, 我们可以在其上<code>@Component</code>或者<code>@Service</code>纳入Spring IoC容器管理, 让容器帮我们解除接口和实现类之间的耦合性. 但是, 如果BarInterface来自于第三方库, 接口与实现类的耦合性需要其他方式来避免. 这是我们可以写一个工厂方法(Factory Method), 提供一个工厂类来实例化具体接口实现类. Foo类只需要依赖于工厂类, 当实现类有变更的时候, 只是变更工厂类, Foo类代码不需要做出任何变动.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> BarInterface barInterface;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 静态工厂</span></span><br><span class=\"line\">        <span class=\"comment\">// barInterface = BarInterfaceFactory.getInterface()</span></span><br><span class=\"line\">        <span class=\"comment\">// 或者, 非静态工厂</span></span><br><span class=\"line\">        <span class=\"comment\">// barInterface = new BarInterfaceFactory().getInstance();</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 以上操作实际上是在BarInterface与实现类之间加了一层而已. 美其名曰: &quot;解除耦合&quot;.</span></span><br></pre></td></tr></table></figure>\n<p>在XML中, 我们可以这样声明, 将这个工厂方法交给Spring容器管理</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;foo&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;...Foo&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;barInterface&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">&quot;bar&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;bar&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;...StaticBarInterfaceFactory&quot;</span> <span class=\"attr\">factory-method</span>=<span class=\"string\">&quot;getInstance&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>factory-method指定工厂方法名, 然后容器调用静态方法getInstance. 也就是说, 为对象foo注入的bar对象实际是BarInterfaceImpl的实例.</p>\n<h2 id=\"容器背后的秘密\"><a href=\"#容器背后的秘密\" class=\"headerlink\" title=\"容器背后的秘密\"></a>容器背后的秘密</h2><p>Spring IoC容器实现其功能, 基本上可以按照类似的流程分为两个阶段: 容器启动阶段和Bean实例化阶段</p>\n<blockquote>\n<p>容器启动阶段: 加载配置 &gt; 分析配置信息 &gt; 装备到BeanDefinition &gt; 其他后处理 …</p>\n</blockquote>\n<ul>\n<li>容器需要依赖BeanDefinitionReader对加载的Configuration MetaData就行解析和处理, 最后注册到BeanDefinitionRegistory<blockquote>\n<p>Bean实例化阶段: 实例化对象 &gt; 装配依赖 &gt; 生命周期回调 &gt; 对象其他处理 &gt; 注册回调接口 …</p>\n</blockquote>\n</li>\n<li>所有的Bean定义都通过BeanDefinition的方式注册到了BeanDefinitionRegistry中. 当某个请求通过容器getBean时, 就会触发第二阶段</li>\n</ul>\n<p>第一阶段是图纸装配, 第二阶段是使用装配好的生产线生产具体的产品.</p>\n<h3 id=\"图纸装配\"><a href=\"#图纸装配\" class=\"headerlink\" title=\"图纸装配\"></a>图纸装配</h3><p>“图纸装配”从一般的逻辑上来讲要经历, 这几个阶段: 读文件 -&gt; 将文件中的占位符替换 -&gt; 文件中的字符串进行类型装换<br>Spring容器提供了一种叫做BeanFactoryProcessor接口, 一个容器可以有多个BeanFactoryPostProcessor. 比如: </p>\n<ul>\n<li>PropertyPlaceholderConfigurer, 作用是将占位符替换为properties文件中声明的值.</li>\n<li>CustomEditorConfigurer, 将XML格式文件中读取的字符串形式的值进行转换. 具体实现是通过Spring内部提供的JavaBean的PropertyEditor来帮助进行String类型到其他类型的转换, 比如: StringArrayPropertyEditor(将逗号分隔的字符串转为String[]), ClassEditor(根据String类型的class名称, 转换为相应的class对象, 相当于Class.forName(String))等等.</li>\n</ul>\n<blockquote>\n<p>插一句, 如果让我去组织这些Processor的话, 我会采用Django框架中middleware的做法, 首先按照顺序列好这些Processor, 然后一个一个执行, PropertyPlaceholderConfigurer &gt; CustomEditorConfigurer &gt; …等等, 每个Processor完成一个步骤, 最后装配成功. 我想Spring框架也会采用这样的办法, 毕竟我们在将Bean注册到Spring容器的时候, 都是可以设置顺序的.</p>\n</blockquote>\n<h3 id=\"生产产品\"><a href=\"#生产产品\" class=\"headerlink\" title=\"生产产品\"></a>生产产品</h3><p>容器启动之后, 并不会马上进行实例化Bean. 容器现在拥有对象的BeanDefinition来存储实例化必要信息. 当通过BeanFactory.getBean()方法来请求某个对象实例时, 才可能触发Bean实例化阶段的活动. </p>\n<h4 id=\"Bean的实例化与BeanWrapper\"><a href=\"#Bean的实例化与BeanWrapper\" class=\"headerlink\" title=\"Bean的实例化与BeanWrapper\"></a>Bean的实例化与BeanWrapper</h4><p>容器在内部实现的时候, 采用”策略模式(Strategy Pattern)”来决定使用何种方式初始化bean实例, 通常是通过反射或者CGLIB动态字节码来生成bean实例, 或者其子类. 默认情况下, 容器采用的是CglibSubclassingInstantiationStrategy.</p>\n<p>按照正常的逻辑, 容器只需要根据BeanDefintion取得实例化信息, 结合CglibInstantiationStrategy返回对象实例. 但是, 这里的做法不是直接返回构造完成的实例, 而是以BeanWrapper对构造完成的对象实例进行包裹, 返回相应的BeanWrapper实例. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object order = Class.forName(<span class=\"string\">&quot;package.name.Order&quot;</span>).newInstance();</span><br><span class=\"line\">Object orderItem = Class.forName(<span class=\"string\">&quot;package.name.AmazonOrderItem&quot;</span>).newInstance();</span><br><span class=\"line\">Object orderAddress = Class.forName(<span class=\"string\">&quot;package.name.AmazonOrderAddress&quot;</span>).newInstace();</span><br><span class=\"line\"></span><br><span class=\"line\">BeanWrapper newOrder = <span class=\"keyword\">new</span> BeanWrapperImpl(order);</span><br><span class=\"line\">newOrder.setPropertyValue(<span class=\"string\">&quot;newOrderItem&quot;</span>, orderItem);</span><br><span class=\"line\">newOrder.setPropertyValue(<span class=\"string\">&quot;newOrderAddress&quot;</span>, orderAddress);</span><br><span class=\"line\"></span><br><span class=\"line\">assertTrue(newOrder.getWrappedInstance() <span class=\"keyword\">instanceof</span> Order);</span><br><span class=\"line\">assertSame(order, newOrder.getWrappedInstance());</span><br><span class=\"line\">assertSame(orderItem, newOrder.getPropertyValue(<span class=\"string\">&quot;newOrderItem&quot;</span>));</span><br><span class=\"line\">assertSame(orderAddress, newOrder.getPropertyValue(<span class=\"string\">&quot;newOrderAddress&quot;</span>));</span><br></pre></td></tr></table></figure>\n<p>针对以上示例, 截一段源码, BeanWrapperImpl是实现类, 这里调用的都是父类AbstractNestablePropertyAccessor的方法.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.springframework.beans;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanWrapperImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractNestablePropertyAccessor</span> <span class=\"keyword\">implements</span> <span class=\"title\">BeanWrapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BeanWrapperImpl</span><span class=\"params\">(Object object)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>(object);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractNestablePropertyAccessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractPropertyAccessor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\tObject wrappedObject;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Object <span class=\"title\">getWrappedInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tAssert.state(<span class=\"keyword\">this</span>.wrappedObject != <span class=\"keyword\">null</span>, <span class=\"string\">&quot;No wrapped object&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.wrappedObject;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">AbstractNestablePropertyAccessor</span><span class=\"params\">(Object object)</span> </span>&#123;</span><br><span class=\"line\">\t\tregisterDefaultEditors();</span><br><span class=\"line\">\t\tsetWrappedInstance(object);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWrappedInstance</span><span class=\"params\">(Object object)</span> </span>&#123;</span><br><span class=\"line\">\t\tsetWrappedInstance(object, <span class=\"string\">&quot;&quot;</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWrappedInstance</span><span class=\"params\">(Object object, <span class=\"meta\">@Nullable</span> String nestedPath, <span class=\"meta\">@Nullable</span> Object rootObject)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.wrappedObject = ObjectUtils.unwrapOptional(object);</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPropertyValue</span><span class=\"params\">(String propertyName, <span class=\"meta\">@Nullable</span> Object value)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ... 这里用了很多反射的方法.</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果粗略的看没有什么复杂的逻辑, 但是里边的细节很多, 要是让我去写Spring的架构, 最终要的是接口的设计, 层次的划分, 以及需求的抽象. </p>\n<h4 id=\"给实例注入依赖对象\"><a href=\"#给实例注入依赖对象\" class=\"headerlink\" title=\"给实例注入依赖对象\"></a>给实例注入依赖对象</h4><p>上一步我们已经将, 属性set到了bean实例上, 但是没有赋值. Spring容器会检查当前实例实现了哪个Aware命名结尾的接口, 然后将对应Aware接口中对顶的依赖注入进去.<br>比如, BeanNameAware, 如果Spring容器检测到当前对象实例实现了该接口, 会将该对象实例的bean定义对应的beanName设置到当前实例. BeanClassLoaderAware, 会将当前bean的ClassLoader注入当前对象实例.</p>\n<h4 id=\"对实例进行前-后-置处理\"><a href=\"#对实例进行前-后-置处理\" class=\"headerlink\" title=\"对实例进行前(后)置处理\"></a>对实例进行前(后)置处理</h4><p>现在依赖注入已经完成, 那么接下来可以对实例进行后置处理(hook), Spring提供了侵入的办法, 就是BeanPostProcessor.<br>BeanPostProcessor与BeanFactoryPostProcessor容器混淆. 只要记住BeanPostProcessor存在于对象实例化阶段, 而BeanFactoryPostProcessor存在于容器启动阶段. BeanPostProcessor会处理容器内所有符合条件的实例化后的对象实例. 该接口很简单, 从方法的命名上就可以看出其意义, 一个可以唤作前置处理, 一个唤作后置处理:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.springframework.beans.factory.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.BeansException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.lang.Nullable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Factory hook that allows for custom modification of new bean instances,</span></span><br><span class=\"line\"><span class=\"comment\"> * e.g. checking for marker interfaces or wrapping them with proxies.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;ApplicationContexts can autodetect BeanPostProcessor beans in their</span></span><br><span class=\"line\"><span class=\"comment\"> * bean definitions and apply them to any beans subsequently created.</span></span><br><span class=\"line\"><span class=\"comment\"> * Plain bean factories allow for programmatic registration of post-processors,</span></span><br><span class=\"line\"><span class=\"comment\"> * applying to all beans created through this factory.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;Typically, post-processors that populate beans via marker interfaces</span></span><br><span class=\"line\"><span class=\"comment\"> * or the like will implement &#123;<span class=\"doctag\">@link</span> #postProcessBeforeInitialization&#125;,</span></span><br><span class=\"line\"><span class=\"comment\"> * while post-processors that wrap beans with proxies will normally</span></span><br><span class=\"line\"><span class=\"comment\"> * implement &#123;<span class=\"doctag\">@link</span> #postProcessAfterInitialization&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Juergen Hoeller</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 10.10.2003</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> InstantiationAwareBeanPostProcessor</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> DestructionAwareBeanPostProcessor</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> ConfigurableBeanFactory#addBeanPostProcessor</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> BeanFactoryPostProcessor</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BeanPostProcessor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;before&lt;/i&gt; any bean</span></span><br><span class=\"line\"><span class=\"comment\">\t * initialization callbacks (like InitializingBean&#x27;s &#123;<span class=\"doctag\">@code</span> afterPropertiesSet&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t * or a custom init-method). The bean will already be populated with property values.</span></span><br><span class=\"line\"><span class=\"comment\">\t * The returned bean instance may be a wrapper around the original.</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;The default implementation returns the given &#123;<span class=\"doctag\">@code</span> bean&#125; as-is.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> bean the new bean instance</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> beanName the name of the bean</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the bean instance to use, either the original or a wrapped one;</span></span><br><span class=\"line\"><span class=\"comment\">\t * if &#123;<span class=\"doctag\">@code</span> null&#125;, no subsequent BeanPostProcessors will be invoked</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@see</span> org.springframework.beans.factory.InitializingBean#afterPropertiesSet</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">default</span> Object <span class=\"title\">postProcessBeforeInitialization</span><span class=\"params\">(Object bean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;after&lt;/i&gt; any bean</span></span><br><span class=\"line\"><span class=\"comment\">\t * initialization callbacks (like InitializingBean&#x27;s &#123;<span class=\"doctag\">@code</span> afterPropertiesSet&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t * or a custom init-method). The bean will already be populated with property values.</span></span><br><span class=\"line\"><span class=\"comment\">\t * The returned bean instance may be a wrapper around the original.</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;In case of a FactoryBean, this callback will be invoked for both the FactoryBean</span></span><br><span class=\"line\"><span class=\"comment\">\t * instance and the objects created by the FactoryBean (as of Spring 2.0). The</span></span><br><span class=\"line\"><span class=\"comment\">\t * post-processor can decide whether to apply to either the FactoryBean or created</span></span><br><span class=\"line\"><span class=\"comment\">\t * objects or both through corresponding &#123;<span class=\"doctag\">@code</span> bean instanceof FactoryBean&#125; checks.</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;This callback will also be invoked after a short-circuiting triggered by a</span></span><br><span class=\"line\"><span class=\"comment\">\t * &#123;<span class=\"doctag\">@link</span> InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation&#125; method,</span></span><br><span class=\"line\"><span class=\"comment\">\t * in contrast to all other BeanPostProcessor callbacks.</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;The default implementation returns the given &#123;<span class=\"doctag\">@code</span> bean&#125; as-is.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> bean the new bean instance</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> beanName the name of the bean</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the bean instance to use, either the original or a wrapped one;</span></span><br><span class=\"line\"><span class=\"comment\">\t * if &#123;<span class=\"doctag\">@code</span> null&#125;, no subsequent BeanPostProcessors will be invoked</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@see</span> org.springframework.beans.factory.InitializingBean#afterPropertiesSet</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@see</span> org.springframework.beans.factory.FactoryBean</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">default</span> Object <span class=\"title\">postProcessAfterInitialization</span><span class=\"params\">(Object bean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们也可以自定义BeanPostProcessor, 定义一个类implements BeanPostProcessor, 来把自己的逻辑侵入到bean实例化的过程当中去.</p>\n<h4 id=\"InitialzingBean和init-method\"><a href=\"#InitialzingBean和init-method\" class=\"headerlink\" title=\"InitialzingBean和init-method\"></a>InitialzingBean和init-method</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.springframework.beans.factory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Interface to be implemented by beans that need to react once all their properties</span></span><br><span class=\"line\"><span class=\"comment\"> * have been set by a &#123;<span class=\"doctag\">@link</span> BeanFactory&#125;: e.g. to perform custom initialization,</span></span><br><span class=\"line\"><span class=\"comment\"> * or merely to check that all mandatory properties have been set.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;An alternative to implementing &#123;<span class=\"doctag\">@code</span> InitializingBean&#125; is specifying a custom</span></span><br><span class=\"line\"><span class=\"comment\"> * init method, for example in an XML bean definition. For a list of all bean</span></span><br><span class=\"line\"><span class=\"comment\"> * lifecycle methods, see the &#123;<span class=\"doctag\">@link</span> BeanFactory BeanFactory javadocs&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Rod Johnson</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Juergen Hoeller</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> DisposableBean</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> org.springframework.beans.factory.config.BeanDefinition#getPropertyValues()</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> org.springframework.beans.factory.support.AbstractBeanDefinition#getInitMethodName()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">InitializingBean</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Invoked by the containing &#123;<span class=\"doctag\">@code</span> BeanFactory&#125; after it has set all bean properties</span></span><br><span class=\"line\"><span class=\"comment\">\t * and satisfied &#123;<span class=\"doctag\">@link</span> BeanFactoryAware&#125;, &#123;<span class=\"doctag\">@code</span> ApplicationContextAware&#125; etc.</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;This method allows the bean instance to perform validation of its overall</span></span><br><span class=\"line\"><span class=\"comment\">\t * configuration and final initialization when all bean properties have been set.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@throws</span> Exception in the event of misconfiguration (such as failure to set an</span></span><br><span class=\"line\"><span class=\"comment\">\t * essential property) or if initialization fails for any other reason</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>InitializingBean的作用在于, 对象实例化调用过”BeanPostProcessor的前置处理”方法之后, 会接着检测对象是否实现了InitializingBean接口, 如果是, 就会调用afterPropertiesSet()方法进一步调整对象实例的状态.<br>但是, 以上操作显得Spring容器比较具有侵入性, 那么Spring还提供了另一种方式, 那就是在XML的<code>&lt;bean&gt;</code>标签中配置init-method, 可以认为在InitializingBean和init-method中任选其一帮助你完成类似的初始化工作.</p>\n<blockquote>\n<p>到这里我不仅感叹, 这篇博客是我对《Spring揭秘》的读书和实践的笔记, 可能大部分书籍的文字都来源于对Spring源码中注释的解读.</p>\n</blockquote>\n<h4 id=\"DisposableBean与destroy-method\"><a href=\"#DisposableBean与destroy-method\" class=\"headerlink\" title=\"DisposableBean与destroy-method\"></a>DisposableBean与destroy-method</h4><p>同样地, 当所有的一切, 该设置的设置, 该注入的注入, 该调用的调用完成之后, 容器会检查singleton类型的bean实例, 是否实现了DisposableBean接口. 或者对应的bean在<code>&lt;bean&gt;</code>里定义了destory-method. 是的话, 就会为该实例注册一个用于对象销毁的回调(Callback), 以便这些singleton类型的对象实例销毁之前, 执行销毁逻辑.</p>\n<blockquote>\n<p>容器不会去管理, scope为prototype类型的bean实例.</p>\n</blockquote>\n<h2 id=\"使用注解代替XML\"><a href=\"#使用注解代替XML\" class=\"headerlink\" title=\"使用注解代替XML\"></a>使用注解代替XML</h2><p>在XML配置成功的基础上, 引入了注解来减少冗余操作.<br><code>@Autowired</code>四基于注解的依赖注入的核心注解. 它们都是触发容器对相应对象给与依赖注入的标志. <code>@Autowired</code>是按照类型匹配进行依赖注入的. 现在, 容器的配置文件就只剩下一个个孤零零的bean定义了.</p>\n<p>有了注解必须得有Annotation Processor, 要不然注解和注释没什么区别, Spring提供了AutowiredAnnotationBeanPostProcessor来得到这一目的. 通过反射检查每个bean定义对应的类上的各种可能位置上的<code>@Autowired</code>. 存在, 就从当前容器管理的对象中获取符合条件的对象, 设置给<code>@Autowired</code>锁标注的属性或方法. 伪代码如下: </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object[] beans = ...;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Objec bean: beans) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(autowiredExistsOnField(bean))&#123;</span><br><span class=\"line\">        Field f = getQulifiedField(bean);</span><br><span class=\"line\">        setAccessiableIfNeccessary(f);</span><br><span class=\"line\">        f.set(getBeanByTypeFromContainer());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(autowiredExistsOnMethod(bean)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果当前的<code>@Autowired</code>标注的依赖在容器中找到了两个以上的实例的话, 就需要@Qualifier的配合, 出入自定义的name(String)条件作出进一步限定. <code>@Qualifier</code>实际上是byName自动绑定的注解版.</p>\n<h4 id=\"classpath-scanning\"><a href=\"#classpath-scanning\" class=\"headerlink\" title=\"classpath-scanning\"></a>classpath-scanning</h4><p>到目前为止, 我们已经通过注解将依赖关系xml定义转移到了源码中. 为了”一套代码, 一处定义”的理念, 要将革命进行彻底. classpath-scanning的诞生!<br>使用相应的注解(<code>@Component</code>, <code>@Service</code>, <code>@Configuration</code>)进行标注之后, classpath-scanning功能从某一顶层包(base package)开始扫描, 当扫描到相应的注解之后, 就会提取该类的信息, 构建对应的BeanDefinition, 然后把构建完成的BeanDefinition注册到容器.<br>classpath-scanning由<code>&lt;context:component-scan&gt;</code>决定. <code>&lt;context:component-scan&gt;</code>默认扫描的注解时<code>@Component</code>. 其中, 在@Component语义的基础上细化后又有了<code>@Repository</code>, <code>@Service</code>/<code>@Controller</code>, 他们同样都会被扫描. <code>@Component</code>的语义更宽泛, 而<code>@Service</code>以及<code>@Repository</code>等更具体. 另外, 对于服务层类定义来说, 使用<code>@Service</code>标注它, 比<code>@Component</code>更加确切.</p>\n<p>学习Spring框架, 是不是要抓住Spring中几个大的接口来进行, 比如BeanFactory, BeanPostProcessor等, 毕竟是面向接口的编程. </p>\n"},{"title":"图灵完备","date":"2021-11-12T06:49:19.000Z","_content":"\n这是一篇旨在帮助理解图灵完备及相关概念是什么，而非证明其正确性的回答，它包含以下内容：\n什么是图灵机图灵机\n可以解决什么问题\n什么是图灵完备\n直观理解图灵完备——Brainfuck语言\n\n# 什么是图灵机\n\n图灵机（Turing Machine）是图灵在1936年发表的 \"On Computable Numbers, with an Application to the Entscheidungsproblem\"（《论可计算数及其在判定性问题上的应用》）中提出的数学模型。既然是数学模型，它就并非一个实体概念，而是架空的一个想法。在文章中图灵描述了它是什么，并且证明了，只要图灵机可以被实现，就可以用来解决任何可计算问题。\n\n图灵机的结构包括以下几个部分：一条无限长的纸带（tape），纸带被分成一个个相邻的格子（square），每个格子都可以写上至多一个字符（symbol）。一个字符表（alphabet），即字符的集合，它包含纸带上可能出现的所有字符。其中包含一个特殊的空白字符（blank），意思是此格子没有任何字符。一个读写头（head），可理解为指向其中一个格子的指针。它可以读取/擦除/写入当前格子的内容，此外也可以每次向左/右移动一个格子。一个状态寄存器（state register），它追踪着每一步运算过程中，整个机器所处的状态（运行/终止）。当这个状态从运行变为终止，则运算结束，机器停机并交回控制权。如果你了解有限状态机，它便对应着有限状态机里的状态。一个有限的指令集（instructions table），它记录着读写头在特定情况下应该执行的行为。可以想象读写头随身有一本操作指南，里面记录着很多条类似于“当你身处编号53的格子并看到其内容为0时，擦除，改写为1，并向右移一格。此外，令下一状态为运行。”这样的命令。其实某种意义上，这个指令集就对应着程序员所写下的程序了。\n\n\n\n在计算开始前，纸带可以是完全空白，也可以在某些格子里预先就有写上部分字符作为输入。运算开始时，读写头从某一位置开始，严格按照此刻的配置（configuration），即：\n - 当前所处位置\n - 当前格子内容\n\n来一步步的对照着指令集去进行操作，直到状态变为停止，运算结束。而后纸带上留下的信息，即字符的序列（比如类似“...011001...”）便作为输出，由人来解码为自然语言。\n\n要重申一下，以上只是图灵机模型的内容，而非具体的实现。所谓的纸带和读写头都只是图灵提出的抽象概念。为便于理解打一个比方。算盘虽然不是图灵机（因为它没有无限长的纸带，即无限的存储空间），但它的行为与图灵机一致。每一串算珠都是纸带上的一格，一串算珠上展示的数字便记录着当前格中的字符（可以是空白，可以是 12345 ）。人类的手即是读写头，可以更改每串算珠的状态。算盘的运行遵循人脑中的算法，当算法结束，算盘停机。\n\n# 图灵机可以解决什么问题\n\n在文章中，图灵所做的事是证明了，假设上述模型里所说的功能都能被以某种形式物理实现，那么任意可计算问题都可以被解决。这里所说的可计算问题，涉及到计算理论（Computation Theory）的概念。这个领域的概念很繁杂，先简单梳理一下。\n在计算机领域，或者说自动机领域，我们研究的一切问题都是计算问题（Computational Problem）。它泛指一切与计算相关的问题。\n> A computational problem is a mathematical object representing a collection of questions that computers might be able to solve.\n\n计算问题的一些举例：\n - 给定一个正整数 n，判断它是否是质数\n - 给定一个 01 序列，把它们按位取反\n - 给定一个字符串，判断某个字符是否存在，及查找存在位置\n - 给定一个逻辑蕴含的命题，求它的逆否命题\n非计算问题的例子：\n - 今晚吃什么\n - 为什么太阳从东边升起\n\n计算问题有的可以解决，有的不可解决。这就引出了计算问题的可计算性（Computability）。它可以被理解为“是否存在一个算法，能解决在任何输入下的此计算问题”。如上面的问题 1，我们当然可以找到一个算法来解决判断任意正整数 n 是否为质数的问题（比如从2遍历到 n-1，看 n 是否可以整除它）。所以，问题 1 就是可计算的。\n\n也有一些不可计算的计算问题，比如著名的停机问题（Halting Problem）。它的表述是这样的：给定一段程序的描述和该程序的一个有效输入，运行此程序，那么程序最终是会终止，还是会死循环下去？\n > Halting Problem: given the description of an arbitrary program and a finite input, decide whether the program finishes running or will run forever. \n\n这个问题很绕人，有点像那个著名的理发师悖论，但它确实是一个计算问题。更具体的，它是一个不可判定问题（Undecidable Problem）。即不存在一个通用算法，可以在任意输入下解决此问题。图灵在文章里很优雅的用反证法推翻了假设“假设有这么一个算法可以解决任何停机问题”，从而证明了这样的算法并不存在。具体证明过程网上的资料非常丰富，我就不再花篇幅了。\n\n回到这一节的主题。简而言之，对于一个问题，对于任意输入，只要人类可以保证算出结果（不管花多少时间），那么图灵机就可以保证算出结果（不管花多少时间）。\n\n# 什么是图灵完备\n\n图灵完备性（Turing Completeness）是针对一套数据操作规则而言的概念。数据操作规则可以是一门编程语言，也可以是计算机里具体实现了的指令集。当这套规则可以实现图灵机模型里的全部功能时，就称它具有图灵完备性。直白一点说，图灵完备性就是我给你一工具箱的东西，包括无限内存、if/else 控制流、while 循环……那么你现在图灵完备了吗？\n\n概念本身倒是非常直观，但整件事似乎还是让人云里雾里。我曾经一直不懂的就是为什么图灵给出的那个命题是正确的。换句话说，凭什么有了纸带以及其他的那一套东西，就可以自信解决任意可计算问题呢？尽管我不能通读他的那篇论文里的证明，但是通过一门叫做 Brainfuck 的编程语言，还是可以获得一些直觉。\n\n# 直观理解图灵完备——Brainfuck 语言\n\n如今主流的编程语言（C++，Java，Python，以及等等等等）都是图灵完备的语言。关于语言优劣之争也只是在其封装、优化等方面，以及因为这些区别而产生的“不同语言适用于不同情况”的争执。如果我们回到最底层，就会发现它们可以实现的功能其实完全一样，并且本质上就是一个图灵机。在1993年，Urban Müller 发明了 Brainfuck 语言。这门语言可以说是编程语言界的 helloworld 了——它一共只含有 8 个有效字符，每个有效字符就是一条指令。语言虽然极致轻量，它却是一门图灵完备的编程语言。如果能理解它的工作原理，那么对于理解图灵机是有很大帮助的。\n > Brainfuck is fully Turing-complete.\n\n先贴上一段 BF 的代码，体验一下它的画风：\n```Brainfuck\n++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++\n.------.--------.>>+.>++.\n```\n这个程序编译运行后，控制台打印 \"Hello World!\"。\n\nBF 的工作机制与图灵机高度一致。首先它存储数据的方式是一个不限长的一维整数数组，里面的数值全部初始化为 0。此外，有一数据指针，每一时刻都指向数组的某一任意元素。指针可以向左/右移动，也可以读取/修改当前值。\n\n语言里的 8 个有效字符分别是：\n - `>` ---- 指针向右移动一格\n - `<` ---- 指针向左移动一格\n - `+` ---- 使指针当前格数值加一\n - `-` ---- 使指针当前格数值减一\n - `.` ---- 把当前格数值按 ASCII 表输出到终端\n - `,` ---- 从终端接受一 byte 的数据，存储其 ASCII 数值到当前格\n - `[` ---- 当指针当前值为 0 时，程序跳转至与之对应的 `]` 之后；否则程序正常执行\n - `]` ---- 程序跳转回与之对应的 `[` 处\n\n有了这些工具，我们可以很快做出一个计算乘法的程序。因为 ASCII 表中 'A' 对应的值为 65，可以使用 5 * 13 算出 65 并输出得到字符 'A'。\n```Brainfuck\n+++++\n[\n>+++++++++++++\n<-\n]\n>.\n```\n\n把指针初始处的格子命名为 cell 0，cell 0 右边的那个格子命名为 cell 1。那么第一句将其递增 5 次变为 5。然后，循环执行“右移指针，递增 13 次， 左移指针，递减 1 次”。当 cell 0 的值最终被递减为 0 的时候，循环结束。此时 cell 1 的值执行了 5 次“递增 13 次”的操作，即 65。指针右移至 cell 1，输出此格子，则在终端会看到 'A'。\n\n编译运行上述代码块我写这个例子的目的是演示只用图灵机的模型，就可以确实计算出乘法的结果。那么自然更加复杂的计算也可以被拆解成图灵机操作（尽管可能非常琐碎）。此外，这个语言因为简洁，也是第一次练习写编译器的一个非常好的选择。","source":"_posts/theory-turing-completeness.md","raw":"---\ntitle: 图灵完备\ndate: 2021-11-12 14:49:19\ncategories:\n- 计算机理论\ntags:\n- Turing\n---\n\n这是一篇旨在帮助理解图灵完备及相关概念是什么，而非证明其正确性的回答，它包含以下内容：\n什么是图灵机图灵机\n可以解决什么问题\n什么是图灵完备\n直观理解图灵完备——Brainfuck语言\n\n# 什么是图灵机\n\n图灵机（Turing Machine）是图灵在1936年发表的 \"On Computable Numbers, with an Application to the Entscheidungsproblem\"（《论可计算数及其在判定性问题上的应用》）中提出的数学模型。既然是数学模型，它就并非一个实体概念，而是架空的一个想法。在文章中图灵描述了它是什么，并且证明了，只要图灵机可以被实现，就可以用来解决任何可计算问题。\n\n图灵机的结构包括以下几个部分：一条无限长的纸带（tape），纸带被分成一个个相邻的格子（square），每个格子都可以写上至多一个字符（symbol）。一个字符表（alphabet），即字符的集合，它包含纸带上可能出现的所有字符。其中包含一个特殊的空白字符（blank），意思是此格子没有任何字符。一个读写头（head），可理解为指向其中一个格子的指针。它可以读取/擦除/写入当前格子的内容，此外也可以每次向左/右移动一个格子。一个状态寄存器（state register），它追踪着每一步运算过程中，整个机器所处的状态（运行/终止）。当这个状态从运行变为终止，则运算结束，机器停机并交回控制权。如果你了解有限状态机，它便对应着有限状态机里的状态。一个有限的指令集（instructions table），它记录着读写头在特定情况下应该执行的行为。可以想象读写头随身有一本操作指南，里面记录着很多条类似于“当你身处编号53的格子并看到其内容为0时，擦除，改写为1，并向右移一格。此外，令下一状态为运行。”这样的命令。其实某种意义上，这个指令集就对应着程序员所写下的程序了。\n\n\n\n在计算开始前，纸带可以是完全空白，也可以在某些格子里预先就有写上部分字符作为输入。运算开始时，读写头从某一位置开始，严格按照此刻的配置（configuration），即：\n - 当前所处位置\n - 当前格子内容\n\n来一步步的对照着指令集去进行操作，直到状态变为停止，运算结束。而后纸带上留下的信息，即字符的序列（比如类似“...011001...”）便作为输出，由人来解码为自然语言。\n\n要重申一下，以上只是图灵机模型的内容，而非具体的实现。所谓的纸带和读写头都只是图灵提出的抽象概念。为便于理解打一个比方。算盘虽然不是图灵机（因为它没有无限长的纸带，即无限的存储空间），但它的行为与图灵机一致。每一串算珠都是纸带上的一格，一串算珠上展示的数字便记录着当前格中的字符（可以是空白，可以是 12345 ）。人类的手即是读写头，可以更改每串算珠的状态。算盘的运行遵循人脑中的算法，当算法结束，算盘停机。\n\n# 图灵机可以解决什么问题\n\n在文章中，图灵所做的事是证明了，假设上述模型里所说的功能都能被以某种形式物理实现，那么任意可计算问题都可以被解决。这里所说的可计算问题，涉及到计算理论（Computation Theory）的概念。这个领域的概念很繁杂，先简单梳理一下。\n在计算机领域，或者说自动机领域，我们研究的一切问题都是计算问题（Computational Problem）。它泛指一切与计算相关的问题。\n> A computational problem is a mathematical object representing a collection of questions that computers might be able to solve.\n\n计算问题的一些举例：\n - 给定一个正整数 n，判断它是否是质数\n - 给定一个 01 序列，把它们按位取反\n - 给定一个字符串，判断某个字符是否存在，及查找存在位置\n - 给定一个逻辑蕴含的命题，求它的逆否命题\n非计算问题的例子：\n - 今晚吃什么\n - 为什么太阳从东边升起\n\n计算问题有的可以解决，有的不可解决。这就引出了计算问题的可计算性（Computability）。它可以被理解为“是否存在一个算法，能解决在任何输入下的此计算问题”。如上面的问题 1，我们当然可以找到一个算法来解决判断任意正整数 n 是否为质数的问题（比如从2遍历到 n-1，看 n 是否可以整除它）。所以，问题 1 就是可计算的。\n\n也有一些不可计算的计算问题，比如著名的停机问题（Halting Problem）。它的表述是这样的：给定一段程序的描述和该程序的一个有效输入，运行此程序，那么程序最终是会终止，还是会死循环下去？\n > Halting Problem: given the description of an arbitrary program and a finite input, decide whether the program finishes running or will run forever. \n\n这个问题很绕人，有点像那个著名的理发师悖论，但它确实是一个计算问题。更具体的，它是一个不可判定问题（Undecidable Problem）。即不存在一个通用算法，可以在任意输入下解决此问题。图灵在文章里很优雅的用反证法推翻了假设“假设有这么一个算法可以解决任何停机问题”，从而证明了这样的算法并不存在。具体证明过程网上的资料非常丰富，我就不再花篇幅了。\n\n回到这一节的主题。简而言之，对于一个问题，对于任意输入，只要人类可以保证算出结果（不管花多少时间），那么图灵机就可以保证算出结果（不管花多少时间）。\n\n# 什么是图灵完备\n\n图灵完备性（Turing Completeness）是针对一套数据操作规则而言的概念。数据操作规则可以是一门编程语言，也可以是计算机里具体实现了的指令集。当这套规则可以实现图灵机模型里的全部功能时，就称它具有图灵完备性。直白一点说，图灵完备性就是我给你一工具箱的东西，包括无限内存、if/else 控制流、while 循环……那么你现在图灵完备了吗？\n\n概念本身倒是非常直观，但整件事似乎还是让人云里雾里。我曾经一直不懂的就是为什么图灵给出的那个命题是正确的。换句话说，凭什么有了纸带以及其他的那一套东西，就可以自信解决任意可计算问题呢？尽管我不能通读他的那篇论文里的证明，但是通过一门叫做 Brainfuck 的编程语言，还是可以获得一些直觉。\n\n# 直观理解图灵完备——Brainfuck 语言\n\n如今主流的编程语言（C++，Java，Python，以及等等等等）都是图灵完备的语言。关于语言优劣之争也只是在其封装、优化等方面，以及因为这些区别而产生的“不同语言适用于不同情况”的争执。如果我们回到最底层，就会发现它们可以实现的功能其实完全一样，并且本质上就是一个图灵机。在1993年，Urban Müller 发明了 Brainfuck 语言。这门语言可以说是编程语言界的 helloworld 了——它一共只含有 8 个有效字符，每个有效字符就是一条指令。语言虽然极致轻量，它却是一门图灵完备的编程语言。如果能理解它的工作原理，那么对于理解图灵机是有很大帮助的。\n > Brainfuck is fully Turing-complete.\n\n先贴上一段 BF 的代码，体验一下它的画风：\n```Brainfuck\n++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++\n.------.--------.>>+.>++.\n```\n这个程序编译运行后，控制台打印 \"Hello World!\"。\n\nBF 的工作机制与图灵机高度一致。首先它存储数据的方式是一个不限长的一维整数数组，里面的数值全部初始化为 0。此外，有一数据指针，每一时刻都指向数组的某一任意元素。指针可以向左/右移动，也可以读取/修改当前值。\n\n语言里的 8 个有效字符分别是：\n - `>` ---- 指针向右移动一格\n - `<` ---- 指针向左移动一格\n - `+` ---- 使指针当前格数值加一\n - `-` ---- 使指针当前格数值减一\n - `.` ---- 把当前格数值按 ASCII 表输出到终端\n - `,` ---- 从终端接受一 byte 的数据，存储其 ASCII 数值到当前格\n - `[` ---- 当指针当前值为 0 时，程序跳转至与之对应的 `]` 之后；否则程序正常执行\n - `]` ---- 程序跳转回与之对应的 `[` 处\n\n有了这些工具，我们可以很快做出一个计算乘法的程序。因为 ASCII 表中 'A' 对应的值为 65，可以使用 5 * 13 算出 65 并输出得到字符 'A'。\n```Brainfuck\n+++++\n[\n>+++++++++++++\n<-\n]\n>.\n```\n\n把指针初始处的格子命名为 cell 0，cell 0 右边的那个格子命名为 cell 1。那么第一句将其递增 5 次变为 5。然后，循环执行“右移指针，递增 13 次， 左移指针，递减 1 次”。当 cell 0 的值最终被递减为 0 的时候，循环结束。此时 cell 1 的值执行了 5 次“递增 13 次”的操作，即 65。指针右移至 cell 1，输出此格子，则在终端会看到 'A'。\n\n编译运行上述代码块我写这个例子的目的是演示只用图灵机的模型，就可以确实计算出乘法的结果。那么自然更加复杂的计算也可以被拆解成图灵机操作（尽管可能非常琐碎）。此外，这个语言因为简洁，也是第一次练习写编译器的一个非常好的选择。","slug":"theory-turing-completeness","published":1,"updated":"2021-12-30T03:05:08.334Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxsdzpz5001exotg5gzjgm4a","content":"<p>这是一篇旨在帮助理解图灵完备及相关概念是什么，而非证明其正确性的回答，它包含以下内容：<br>什么是图灵机图灵机<br>可以解决什么问题<br>什么是图灵完备<br>直观理解图灵完备——Brainfuck语言</p>\n<h1 id=\"什么是图灵机\"><a href=\"#什么是图灵机\" class=\"headerlink\" title=\"什么是图灵机\"></a>什么是图灵机</h1><p>图灵机（Turing Machine）是图灵在1936年发表的 “On Computable Numbers, with an Application to the Entscheidungsproblem”（《论可计算数及其在判定性问题上的应用》）中提出的数学模型。既然是数学模型，它就并非一个实体概念，而是架空的一个想法。在文章中图灵描述了它是什么，并且证明了，只要图灵机可以被实现，就可以用来解决任何可计算问题。</p>\n<p>图灵机的结构包括以下几个部分：一条无限长的纸带（tape），纸带被分成一个个相邻的格子（square），每个格子都可以写上至多一个字符（symbol）。一个字符表（alphabet），即字符的集合，它包含纸带上可能出现的所有字符。其中包含一个特殊的空白字符（blank），意思是此格子没有任何字符。一个读写头（head），可理解为指向其中一个格子的指针。它可以读取/擦除/写入当前格子的内容，此外也可以每次向左/右移动一个格子。一个状态寄存器（state register），它追踪着每一步运算过程中，整个机器所处的状态（运行/终止）。当这个状态从运行变为终止，则运算结束，机器停机并交回控制权。如果你了解有限状态机，它便对应着有限状态机里的状态。一个有限的指令集（instructions table），它记录着读写头在特定情况下应该执行的行为。可以想象读写头随身有一本操作指南，里面记录着很多条类似于“当你身处编号53的格子并看到其内容为0时，擦除，改写为1，并向右移一格。此外，令下一状态为运行。”这样的命令。其实某种意义上，这个指令集就对应着程序员所写下的程序了。</p>\n<p>在计算开始前，纸带可以是完全空白，也可以在某些格子里预先就有写上部分字符作为输入。运算开始时，读写头从某一位置开始，严格按照此刻的配置（configuration），即：</p>\n<ul>\n<li>当前所处位置</li>\n<li>当前格子内容</li>\n</ul>\n<p>来一步步的对照着指令集去进行操作，直到状态变为停止，运算结束。而后纸带上留下的信息，即字符的序列（比如类似“…011001…”）便作为输出，由人来解码为自然语言。</p>\n<p>要重申一下，以上只是图灵机模型的内容，而非具体的实现。所谓的纸带和读写头都只是图灵提出的抽象概念。为便于理解打一个比方。算盘虽然不是图灵机（因为它没有无限长的纸带，即无限的存储空间），但它的行为与图灵机一致。每一串算珠都是纸带上的一格，一串算珠上展示的数字便记录着当前格中的字符（可以是空白，可以是 12345 ）。人类的手即是读写头，可以更改每串算珠的状态。算盘的运行遵循人脑中的算法，当算法结束，算盘停机。</p>\n<h1 id=\"图灵机可以解决什么问题\"><a href=\"#图灵机可以解决什么问题\" class=\"headerlink\" title=\"图灵机可以解决什么问题\"></a>图灵机可以解决什么问题</h1><p>在文章中，图灵所做的事是证明了，假设上述模型里所说的功能都能被以某种形式物理实现，那么任意可计算问题都可以被解决。这里所说的可计算问题，涉及到计算理论（Computation Theory）的概念。这个领域的概念很繁杂，先简单梳理一下。<br>在计算机领域，或者说自动机领域，我们研究的一切问题都是计算问题（Computational Problem）。它泛指一切与计算相关的问题。</p>\n<blockquote>\n<p>A computational problem is a mathematical object representing a collection of questions that computers might be able to solve.</p>\n</blockquote>\n<p>计算问题的一些举例：</p>\n<ul>\n<li>给定一个正整数 n，判断它是否是质数</li>\n<li>给定一个 01 序列，把它们按位取反</li>\n<li>给定一个字符串，判断某个字符是否存在，及查找存在位置</li>\n<li>给定一个逻辑蕴含的命题，求它的逆否命题<br>非计算问题的例子：</li>\n<li>今晚吃什么</li>\n<li>为什么太阳从东边升起</li>\n</ul>\n<p>计算问题有的可以解决，有的不可解决。这就引出了计算问题的可计算性（Computability）。它可以被理解为“是否存在一个算法，能解决在任何输入下的此计算问题”。如上面的问题 1，我们当然可以找到一个算法来解决判断任意正整数 n 是否为质数的问题（比如从2遍历到 n-1，看 n 是否可以整除它）。所以，问题 1 就是可计算的。</p>\n<p>也有一些不可计算的计算问题，比如著名的停机问题（Halting Problem）。它的表述是这样的：给定一段程序的描述和该程序的一个有效输入，运行此程序，那么程序最终是会终止，还是会死循环下去？</p>\n<blockquote>\n<p>Halting Problem: given the description of an arbitrary program and a finite input, decide whether the program finishes running or will run forever. </p>\n</blockquote>\n<p>这个问题很绕人，有点像那个著名的理发师悖论，但它确实是一个计算问题。更具体的，它是一个不可判定问题（Undecidable Problem）。即不存在一个通用算法，可以在任意输入下解决此问题。图灵在文章里很优雅的用反证法推翻了假设“假设有这么一个算法可以解决任何停机问题”，从而证明了这样的算法并不存在。具体证明过程网上的资料非常丰富，我就不再花篇幅了。</p>\n<p>回到这一节的主题。简而言之，对于一个问题，对于任意输入，只要人类可以保证算出结果（不管花多少时间），那么图灵机就可以保证算出结果（不管花多少时间）。</p>\n<h1 id=\"什么是图灵完备\"><a href=\"#什么是图灵完备\" class=\"headerlink\" title=\"什么是图灵完备\"></a>什么是图灵完备</h1><p>图灵完备性（Turing Completeness）是针对一套数据操作规则而言的概念。数据操作规则可以是一门编程语言，也可以是计算机里具体实现了的指令集。当这套规则可以实现图灵机模型里的全部功能时，就称它具有图灵完备性。直白一点说，图灵完备性就是我给你一工具箱的东西，包括无限内存、if/else 控制流、while 循环……那么你现在图灵完备了吗？</p>\n<p>概念本身倒是非常直观，但整件事似乎还是让人云里雾里。我曾经一直不懂的就是为什么图灵给出的那个命题是正确的。换句话说，凭什么有了纸带以及其他的那一套东西，就可以自信解决任意可计算问题呢？尽管我不能通读他的那篇论文里的证明，但是通过一门叫做 Brainfuck 的编程语言，还是可以获得一些直觉。</p>\n<h1 id=\"直观理解图灵完备——Brainfuck-语言\"><a href=\"#直观理解图灵完备——Brainfuck-语言\" class=\"headerlink\" title=\"直观理解图灵完备——Brainfuck 语言\"></a>直观理解图灵完备——Brainfuck 语言</h1><p>如今主流的编程语言（C++，Java，Python，以及等等等等）都是图灵完备的语言。关于语言优劣之争也只是在其封装、优化等方面，以及因为这些区别而产生的“不同语言适用于不同情况”的争执。如果我们回到最底层，就会发现它们可以实现的功能其实完全一样，并且本质上就是一个图灵机。在1993年，Urban Müller 发明了 Brainfuck 语言。这门语言可以说是编程语言界的 helloworld 了——它一共只含有 8 个有效字符，每个有效字符就是一条指令。语言虽然极致轻量，它却是一门图灵完备的编程语言。如果能理解它的工作原理，那么对于理解图灵机是有很大帮助的。</p>\n<blockquote>\n<p>Brainfuck is fully Turing-complete.</p>\n</blockquote>\n<p>先贴上一段 BF 的代码，体验一下它的画风：</p>\n<figure class=\"highlight brainfuck\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">++<span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"title\">[</span>&gt;++<span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"title\">[</span>&gt;++&gt;++<span class=\"literal\">+</span>&gt;++<span class=\"literal\">+</span>&gt;<span class=\"literal\">+</span>&lt;&lt;&lt;&lt;<span class=\"literal\">-</span><span class=\"title\">]</span>&gt;<span class=\"literal\">+</span>&gt;<span class=\"literal\">+</span>&gt;<span class=\"literal\">-</span>&gt;&gt;<span class=\"literal\">+</span><span class=\"title\">[</span>&lt;<span class=\"title\">]</span>&lt;<span class=\"literal\">-</span><span class=\"title\">]</span>&gt;&gt;<span class=\"string\">.</span>&gt;--<span class=\"literal\">-</span><span class=\"string\">.</span>++<span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"string\">.</span><span class=\"string\">.</span>++<span class=\"literal\">+</span><span class=\"string\">.</span>&gt;&gt;<span class=\"string\">.</span>&lt;<span class=\"literal\">-</span><span class=\"string\">.</span>&lt;<span class=\"string\">.</span>++<span class=\"literal\">+</span></span><br><span class=\"line\"><span class=\"string\">.</span>--<span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"string\">.</span>--<span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"string\">.</span>&gt;&gt;<span class=\"literal\">+</span><span class=\"string\">.</span>&gt;++<span class=\"string\">.</span></span><br></pre></td></tr></table></figure>\n<p>这个程序编译运行后，控制台打印 “Hello World!”。</p>\n<p>BF 的工作机制与图灵机高度一致。首先它存储数据的方式是一个不限长的一维整数数组，里面的数值全部初始化为 0。此外，有一数据指针，每一时刻都指向数组的某一任意元素。指针可以向左/右移动，也可以读取/修改当前值。</p>\n<p>语言里的 8 个有效字符分别是：</p>\n<ul>\n<li><code>&gt;</code> —- 指针向右移动一格</li>\n<li><code>&lt;</code> —- 指针向左移动一格</li>\n<li><code>+</code> —- 使指针当前格数值加一</li>\n<li><code>-</code> —- 使指针当前格数值减一</li>\n<li><code>.</code> —- 把当前格数值按 ASCII 表输出到终端</li>\n<li><code>,</code> —- 从终端接受一 byte 的数据，存储其 ASCII 数值到当前格</li>\n<li><code>[</code> —- 当指针当前值为 0 时，程序跳转至与之对应的 <code>]</code> 之后；否则程序正常执行</li>\n<li><code>]</code> —- 程序跳转回与之对应的 <code>[</code> 处</li>\n</ul>\n<p>有了这些工具，我们可以很快做出一个计算乘法的程序。因为 ASCII 表中 ‘A’ 对应的值为 65，可以使用 5 * 13 算出 65 并输出得到字符 ‘A’。</p>\n<figure class=\"highlight brainfuck\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">++<span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span></span><br><span class=\"line\"><span class=\"title\">[</span></span><br><span class=\"line\">&gt;++<span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span></span><br><span class=\"line\">&lt;<span class=\"literal\">-</span></span><br><span class=\"line\"><span class=\"title\">]</span></span><br><span class=\"line\">&gt;<span class=\"string\">.</span></span><br></pre></td></tr></table></figure>\n\n<p>把指针初始处的格子命名为 cell 0，cell 0 右边的那个格子命名为 cell 1。那么第一句将其递增 5 次变为 5。然后，循环执行“右移指针，递增 13 次， 左移指针，递减 1 次”。当 cell 0 的值最终被递减为 0 的时候，循环结束。此时 cell 1 的值执行了 5 次“递增 13 次”的操作，即 65。指针右移至 cell 1，输出此格子，则在终端会看到 ‘A’。</p>\n<p>编译运行上述代码块我写这个例子的目的是演示只用图灵机的模型，就可以确实计算出乘法的结果。那么自然更加复杂的计算也可以被拆解成图灵机操作（尽管可能非常琐碎）。此外，这个语言因为简洁，也是第一次练习写编译器的一个非常好的选择。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这是一篇旨在帮助理解图灵完备及相关概念是什么，而非证明其正确性的回答，它包含以下内容：<br>什么是图灵机图灵机<br>可以解决什么问题<br>什么是图灵完备<br>直观理解图灵完备——Brainfuck语言</p>\n<h1 id=\"什么是图灵机\"><a href=\"#什么是图灵机\" class=\"headerlink\" title=\"什么是图灵机\"></a>什么是图灵机</h1><p>图灵机（Turing Machine）是图灵在1936年发表的 “On Computable Numbers, with an Application to the Entscheidungsproblem”（《论可计算数及其在判定性问题上的应用》）中提出的数学模型。既然是数学模型，它就并非一个实体概念，而是架空的一个想法。在文章中图灵描述了它是什么，并且证明了，只要图灵机可以被实现，就可以用来解决任何可计算问题。</p>\n<p>图灵机的结构包括以下几个部分：一条无限长的纸带（tape），纸带被分成一个个相邻的格子（square），每个格子都可以写上至多一个字符（symbol）。一个字符表（alphabet），即字符的集合，它包含纸带上可能出现的所有字符。其中包含一个特殊的空白字符（blank），意思是此格子没有任何字符。一个读写头（head），可理解为指向其中一个格子的指针。它可以读取/擦除/写入当前格子的内容，此外也可以每次向左/右移动一个格子。一个状态寄存器（state register），它追踪着每一步运算过程中，整个机器所处的状态（运行/终止）。当这个状态从运行变为终止，则运算结束，机器停机并交回控制权。如果你了解有限状态机，它便对应着有限状态机里的状态。一个有限的指令集（instructions table），它记录着读写头在特定情况下应该执行的行为。可以想象读写头随身有一本操作指南，里面记录着很多条类似于“当你身处编号53的格子并看到其内容为0时，擦除，改写为1，并向右移一格。此外，令下一状态为运行。”这样的命令。其实某种意义上，这个指令集就对应着程序员所写下的程序了。</p>\n<p>在计算开始前，纸带可以是完全空白，也可以在某些格子里预先就有写上部分字符作为输入。运算开始时，读写头从某一位置开始，严格按照此刻的配置（configuration），即：</p>\n<ul>\n<li>当前所处位置</li>\n<li>当前格子内容</li>\n</ul>\n<p>来一步步的对照着指令集去进行操作，直到状态变为停止，运算结束。而后纸带上留下的信息，即字符的序列（比如类似“…011001…”）便作为输出，由人来解码为自然语言。</p>\n<p>要重申一下，以上只是图灵机模型的内容，而非具体的实现。所谓的纸带和读写头都只是图灵提出的抽象概念。为便于理解打一个比方。算盘虽然不是图灵机（因为它没有无限长的纸带，即无限的存储空间），但它的行为与图灵机一致。每一串算珠都是纸带上的一格，一串算珠上展示的数字便记录着当前格中的字符（可以是空白，可以是 12345 ）。人类的手即是读写头，可以更改每串算珠的状态。算盘的运行遵循人脑中的算法，当算法结束，算盘停机。</p>\n<h1 id=\"图灵机可以解决什么问题\"><a href=\"#图灵机可以解决什么问题\" class=\"headerlink\" title=\"图灵机可以解决什么问题\"></a>图灵机可以解决什么问题</h1><p>在文章中，图灵所做的事是证明了，假设上述模型里所说的功能都能被以某种形式物理实现，那么任意可计算问题都可以被解决。这里所说的可计算问题，涉及到计算理论（Computation Theory）的概念。这个领域的概念很繁杂，先简单梳理一下。<br>在计算机领域，或者说自动机领域，我们研究的一切问题都是计算问题（Computational Problem）。它泛指一切与计算相关的问题。</p>\n<blockquote>\n<p>A computational problem is a mathematical object representing a collection of questions that computers might be able to solve.</p>\n</blockquote>\n<p>计算问题的一些举例：</p>\n<ul>\n<li>给定一个正整数 n，判断它是否是质数</li>\n<li>给定一个 01 序列，把它们按位取反</li>\n<li>给定一个字符串，判断某个字符是否存在，及查找存在位置</li>\n<li>给定一个逻辑蕴含的命题，求它的逆否命题<br>非计算问题的例子：</li>\n<li>今晚吃什么</li>\n<li>为什么太阳从东边升起</li>\n</ul>\n<p>计算问题有的可以解决，有的不可解决。这就引出了计算问题的可计算性（Computability）。它可以被理解为“是否存在一个算法，能解决在任何输入下的此计算问题”。如上面的问题 1，我们当然可以找到一个算法来解决判断任意正整数 n 是否为质数的问题（比如从2遍历到 n-1，看 n 是否可以整除它）。所以，问题 1 就是可计算的。</p>\n<p>也有一些不可计算的计算问题，比如著名的停机问题（Halting Problem）。它的表述是这样的：给定一段程序的描述和该程序的一个有效输入，运行此程序，那么程序最终是会终止，还是会死循环下去？</p>\n<blockquote>\n<p>Halting Problem: given the description of an arbitrary program and a finite input, decide whether the program finishes running or will run forever. </p>\n</blockquote>\n<p>这个问题很绕人，有点像那个著名的理发师悖论，但它确实是一个计算问题。更具体的，它是一个不可判定问题（Undecidable Problem）。即不存在一个通用算法，可以在任意输入下解决此问题。图灵在文章里很优雅的用反证法推翻了假设“假设有这么一个算法可以解决任何停机问题”，从而证明了这样的算法并不存在。具体证明过程网上的资料非常丰富，我就不再花篇幅了。</p>\n<p>回到这一节的主题。简而言之，对于一个问题，对于任意输入，只要人类可以保证算出结果（不管花多少时间），那么图灵机就可以保证算出结果（不管花多少时间）。</p>\n<h1 id=\"什么是图灵完备\"><a href=\"#什么是图灵完备\" class=\"headerlink\" title=\"什么是图灵完备\"></a>什么是图灵完备</h1><p>图灵完备性（Turing Completeness）是针对一套数据操作规则而言的概念。数据操作规则可以是一门编程语言，也可以是计算机里具体实现了的指令集。当这套规则可以实现图灵机模型里的全部功能时，就称它具有图灵完备性。直白一点说，图灵完备性就是我给你一工具箱的东西，包括无限内存、if/else 控制流、while 循环……那么你现在图灵完备了吗？</p>\n<p>概念本身倒是非常直观，但整件事似乎还是让人云里雾里。我曾经一直不懂的就是为什么图灵给出的那个命题是正确的。换句话说，凭什么有了纸带以及其他的那一套东西，就可以自信解决任意可计算问题呢？尽管我不能通读他的那篇论文里的证明，但是通过一门叫做 Brainfuck 的编程语言，还是可以获得一些直觉。</p>\n<h1 id=\"直观理解图灵完备——Brainfuck-语言\"><a href=\"#直观理解图灵完备——Brainfuck-语言\" class=\"headerlink\" title=\"直观理解图灵完备——Brainfuck 语言\"></a>直观理解图灵完备——Brainfuck 语言</h1><p>如今主流的编程语言（C++，Java，Python，以及等等等等）都是图灵完备的语言。关于语言优劣之争也只是在其封装、优化等方面，以及因为这些区别而产生的“不同语言适用于不同情况”的争执。如果我们回到最底层，就会发现它们可以实现的功能其实完全一样，并且本质上就是一个图灵机。在1993年，Urban Müller 发明了 Brainfuck 语言。这门语言可以说是编程语言界的 helloworld 了——它一共只含有 8 个有效字符，每个有效字符就是一条指令。语言虽然极致轻量，它却是一门图灵完备的编程语言。如果能理解它的工作原理，那么对于理解图灵机是有很大帮助的。</p>\n<blockquote>\n<p>Brainfuck is fully Turing-complete.</p>\n</blockquote>\n<p>先贴上一段 BF 的代码，体验一下它的画风：</p>\n<figure class=\"highlight brainfuck\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">++<span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"title\">[</span>&gt;++<span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"title\">[</span>&gt;++&gt;++<span class=\"literal\">+</span>&gt;++<span class=\"literal\">+</span>&gt;<span class=\"literal\">+</span>&lt;&lt;&lt;&lt;<span class=\"literal\">-</span><span class=\"title\">]</span>&gt;<span class=\"literal\">+</span>&gt;<span class=\"literal\">+</span>&gt;<span class=\"literal\">-</span>&gt;&gt;<span class=\"literal\">+</span><span class=\"title\">[</span>&lt;<span class=\"title\">]</span>&lt;<span class=\"literal\">-</span><span class=\"title\">]</span>&gt;&gt;<span class=\"string\">.</span>&gt;--<span class=\"literal\">-</span><span class=\"string\">.</span>++<span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"string\">.</span><span class=\"string\">.</span>++<span class=\"literal\">+</span><span class=\"string\">.</span>&gt;&gt;<span class=\"string\">.</span>&lt;<span class=\"literal\">-</span><span class=\"string\">.</span>&lt;<span class=\"string\">.</span>++<span class=\"literal\">+</span></span><br><span class=\"line\"><span class=\"string\">.</span>--<span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"string\">.</span>--<span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"string\">.</span>&gt;&gt;<span class=\"literal\">+</span><span class=\"string\">.</span>&gt;++<span class=\"string\">.</span></span><br></pre></td></tr></table></figure>\n<p>这个程序编译运行后，控制台打印 “Hello World!”。</p>\n<p>BF 的工作机制与图灵机高度一致。首先它存储数据的方式是一个不限长的一维整数数组，里面的数值全部初始化为 0。此外，有一数据指针，每一时刻都指向数组的某一任意元素。指针可以向左/右移动，也可以读取/修改当前值。</p>\n<p>语言里的 8 个有效字符分别是：</p>\n<ul>\n<li><code>&gt;</code> —- 指针向右移动一格</li>\n<li><code>&lt;</code> —- 指针向左移动一格</li>\n<li><code>+</code> —- 使指针当前格数值加一</li>\n<li><code>-</code> —- 使指针当前格数值减一</li>\n<li><code>.</code> —- 把当前格数值按 ASCII 表输出到终端</li>\n<li><code>,</code> —- 从终端接受一 byte 的数据，存储其 ASCII 数值到当前格</li>\n<li><code>[</code> —- 当指针当前值为 0 时，程序跳转至与之对应的 <code>]</code> 之后；否则程序正常执行</li>\n<li><code>]</code> —- 程序跳转回与之对应的 <code>[</code> 处</li>\n</ul>\n<p>有了这些工具，我们可以很快做出一个计算乘法的程序。因为 ASCII 表中 ‘A’ 对应的值为 65，可以使用 5 * 13 算出 65 并输出得到字符 ‘A’。</p>\n<figure class=\"highlight brainfuck\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">++<span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span></span><br><span class=\"line\"><span class=\"title\">[</span></span><br><span class=\"line\">&gt;++<span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span><span class=\"literal\">+</span></span><br><span class=\"line\">&lt;<span class=\"literal\">-</span></span><br><span class=\"line\"><span class=\"title\">]</span></span><br><span class=\"line\">&gt;<span class=\"string\">.</span></span><br></pre></td></tr></table></figure>\n\n<p>把指针初始处的格子命名为 cell 0，cell 0 右边的那个格子命名为 cell 1。那么第一句将其递增 5 次变为 5。然后，循环执行“右移指针，递增 13 次， 左移指针，递减 1 次”。当 cell 0 的值最终被递减为 0 的时候，循环结束。此时 cell 1 的值执行了 5 次“递增 13 次”的操作，即 65。指针右移至 cell 1，输出此格子，则在终端会看到 ‘A’。</p>\n<p>编译运行上述代码块我写这个例子的目的是演示只用图灵机的模型，就可以确实计算出乘法的结果。那么自然更加复杂的计算也可以被拆解成图灵机操作（尽管可能非常琐碎）。此外，这个语言因为简洁，也是第一次练习写编译器的一个非常好的选择。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckxsdzpxx0001xotg65yafs9i","category_id":"ckxsdzpy50004xotg087w2j5w","_id":"ckxsdzpyg000cxotgb8b3azcx"},{"post_id":"ckxsdzpy80006xotgf8gsfdnb","category_id":"ckxsdzpyd0009xotg7114am3u","_id":"ckxsdzpyk000hxotg00i261ua"},{"post_id":"ckxsdzpya0007xotg13uchtu0","category_id":"ckxsdzpyg000dxotgbnsjarwf","_id":"ckxsdzpyr000nxotgc4c560jw"},{"post_id":"ckxsdzpyj000gxotgc1s61qa7","category_id":"ckxsdzpyg000dxotgbnsjarwf","_id":"ckxsdzpyt000qxotg2psu7m3t"},{"post_id":"ckxsdzpym000jxotg96oo7rra","category_id":"ckxsdzpyg000dxotgbnsjarwf","_id":"ckxsdzpyv000txotghwu5gul0"},{"post_id":"ckxsdzpyb0008xotgekce7p56","category_id":"ckxsdzpyg000dxotgbnsjarwf","_id":"ckxsdzpyx000xxotg47vl5955"},{"post_id":"ckxsdzpys000pxotga2iw86jk","category_id":"ckxsdzpyg000dxotgbnsjarwf","_id":"ckxsdzpyz0010xotg60gvh9zt"},{"post_id":"ckxsdzpye000axotg528s5jom","category_id":"ckxsdzpyr000mxotge5xqgrtr","_id":"ckxsdzpz10014xotg2seb2b9r"},{"post_id":"ckxsdzpyt000rxotg46dx0vzu","category_id":"ckxsdzpyg000dxotgbnsjarwf","_id":"ckxsdzpz20016xotgc26tgpbq"},{"post_id":"ckxsdzpyv000vxotgg27783me","category_id":"ckxsdzpy50004xotg087w2j5w","_id":"ckxsdzpz4001bxotg9wql1wqt"},{"post_id":"ckxsdzpyf000bxotg7gxz7t70","category_id":"ckxsdzpyg000dxotgbnsjarwf","_id":"ckxsdzpz5001dxotg60rlcens"},{"post_id":"ckxsdzpyh000exotg922w7a6o","category_id":"ckxsdzpyg000dxotgbnsjarwf","_id":"ckxsdzpz7001hxotgbk018ip4"},{"post_id":"ckxsdzpyh000exotg922w7a6o","category_id":"ckxsdzpyz0011xotgeu895910","_id":"ckxsdzpz8001jxotg4omba035"},{"post_id":"ckxsdzpyp000kxotg3azoa26w","category_id":"ckxsdzpyg000dxotgbnsjarwf","_id":"ckxsdzpz9001mxotgdczka4z2"},{"post_id":"ckxsdzpyp000kxotg3azoa26w","category_id":"ckxsdzpyz0011xotgeu895910","_id":"ckxsdzpz9001oxotgffzs8q8r"},{"post_id":"ckxsdzpyx000yxotgbky136mi","category_id":"ckxsdzpz6001gxotg7vrz8bz1","_id":"ckxsdzpza001rxotg92d5djh5"},{"post_id":"ckxsdzpz10015xotgg4ppd5tt","category_id":"ckxsdzpz8001lxotg3mw83p5p","_id":"ckxsdzpzb001uxotgcuug41te"},{"post_id":"ckxsdzpz20018xotg9bmc867m","category_id":"ckxsdzpz8001lxotg3mw83p5p","_id":"ckxsdzpzd001xxotgdh9qbznw"},{"post_id":"ckxsdzpz4001cxotg4oyh0xr2","category_id":"ckxsdzpz8001lxotg3mw83p5p","_id":"ckxsdzpzd0020xotgg73tfg9o"},{"post_id":"ckxsdzpz5001exotg5gzjgm4a","category_id":"ckxsdzpzc001wxotgff1x5cxf","_id":"ckxsdzpze0023xotgfww761z6"}],"PostTag":[{"post_id":"ckxsdzpyf000bxotg7gxz7t70","tag_id":"ckxsdzpyi000fxotgd0yyb9ex","_id":"ckxsdzpyr000oxotghbbebugp"},{"post_id":"ckxsdzpyh000exotg922w7a6o","tag_id":"ckxsdzpyq000lxotg45b2176h","_id":"ckxsdzpyw000wxotg5cni6u0x"},{"post_id":"ckxsdzpyp000kxotg3azoa26w","tag_id":"ckxsdzpyu000sxotgcam3a7tb","_id":"ckxsdzpz00013xotg4sunhnzj"},{"post_id":"ckxsdzpys000pxotga2iw86jk","tag_id":"ckxsdzpyy000zxotgczl1e2u0","_id":"ckxsdzpz4001axotg19cx2dcs"},{"post_id":"ckxsdzpyt000rxotg46dx0vzu","tag_id":"ckxsdzpz20017xotgbr7mgmya","_id":"ckxsdzpz7001ixotga83l85re"},{"post_id":"ckxsdzpyv000vxotgg27783me","tag_id":"ckxsdzpz6001fxotg9681c32n","_id":"ckxsdzpz9001nxotg0n6t06re"},{"post_id":"ckxsdzpyz0012xotg2tceetz9","tag_id":"ckxsdzpz8001kxotgbg7g9okn","_id":"ckxsdzpza001sxotg57cp3me3"},{"post_id":"ckxsdzpz10015xotgg4ppd5tt","tag_id":"ckxsdzpz9001pxotghjibfctj","_id":"ckxsdzpzd001zxotga4aeduou"},{"post_id":"ckxsdzpz10015xotgg4ppd5tt","tag_id":"ckxsdzpzb001vxotg84x6hmmn","_id":"ckxsdzpze0021xotgb3pya25j"},{"post_id":"ckxsdzpz5001exotg5gzjgm4a","tag_id":"ckxsdzpzd001yxotg9fi57plw","_id":"ckxsdzpze0022xotgfe3k6pjd"}],"Tag":[{"name":"ClassLoader","_id":"ckxsdzpyi000fxotgd0yyb9ex"},{"name":"factory pattern","_id":"ckxsdzpyq000lxotg45b2176h"},{"name":"Proxy","_id":"ckxsdzpyu000sxotgcam3a7tb"},{"name":"Reflection","_id":"ckxsdzpyy000zxotgczl1e2u0"},{"name":"Stream","_id":"ckxsdzpz20017xotgbr7mgmya"},{"name":"maven","_id":"ckxsdzpz6001fxotg9681c32n"},{"name":"Serialization","_id":"ckxsdzpz8001kxotgbg7g9okn"},{"name":"AOP","_id":"ckxsdzpz9001pxotghjibfctj"},{"name":"Spring","_id":"ckxsdzpzb001vxotg84x6hmmn"},{"name":"Turing","_id":"ckxsdzpzd001yxotg9fi57plw"}]}}